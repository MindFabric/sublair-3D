<!DOCTYPE html>
<html>

<head>
	<title>SUBLAIR 3D</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Primary Meta Tags -->
	<meta name="title" content="SUBLAIR 3D">
	<meta name="description" content="The 3D Sublair experience. Discover music again.">
	<meta name="keywords" content="SUBLAIR, 3D world, music experience, interactive, virtual world">
	<meta name="author" content="SUBLAIR">

	<!-- Favicon -->
	<link rel="icon" type="image/png" href="/public/CIRCLE.png">

	<!-- Open Graph / Facebook -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://3d.sublair.com/">
	<meta property="og:title" content="SUBLAIR 3D">
	<meta property="og:description" content="The 3D Sublair experience. Discover music again.">
	<meta property="og:image" content="https://3d.sublair.com/public/social%20card.png">
	<meta property="og:image:width" content="1200">
	<meta property="og:image:height" content="630">
	<meta property="og:image:alt" content="SUBLAIR 3D - The 3D music experience">

	<!-- Twitter -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:url" content="https://3d.sublair.com/">
	<meta name="twitter:title" content="SUBLAIR 3D">
	<meta name="twitter:description" content="The 3D Sublair experience. Discover music again.">
	<meta name="twitter:image" content="https://3d.sublair.com/public/social%20card.png">

	<!-- Fonts -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Share:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}

		/* Fix z-index hierarchy */
		#canvas {
			position: fixed;
			top: 0;
			left: 0;
			z-index: 1;
		}

		#ui-container {
			z-index: 100 !important;
			pointer-events: none;
		}

		#ui-container * {
			pointer-events: auto;
		}

		/* Dark sleek customize button */
		.customize-button {
			position: fixed !important;
			bottom: 30px !important;
			right: 30px !important;
			background: rgba(0, 0, 0, 0.8) !important;
			color: #fff !important;
			border: 1px solid rgba(255, 255, 255, 0.2) !important;
			padding: 12px 24px !important;
			border-radius: 8px !important;
			font-family: 'Lucida Grande', 'Lucida Sans Unicode', Arial, sans-serif !important;
			font-size: 12px !important;
			font-weight: 600 !important;
			cursor: pointer !important;
			z-index: 10000 !important;
			backdrop-filter: blur(10px) !important;
			transition: all 0.2s ease !important;
			text-transform: uppercase !important;
			letter-spacing: 1px !important;
			pointer-events: auto !important;
		}

		.customize-button:hover {
			background: rgba(255, 255, 255, 0.15) !important;
			border-color: rgba(255, 255, 255, 0.4) !important;
			transform: translateY(-2px);
		}

		.customize-button:active {
			transform: translateY(0px);
		}

		.controls-panel {
			position: fixed !important;
			bottom: 90px !important;
			right: 30px !important;
			background: rgba(0, 0, 0, 0.8) !important;
			color: rgba(255, 255, 255, 0.8) !important;
			border: 1px solid rgba(255, 255, 255, 0.2) !important;
			padding: 16px !important;
			border-radius: 8px !important;
			font-family: 'Lucida Grande', 'Lucida Sans Unicode', Arial, sans-serif !important;
			font-size: 11px !important;
			z-index: 10000 !important;
			backdrop-filter: blur(10px) !important;
			pointer-events: none !important;
			line-height: 1.6 !important;
		}

		/* Custom character menu - Compact LBP Style */
		.character-customization {
			position: fixed;
			top: 20px;
			left: 20px;
			background: rgba(0, 0, 0, 0.95);
			padding: 0;
			border-radius: 12px;
			font-family: 'Share Tech Mono', monospace;
			color: #bee17b;
			z-index: 99999;
			width: 320px;
			overflow: hidden;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.9),
						inset 0 0 0 1px rgba(190, 225, 123, 0.3),
						0 0 20px rgba(190, 225, 123, 0.1);
			opacity: 0;
			transform: translateY(-10px) scale(0.98);
			pointer-events: none;
			transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
		}

		.character-customization.active {
			opacity: 1;
			transform: translateY(0) scale(1);
			pointer-events: auto;
		}

		.character-customization h3 {
			margin: 0;
			padding: 12px 16px;
			font-size: 11px;
			font-weight: 400;
			letter-spacing: 3px;
			color: #bee17b;
			text-transform: uppercase;
			background: rgba(190, 225, 123, 0.1);
			border-bottom: 2px solid rgba(190, 225, 123, 0.3);
			text-align: center;
		}

		.customization-tabs {
			display: flex;
			gap: 0;
			background: rgba(0, 0, 0, 0.3);
			border-bottom: 1px solid rgba(190, 225, 123, 0.2);
		}

		.customization-tab {
			flex: 1;
			padding: 10px;
			background: transparent;
			border: none;
			color: rgba(190, 225, 123, 0.5);
			font-family: 'Share Tech Mono', monospace;
			font-size: 9px;
			letter-spacing: 1px;
			text-transform: uppercase;
			cursor: pointer;
			transition: all 0.2s ease;
			border-bottom: 2px solid transparent;
		}

		.customization-tab:hover {
			background: rgba(190, 225, 123, 0.05);
			color: rgba(190, 225, 123, 0.8);
		}

		.customization-tab.active {
			color: #bee17b;
			border-bottom-color: #bee17b;
			background: rgba(190, 225, 123, 0.1);
		}

		.customization-content {
			padding: 12px;
			max-height: 450px;
			overflow-y: auto;
		}

		.customization-content::-webkit-scrollbar {
			width: 4px;
		}

		.customization-content::-webkit-scrollbar-track {
			background: transparent;
		}

		.customization-content::-webkit-scrollbar-thumb {
			background: rgba(190, 225, 123, 0.3);
			border-radius: 2px;
		}

		.customization-content::-webkit-scrollbar-thumb:hover {
			background: rgba(190, 225, 123, 0.5);
		}

		.customization-section {
			margin-bottom: 12px;
			background: rgba(190, 225, 123, 0.05);
			padding: 10px;
			border-radius: 8px;
			border: 1px solid rgba(190, 225, 123, 0.15);
		}

		.customization-section:last-child {
			margin-bottom: 0;
		}

		.customization-footer {
			padding: 15px;
			border-top: 1px solid rgba(190, 225, 123, 0.2);
			display: flex;
			justify-content: center;
			background: rgba(0, 0, 0, 0.3);
		}

		.reset-defaults-button {
			padding: 10px 20px;
			background: rgba(190, 225, 123, 0.1);
			border: 1px solid rgba(190, 225, 123, 0.3);
			border-radius: 6px;
			color: #bee17b;
			font-family: 'Courier New', monospace;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.reset-defaults-button:hover {
			background: rgba(190, 225, 123, 0.2);
			border-color: #bee17b;
			transform: translateY(-1px);
		}

		.reset-defaults-button:active {
			transform: translateY(0);
		}

		.section-label {
			font-size: 9px;
			font-weight: 400;
			letter-spacing: 2px;
			color: #bee17b;
			margin-bottom: 8px;
			text-transform: uppercase;
			opacity: 0.8;
		}

		/* Collapsible sections */
		.collapsible-section {
			margin-bottom: 12px;
			border: 1px solid rgba(190, 225, 123, 0.2);
			border-radius: 8px;
			overflow: hidden;
			background: rgba(0, 0, 0, 0.3);
		}

		.collapsible-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 10px 12px;
			background: rgba(190, 225, 123, 0.1);
			cursor: pointer;
			user-select: none;
			transition: all 0.2s ease;
		}

		.collapsible-header:hover {
			background: rgba(190, 225, 123, 0.15);
		}

		.collapsible-title {
			font-size: 10px;
			font-weight: 600;
			letter-spacing: 2px;
			color: #bee17b;
			text-transform: uppercase;
		}

		.collapsible-arrow {
			font-size: 12px;
			color: #bee17b;
			transition: transform 0.2s ease;
		}

		.collapsible-section.collapsed .collapsible-arrow {
			transform: rotate(-90deg);
		}

		.collapsible-content {
			padding: 10px;
			max-height: 1000px;
			overflow-y: auto;
			transition: max-height 0.3s ease, padding 0.3s ease;
		}

		.collapsible-content::-webkit-scrollbar {
			width: 4px;
		}

		.collapsible-content::-webkit-scrollbar-track {
			background: transparent;
		}

		.collapsible-content::-webkit-scrollbar-thumb {
			background: rgba(190, 225, 123, 0.3);
			border-radius: 2px;
		}

		.collapsible-content::-webkit-scrollbar-thumb:hover {
			background: rgba(190, 225, 123, 0.5);
		}

		.collapsible-section.collapsed .collapsible-content {
			max-height: 0;
			padding: 0 10px;
		}

		.color-picker-container {
			display: flex;
			align-items: center;
			gap: 8px;
			margin-bottom: 8px;
			padding: 6px;
			background: rgba(0, 0, 0, 0.4);
			border-radius: 6px;
			border: 1px solid rgba(190, 225, 123, 0.2);
		}

		.color-picker-container input[type="color"] {
			width: 32px;
			height: 32px;
			border: 2px solid rgba(190, 225, 123, 0.3);
			border-radius: 6px;
			background: transparent;
			cursor: pointer;
			transition: all 0.15s ease;
		}

		.color-picker-container input[type="color"]:hover {
			border-color: #bee17b;
			transform: scale(1.08);
		}

		.color-picker-container input[type="color"]::-webkit-color-swatch-wrapper {
			padding: 0;
		}

		.color-picker-container input[type="color"]::-webkit-color-swatch {
			border: none;
			border-radius: 4px;
		}

		.color-info {
			flex: 1;
		}

		.color-info-label {
			font-size: 8px;
			text-transform: uppercase;
			letter-spacing: 1px;
			color: rgba(190, 225, 123, 0.6);
			margin-bottom: 2px;
		}

		.color-info-value {
			font-size: 11px;
			font-weight: 400;
			font-family: 'Share Tech Mono', monospace;
			color: #bee17b;
			letter-spacing: 1px;
		}

		.texture-grid {
			display: grid;
			grid-template-columns: repeat(4, 1fr);
			gap: 6px;
			margin-bottom: 8px;
		}

		.texture-option {
			aspect-ratio: 1;
			border-radius: 6px;
			cursor: pointer;
			border: 2px solid rgba(190, 225, 123, 0.25);
			transition: all 0.15s cubic-bezier(0.34, 1.56, 0.64, 1);
			position: relative;
			overflow: hidden;
			background: rgba(0, 0, 0, 0.3);
		}

		.texture-option.selected {
			border-color: #bee17b;
			box-shadow: 0 0 10px rgba(190, 225, 123, 0.4),
						inset 0 0 10px rgba(190, 225, 123, 0.1);
			transform: scale(1.05);
		}

		.texture-option:hover {
			transform: scale(1.08);
			border-color: rgba(190, 225, 123, 0.6);
		}

		.texture-controls {
			display: flex;
			flex-direction: column;
			gap: 6px;
			margin-top: 8px;
		}

		.control-row {
			display: flex;
			align-items: center;
			justify-content: space-between;
			background: rgba(0, 0, 0, 0.3);
			padding: 4px 8px;
			border-radius: 4px;
		}

		.control-row label {
			font-size: 8px;
			text-transform: uppercase;
			letter-spacing: 1px;
			color: rgba(190, 225, 123, 0.7);
			font-weight: 400;
			min-width: 50px;
		}

		.control-row input[type="range"] {
			flex: 1;
			margin: 0 8px;
			height: 2px;
			border-radius: 1px;
			background: rgba(190, 225, 123, 0.2);
			outline: none;
			-webkit-appearance: none;
		}

		.control-row input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 12px;
			height: 12px;
			border-radius: 50%;
			background: #bee17b;
			cursor: pointer;
			border: 2px solid rgba(0, 0, 0, 0.8);
			box-shadow: 0 0 4px rgba(190, 225, 123, 0.5);
		}

		.control-row input[type="range"]::-moz-range-thumb {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			background: #bee17b;
			cursor: pointer;
			border: 2px solid rgba(0, 0, 0, 0.8);
			box-shadow: 0 0 4px rgba(190, 225, 123, 0.5);
		}

		.control-value {
			font-size: 9px;
			color: #bee17b;
			font-weight: 400;
			min-width: 35px;
			text-align: right;
			font-family: 'Share Tech Mono', monospace;
			opacity: 0.8;
		}

		.preset-colors {
			display: grid;
			grid-template-columns: repeat(6, 1fr);
			gap: 10px;
		}

		.preset-color {
			aspect-ratio: 1;
			border-radius: 10px;
			cursor: pointer;
			border: 2.5px solid rgba(255, 255, 255, 0.15);
			transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
			position: relative;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
		}

		.preset-color::after {
			content: '';
			position: absolute;
			inset: 0;
			border-radius: 8px;
			background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 50%);
			opacity: 0;
			transition: opacity 0.25s ease;
		}

		.preset-color:hover::after {
			opacity: 1;
		}

		.preset-color.selected {
			border-color: #fff;
			box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3), 0 4px 16px rgba(0, 0, 0, 0.5);
			transform: scale(1.05);
		}

		.preset-color.selected::before {
			content: '✓';
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: rgba(255, 255, 255, 0.9);
			font-size: 14px;
			font-weight: bold;
			text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
		}

		.preset-color:hover {
			transform: scale(1.08);
			border-color: rgba(255, 255, 255, 0.4);
		}

		.preset-colors-label {
			font-size: 11px;
			text-transform: uppercase;
			letter-spacing: 0.5px;
			color: rgba(255, 255, 255, 0.4);
			margin-bottom: 10px;
		}

		/* OS Container */
		.terminal-login {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%) scale(0.9);
			background: rgba(0, 0, 0, 0.95);
			border: 4px solid #bee17b;
			border-radius: 0;
			padding: 0;
			font-family: 'Share', 'Courier New', monospace;
			color: #bee17b;
			z-index: 10000;
			width: 900px;
			height: 600px;
			opacity: 0;
			pointer-events: none;
			transition: all 0.3s ease;
			box-shadow: 0 0 30px rgba(190, 225, 123, 0.5);
			overflow: hidden;
		}

		/* OS Container Scrollbar (if needed) */
		.terminal-login::-webkit-scrollbar {
			width: 16px;
		}

		.terminal-login::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		.terminal-login::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		.terminal-login::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		/* Car Radio - iPhone Style */
		.car-radio {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%) scale(0.9);
			width: 380px;
			height: 650px;
			background: #000;
			border-radius: 40px;
			padding: 0;
			box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 0 0 1px rgba(255, 255, 255, 0.1);
			font-family: 'Share Tech Mono', monospace;
			color: #fff;
			z-index: 9999;
			opacity: 0;
			pointer-events: none;
			transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}

		.car-radio.active {
			opacity: 1;
			pointer-events: auto;
			transform: translate(-50%, -50%) scale(1);
		}

		/* Crosshair */
		.crosshair {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			width: 4px;
			height: 4px;
			background: white;
			border-radius: 50%;
			pointer-events: none;
			z-index: 1000;
			opacity: 0.8;
			box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
		}

		/* Phone Home Screen */
		.phone-home {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
			display: flex;
			flex-direction: column;
			opacity: 1;
			transition: opacity 0.3s ease;
			z-index: 1;
		}

		.phone-home.hidden {
			opacity: 0;
			pointer-events: none;
		}

		.phone-status-bar {
			padding: 12px 20px 8px 20px;
			display: flex;
			justify-content: space-between;
			font-size: 12px;
			color: rgba(255, 255, 255, 0.8);
			background: rgba(0, 0, 0, 0.3);
		}

		.phone-time {
			font-weight: 600;
		}

		.phone-icons {
			display: flex;
			gap: 6px;
		}

		.phone-app-grid {
			flex: 1;
			padding: 60px 30px 40px 30px;
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 35px;
			align-content: start;
		}

		.phone-app {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 8px;
			cursor: pointer;
			transition: transform 0.2s ease;
		}

		.phone-app:active {
			transform: scale(0.95);
		}

		.phone-app-icon {
			width: 64px;
			height: 64px;
			border-radius: 16px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 32px;
			background: linear-gradient(135deg, #bee17b 0%, #8cc63f 100%);
			box-shadow: 0 4px 12px rgba(190, 225, 123, 0.3);
			position: relative;
			overflow: hidden;
		}

		.phone-app-icon::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			height: 50%;
			background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 100%);
		}

		.phone-app-label {
			font-size: 12px;
			color: rgba(255, 255, 255, 0.9);
			text-align: center;
			font-weight: 500;
		}

		.phone-home-indicator {
			position: absolute;
			bottom: 8px;
			left: 50%;
			transform: translateX(-50%);
			width: 140px;
			height: 4px;
			background: rgba(255, 255, 255, 0.3);
			border-radius: 2px;
		}

		/* Music App Screen */
		.phone-music-app {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: #000;
			display: flex;
			flex-direction: column;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
			z-index: 2;
		}

		.phone-music-app.active {
			opacity: 1;
			pointer-events: auto;
		}

		.car-radio-header {
			padding: 50px 20px 16px 20px;
			background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
			position: relative;
			z-index: 10;
		}

		.phone-back-btn {
			position: absolute;
			top: 50px;
			left: 12px;
			width: 36px;
			height: 36px;
			border: none;
			background: rgba(255, 255, 255, 0.1);
			color: #bee17b;
			font-size: 32px;
			border-radius: 50%;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: background 0.2s ease;
			z-index: 20;
		}

		.phone-back-btn:hover {
			background: rgba(255, 255, 255, 0.2);
		}

		.phone-back-btn:active {
			transform: scale(0.95);
		}

		.car-radio-title {
			font-size: 32px;
			font-weight: 700;
			letter-spacing: -0.6px;
			color: #fff;
		}

		.car-radio-subtitle {
			font-size: 15px;
			color: rgba(255, 255, 255, 0.5);
			margin-top: 4px;
			font-weight: 500;
		}

		.phone-search-bar {
			padding: 12px 20px;
			background: rgba(0, 0, 0, 0.5);
			border-bottom: 1px solid rgba(255, 255, 255, 0.1);
		}

		.phone-search-bar input {
			width: 100%;
			background: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 10px;
			padding: 10px 14px;
			color: #fff;
			font-family: 'Share Tech Mono', monospace;
			font-size: 14px;
			outline: none;
			transition: all 0.2s ease;
		}

		.phone-search-bar input::placeholder {
			color: rgba(255, 255, 255, 0.4);
		}

		.phone-search-bar input:focus {
			background: rgba(255, 255, 255, 0.15);
			border-color: #bee17b;
		}

		.car-radio-content {
			flex: 1;
			overflow-y: auto;
			padding: 12px 20px 140px 20px;
		}

		.car-radio-bottom-bar {
			position: absolute;
			bottom: 0;
			left: 0;
			right: 0;
			background: rgba(20, 20, 20, 0.95);
			backdrop-filter: blur(20px);
			border-top: 1px solid rgba(255, 255, 255, 0.1);
			padding: 12px 20px 32px 20px;
		}

		.car-radio-now-playing-mini {
			display: flex;
			align-items: center;
			gap: 12px;
			margin-bottom: 12px;
		}

		.car-radio-mini-art {
			width: 48px;
			height: 48px;
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			background-size: cover;
			background-position: center;
			border-radius: 8px;
			flex-shrink: 0;
		}

		.car-radio-mini-info {
			flex: 1;
			min-width: 0;
		}

		.car-radio-mini-title {
			font-size: 14px;
			font-weight: 600;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.car-radio-mini-artist {
			font-size: 12px;
			color: rgba(255, 255, 255, 0.5);
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.car-radio-controls {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 40px;
		}

		.car-radio-btn {
			background: none;
			border: none;
			color: #fff;
			font-size: 28px;
			cursor: pointer;
			transition: all 0.2s;
			width: 44px;
			height: 44px;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0.9;
		}

		.car-radio-btn:hover {
			opacity: 1;
			transform: scale(1.05);
		}

		.car-radio-btn.play-pause {
			width: 48px;
			height: 48px;
			background: rgba(255, 255, 255, 0.15);
			border-radius: 24px;
			font-size: 24px;
		}

		.car-radio-btn.play-pause:hover {
			background: rgba(255, 255, 255, 0.25);
		}

		.car-radio-content::-webkit-scrollbar {
			width: 0;
		}

		.car-radio-track-item {
			padding: 12px 0;
			cursor: pointer;
			transition: all 0.2s;
			display: flex;
			align-items: center;
			gap: 12px;
			border-bottom: 1px solid rgba(255, 255, 255, 0.05);
		}

		.car-radio-track-item:hover {
			opacity: 0.7;
		}

		.car-radio-track-item.playing {
			opacity: 1;
		}

		.car-radio-track-item.playing .car-radio-track-number {
			color: #667eea;
		}

		.car-radio-track-number {
			color: rgba(255, 255, 255, 0.4);
			font-size: 15px;
			min-width: 32px;
			font-weight: 500;
		}

		.car-radio-track-details {
			flex: 1;
			min-width: 0;
		}

		.car-radio-track-name {
			font-size: 16px;
			font-weight: 500;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			margin-bottom: 2px;
		}

		.car-radio-track-meta {
			font-size: 14px;
			color: rgba(255, 255, 255, 0.4);
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.car-radio-close {
			position: absolute;
			top: 20px;
			left: 20px;
			background: rgba(60, 60, 67, 0.6);
			backdrop-filter: blur(10px);
			border: none;
			color: #fff;
			width: 32px;
			height: 32px;
			border-radius: 16px;
			cursor: pointer;
			font-size: 20px;
			font-weight: 600;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: all 0.2s;
			z-index: 100;
		}

		.car-radio-close:hover {
			background: rgba(80, 80, 87, 0.8);
			transform: scale(1.05);
		}

		/* Welcome Slideshow */
		.welcome-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.95);
			z-index: 999999;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.4s ease;
		}

		.welcome-overlay.active {
			opacity: 1;
			pointer-events: auto;
		}

		.welcome-modal {
			background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
			border: 2px solid #bee17b;
			border-radius: 16px;
			width: 90%;
			max-width: 700px;
			max-height: 80vh;
			overflow: hidden;
			position: relative;
			box-shadow: 0 20px 60px rgba(190, 225, 123, 0.3);
			animation: slideIn 0.5s ease;
		}

		@keyframes slideIn {
			from {
				transform: translateY(-30px);
				opacity: 0;
			}
			to {
				transform: translateY(0);
				opacity: 1;
			}
		}

		.welcome-header {
			background: #000;
			border-bottom: 2px solid #bee17b;
			padding: 20px 24px;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.welcome-title {
			font-family: 'Share Tech Mono', monospace;
			font-size: 24px;
			font-weight: 700;
			color: #bee17b;
			letter-spacing: 2px;
			text-transform: uppercase;
		}

		.welcome-close {
			background: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.2);
			color: #fff;
			width: 32px;
			height: 32px;
			border-radius: 50%;
			cursor: pointer;
			font-size: 18px;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: all 0.2s ease;
		}

		.welcome-close:hover {
			background: rgba(255, 255, 255, 0.2);
			transform: rotate(90deg);
		}

		.welcome-content {
			padding: 40px;
			min-height: 350px;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			text-align: center;
		}

		.welcome-slide {
			display: none;
			animation: fadeIn 0.5s ease;
		}

		.welcome-slide.active {
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		@keyframes fadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}

		.welcome-icon {
			font-size: 64px;
			margin-bottom: 24px;
			filter: drop-shadow(0 4px 12px rgba(190, 225, 123, 0.4));
		}

		.welcome-slide h2 {
			font-family: 'Share Tech Mono', monospace;
			font-size: 28px;
			font-weight: 700;
			color: #bee17b;
			margin: 0 0 16px 0;
			letter-spacing: 1px;
		}

		.welcome-slide p {
			font-family: 'Share Tech Mono', monospace;
			font-size: 16px;
			line-height: 1.6;
			color: rgba(255, 255, 255, 0.8);
			margin: 0;
			max-width: 500px;
		}

		.welcome-footer {
			background: #000;
			border-top: 2px solid #bee17b;
			padding: 20px 24px;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.welcome-dots {
			display: flex;
			gap: 8px;
		}

		.welcome-dot {
			width: 10px;
			height: 10px;
			border-radius: 50%;
			background: rgba(255, 255, 255, 0.3);
			cursor: pointer;
			transition: all 0.3s ease;
		}

		.welcome-dot.active {
			background: #bee17b;
			transform: scale(1.2);
		}

		.welcome-dot:hover {
			background: rgba(190, 225, 123, 0.6);
		}

		.welcome-nav {
			display: flex;
			gap: 12px;
		}

		.welcome-btn {
			background: rgba(190, 225, 123, 0.15);
			border: 1px solid #bee17b;
			color: #bee17b;
			padding: 10px 20px;
			border-radius: 6px;
			font-family: 'Share Tech Mono', monospace;
			font-size: 14px;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.2s ease;
			text-transform: uppercase;
			letter-spacing: 1px;
		}

		.welcome-btn:hover {
			background: rgba(190, 225, 123, 0.25);
			transform: translateY(-2px);
		}

		.welcome-btn:disabled {
			opacity: 0.4;
			cursor: not-allowed;
			transform: none;
		}

		.welcome-btn.primary {
			background: #bee17b;
			color: #000;
		}

		.welcome-btn.primary:hover {
			background: #d4f098;
			box-shadow: 0 4px 12px rgba(190, 225, 123, 0.4);
		}

		/* OS View Scrollbar */
		.os-view::-webkit-scrollbar {
			width: 16px;
		}

		.os-view::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		.os-view::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		.os-view::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		.terminal-login.active {
			opacity: 1;
			pointer-events: auto;
			transform: translate(-50%, -50%) scale(1);
		}

		.os-container {
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		/* OS Taskbar */
		.os-taskbar {
			background: #000;
			border-bottom: 2px solid #bee17b;
			padding: 8px 16px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 20px;
		}

		.os-logo {
			font-weight: bold;
			font-size: 14px;
			color: #bee17b;
			text-transform: uppercase;
			letter-spacing: 1px;
		}

		.os-taskbar-apps {
			display: flex;
			gap: 0;
			flex: 1;
		}

		.taskbar-app {
			padding: 6px 12px;
			background: #000;
			border: 1px solid #bee17b;
			border-right: none;
			cursor: pointer;
			transition: all 0.1s ease;
			font-size: 12px;
			font-weight: bold;
		}

		.taskbar-app:last-child {
			border-right: 1px solid #bee17b;
		}

		.taskbar-app:hover {
			background: rgba(190, 225, 123, 0.2);
		}

		.taskbar-app.active {
			background: rgba(190, 225, 123, 0.3);
			color: #000;
			background: #bee17b;
		}

		.os-close {
			background: #000;
			color: #bee17b;
			padding: 6px 12px;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			transition: all 0.1s ease;
			font-weight: bold;
			border: 1px solid #bee17b;
		}

		.os-close:hover {
			background: #bee17b;
			color: #000;
		}

		/* OS Views */
		.os-view {
			flex: 1;
			overflow: hidden;
		}

		/* Desktop View */
		.desktop-split {
			position: relative;
			height: 100%;
			padding: 20px;
		}

		.desktop-icons {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
			gap: 20px;
			align-content: start;
			padding-bottom: 180px;
		}

		.desktop-icon {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 8px;
			cursor: pointer;
			padding: 15px;
			border: 2px solid transparent;
			transition: all 0.1s ease;
		}

		.desktop-icon:hover {
			border: 2px solid #bee17b;
			background: rgba(190, 225, 123, 0.1);
		}

		.desktop-icon .icon {
			font-size: 32px;
			font-weight: bold;
			color: #bee17b;
		}

		.desktop-icon .label {
			font-size: 11px;
			text-align: center;
			color: #bee17b;
			font-weight: bold;
		}

		/* Desktop Audio Player */
		.desktop-audio-player {
			position: absolute;
			bottom: 60px;
			left: 20px;
			right: 20px;
			border: 2px solid #bee17b;
			background: #000;
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}

		.audio-player-header {
			font-weight: bold;
			font-size: 12px;
			color: #000;
			background: #bee17b;
			text-transform: uppercase;
			padding: 10px 16px;
			letter-spacing: 1px;
		}

		.audio-player-body {
			display: flex;
			gap: 16px;
			padding: 16px;
			align-items: center;
		}

		.audio-album-art-container {
			flex-shrink: 0;
		}

		#desktop-album-art {
			width: 80px;
			height: 80px;
			background: #000;
			border: 2px solid #bee17b;
			display: flex;
			align-items: center;
			justify-content: center;
			color: #bee17b;
			font-size: 10px;
			background-size: cover;
			background-position: center;
			text-align: center;
		}

		.audio-info-controls {
			flex: 1;
			display: flex;
			align-items: center;
			gap: 16px;
			min-width: 0;
		}

		.audio-status {
			font-size: 12px;
			color: #bee17b;
			padding: 12px 16px;
			border: 1px solid #bee17b;
			background: #000;
			flex: 1;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.audio-controls {
			display: flex;
			gap: 8px;
			flex-shrink: 0;
		}

		.audio-btn {
			background: #000;
			color: #bee17b;
			border: 1px solid #bee17b;
			padding: 10px 20px;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.1s ease;
			min-width: 100px;
		}

		/* Profile Button */
		.desktop-profile-btn {
			background: #000;
			color: #bee17b;
			border: 1px solid #bee17b;
			border-right: none;
			padding: 6px 12px;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.1s ease;
		}

		.desktop-profile-btn:hover {
			background: rgba(190, 225, 123, 0.2);
		}

		/* Login Modal */
		.login-modal-overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.8);
			z-index: 10000;
			align-items: center;
			justify-content: center;
		}

		.login-modal-overlay.show {
			display: flex;
		}

		.login-modal-box {
			background: #000;
			border: 2px solid #bee17b;
			width: 400px;
			max-width: 90%;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
		}

		.login-modal-header {
			background: #bee17b;
			color: #000;
			padding: 12px 16px;
			font-weight: bold;
			font-size: 13px;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.login-modal-close {
			background: none;
			border: none;
			color: #000;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
			font-size: 14px;
			cursor: pointer;
			padding: 0;
		}

		.login-modal-body {
			padding: 24px;
		}

		.login-form-group {
			margin-bottom: 16px;
		}

		.login-form-group label {
			display: block;
			color: #bee17b;
			font-size: 11px;
			font-weight: bold;
			margin-bottom: 6px;
			letter-spacing: 1px;
		}

		.login-form-group input {
			width: 100%;
			background: #000;
			border: 1px solid #bee17b;
			color: #bee17b;
			padding: 10px;
			font-family: 'Share', 'Courier New', monospace;
			font-size: 12px;
			box-sizing: border-box;
		}

		.login-form-group input:focus {
			outline: none;
			border-color: #bee17b;
			box-shadow: 0 0 0 2px rgba(190, 225, 123, 0.2);
		}

		.login-submit-btn {
			width: 100%;
			background: #bee17b;
			color: #000;
			border: none;
			padding: 12px;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.1s ease;
			letter-spacing: 1px;
		}

		.login-submit-btn:hover {
			background: #a8cc6b;
		}

		.login-error {
			color: #ff6b6b;
			font-size: 11px;
			margin-top: 12px;
			display: none;
		}

		.login-error.show {
			display: block;
		}

		.audio-btn:hover:not(:disabled) {
			background: #bee17b;
			color: #000;
		}

		.audio-btn:disabled {
			opacity: 0.3;
			cursor: not-allowed;
		}

		/* Delete Message Button */
		.delete-msg-btn:hover {
			background: #f00 !important;
			color: #000 !important;
		}

		/* App Window */
		.app-window {
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		.app-header {
			background: #000;
			border-bottom: 2px solid #bee17b;
			padding: 10px 20px;
			display: flex;
			align-items: center;
			gap: 15px;
		}

		.app-title {
			font-weight: bold;
			font-size: 13px;
			color: #bee17b;
			text-transform: uppercase;
			letter-spacing: 1px;
		}

		.app-content {
			flex: 1;
			overflow-y: auto;
			padding: 20px;
			background: #000;
		}

		.file-path {
			font-size: 11px;
			color: #bee17b;
			background: #000;
			padding: 4px 10px;
			border: 1px solid #bee17b;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
		}

		/* Folder Items */
		.folder-item {
			padding: 10px 15px;
			margin: 4px 0;
			border: 1px solid #bee17b;
			cursor: pointer;
			transition: all 0.1s ease;
			background: #000;
			display: flex;
			align-items: center;
			gap: 10px;
			font-size: 13px;
			font-weight: bold;
		}

		.folder-item:hover {
			background: #bee17b;
			color: #000;
		}

		.folder-icon {
			font-size: 13px;
			font-weight: bold;
		}

		.terminal-header {
			text-align: center;
			margin-bottom: 30px;
			font-size: 24px;
			font-weight: 800;
			color: #bee17b;
			text-transform: uppercase;
			letter-spacing: 2px;
			padding-bottom: 20px;
			border-bottom: 3px solid #bee17b;
		}

		.terminal-input-group {
			margin-bottom: 20px;
		}

		.terminal-input-group label {
			display: block;
			margin-bottom: 8px;
			font-size: 12px;
			font-weight: 700;
			text-transform: uppercase;
			letter-spacing: 1px;
			color: #bee17b;
		}

		.terminal-input-group input {
			width: 100%;
			background: rgba(255, 255, 255, 0.1);
			border: 2px solid rgba(190, 225, 123, 0.3);
			color: #fff;
			padding: 14px 16px;
			font-family: 'Share', 'Courier New', monospace;
			font-size: 15px;
			box-sizing: border-box;
			border-radius: 12px;
			transition: all 0.3s ease;
		}

		.terminal-input-group input:focus {
			outline: none;
			border-color: #bee17b;
			background: rgba(255, 255, 255, 0.15);
			box-shadow: 0 0 20px rgba(190, 225, 123, 0.3);
			transform: translateY(-2px);
		}

		.terminal-input-group input::placeholder {
			color: rgba(255, 255, 255, 0.4);
		}

		.terminal-buttons {
			display: flex;
			gap: 12px;
			margin-top: 30px;
		}

		.terminal-button {
			flex: 1;
			background: rgba(255, 255, 255, 0.1);
			border: 2px solid #bee17b;
			color: #bee17b;
			padding: 14px 24px;
			font-family: 'Share', 'Courier New', monospace;
			cursor: pointer;
			transition: all 0.3s ease;
			text-transform: uppercase;
			font-weight: 700;
			font-size: 13px;
			letter-spacing: 1px;
			border-radius: 12px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
		}

		.terminal-button:hover {
			background: #bee17b;
			color: #000;
			transform: translateY(-2px);
			box-shadow: 0 6px 20px rgba(190, 225, 123, 0.4);
		}

		.terminal-button:active {
			transform: translateY(0px);
		}

		.terminal-error {
			color: #ff6b6b;
			font-size: 13px;
			margin-top: 15px;
			text-align: center;
			display: none;
			font-weight: 600;
			background: rgba(255, 107, 107, 0.1);
			padding: 10px;
			border-radius: 8px;
		}

		.terminal-error.show {
			display: block;
			animation: shake 0.4s ease;
		}

		@keyframes shake {
			0%, 100% { transform: translateX(0); }
			25% { transform: translateX(-10px); }
			75% { transform: translateX(10px); }
		}

		/* Track List Styles */
		#tracks-container {
			max-height: 450px;
			overflow-y: auto;
			margin: 0;
			padding: 0;
		}

		#tracks-container::-webkit-scrollbar {
			width: 16px;
		}

		#tracks-container::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		#tracks-container::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		#tracks-container::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		/* File Explorer Scrollbar */
		#file-explorer::-webkit-scrollbar {
			width: 16px;
		}

		#file-explorer::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		#file-explorer::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		#file-explorer::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		/* App Content Scrollbar */
		.app-content::-webkit-scrollbar {
			width: 16px;
		}

		.app-content::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		.app-content::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		.app-content::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		.track-item {
			padding: 15px;
			margin: 8px 0;
			border: 2px solid rgba(190, 225, 123, 0.3);
			border-radius: 12px;
			cursor: pointer;
			transition: all 0.2s ease;
			background: rgba(255, 255, 255, 0.02);
		}

		.track-item:hover {
			background: rgba(190, 225, 123, 0.15);
			border-color: #bee17b;
			transform: translateX(5px);
		}

		.artist-link {
			color: #bee17b;
			text-decoration: none;
		}

		.artist-link:hover {
			text-decoration: underline;
		}

		.track-title {
			font-weight: bold;
			color: #bee17b;
			font-size: 16px;
			margin-bottom: 5px;
		}

		.track-meta {
			font-size: 12px;
			color: #888;
			text-transform: uppercase;
		}

		#search-input {
			width: 100%;
			background: rgba(255, 255, 255, 0.1);
			border: 2px solid rgba(190, 225, 123, 0.3);
			color: #fff;
			padding: 14px 16px;
			font-family: 'Share', 'Courier New', monospace;
			font-size: 15px;
			box-sizing: border-box;
			border-radius: 12px;
			margin-bottom: 15px;
			transition: all 0.3s ease;
		}

		#search-input:focus {
			outline: none;
			border-color: #bee17b;
			background: rgba(255, 255, 255, 0.15);
			box-shadow: 0 0 20px rgba(190, 225, 123, 0.3);
		}

		#search-input::placeholder {
			color: rgba(190, 225, 123, 0.5);
		}

		/* Audio Loading Indicator */
		#audio-loading {
			position: fixed;
			bottom: 30px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.9);
			border: 2px solid #bee17b;
			color: #bee17b;
			padding: 15px 30px;
			border-radius: 12px;
			font-family: 'Share', 'Courier New', monospace;
			font-size: 14px;
			z-index: 9999;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
			backdrop-filter: blur(10px);
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
		}

		#audio-loading.show {
			opacity: 1;
		}

		/* Interaction Prompt */
		.interaction-prompt {
			position: fixed;
			bottom: 120px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.8);
			color: #fff;
			padding: 12px 24px;
			border-radius: 8px;
			font-family: 'Lucida Grande', 'Lucida Sans Unicode', Arial, sans-serif;
			font-size: 14px;
			z-index: 9999;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
			border: 2px solid rgba(255, 255, 255, 0.3);
		}

		.interaction-prompt.show {
			opacity: 1;
		}

		.interaction-prompt kbd {
			background: #333;
			border: 1px solid #555;
			border-radius: 4px;
			padding: 4px 8px;
			margin: 0 4px;
			font-weight: bold;
		}

		/* CRT Scanline Overlay */
		#crt-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			z-index: 9998;
			opacity: 0.15;
			background:
				repeating-linear-gradient(
					0deg,
					rgba(0, 0, 0, 0.4),
					rgba(0, 0, 0, 0.4) 3px,
					transparent 3px,
					transparent 6px
				);
		}

		/* Grain Overlay - hidden, now in shader */
		#grain-overlay {
			display: none;
		}

		/* CRT Camera UI */
		#crt-ui {
			position: fixed;
			top: 8%;
			left: 5%;
			font-family: 'Share', 'Courier New', monospace;
			color: #ffffff;
			font-size: 18px;
			font-weight: bold;
			z-index: 9999;
			pointer-events: none;
			text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
			opacity: 0;
			transition: opacity 0.5s ease;
		}

		#crt-ui.visible {
			opacity: 1;
		}

		#rec-indicator {
			display: flex;
			align-items: center;
			gap: 8px;
			margin-bottom: 5px;
		}

		#rec-dot {
			width: 12px;
			height: 12px;
			background: #ff0000;
			border-radius: 50%;
			animation: blink 1s infinite;
		}

		@keyframes blink {
			0%, 49% { opacity: 1; }
			50%, 100% { opacity: 0; }
		}

		#timestamp {
			font-size: 16px;
			letter-spacing: 1px;
		}

		/* CRT Engine Credit */
		#crt-engine-credit {
			position: fixed;
			bottom: 20px;
			left: 20px;
			font-family: 'Share', 'Courier New', monospace;
			color: #bee17b;
			font-size: 16px;
			z-index: 99999;
			pointer-events: auto;
			background: rgba(0, 0, 0, 0.7);
			padding: 8px 12px;
			border: 2px solid #bee17b;
		}

		#crt-engine-credit a {
			color: #bee17b;
			text-decoration: none;
		}

		#crt-engine-credit a:hover {
			text-decoration: underline;
		}

		/* EQ Slider Styles - DOS aesthetic */
		#eq-view input[type="range"] {
			-webkit-appearance: none;
			appearance: none;
			width: 100%;
			height: 6px;
			background: #000;
			border: 2px solid #bee17b;
			outline: none;
			cursor: pointer;
		}

		#eq-view input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 20px;
			height: 20px;
			background: #bee17b;
			border: 2px solid #000;
			cursor: pointer;
			box-shadow: 0 0 5px rgba(190, 225, 123, 0.5);
		}

		#eq-view input[type="range"]::-moz-range-thumb {
			width: 20px;
			height: 20px;
			background: #bee17b;
			border: 2px solid #000;
			cursor: pointer;
			box-shadow: 0 0 5px rgba(190, 225, 123, 0.5);
		}

		#eq-view input[type="range"]:hover::-webkit-slider-thumb {
			background: #d4f098;
		}

		#eq-view input[type="range"]:hover::-moz-range-thumb {
			background: #d4f098;
		}
	</style>
</head>

<body>
	<!-- Welcome Slideshow -->
	<div id="welcome-overlay" class="welcome-overlay active">
		<div class="welcome-modal">
			<div class="welcome-header">
				<div class="welcome-title">Welcome to SUBLAIR 3D</div>
				<button class="welcome-close" onclick="closeWelcome()">✕</button>
			</div>
			<div class="welcome-content">
				<!-- Slide 1 -->
				<div class="welcome-slide active" data-slide="0">
					<img src="public/BRAND.png" alt="SUBLAIR" style="max-width: 200px; margin-bottom: 24px;">
					<h2>>_SUBLAIR-3D</h2>
					<p>Welcome to SUBLAIR 3D - an immersive music experience where you explore, discover, and interact with music in a fully realized 3D world.</p>
				</div>
				<!-- Slide 2 -->
				<div class="welcome-slide" data-slide="1">
					<h2>Explore the World</h2>
					<p>Use <strong>WASD</strong> to move, <strong>SHIFT</strong> to sprint, and <strong>SPACE</strong> to jump. Hold <strong>E</strong> for aim mode with over-the-shoulder view. Press <strong>F</strong> to enter vehicles and interact with objects. Click to lock your cursor and look around.</p>
				</div>
				<!-- Slide 3 -->
				<div class="welcome-slide" data-slide="2">
					<h2>Interactive Computer</h2>
					<p>Walk up to the computer terminal and press <strong>F</strong> to access the SUBLAIR OS. Browse music, adjust the EQ, and control playback with a retro DOS-inspired interface.</p>
				</div>
				<!-- Slide 4 -->
				<div class="welcome-slide" data-slide="3">
					<h2>Car Radio</h2>
					<p>Get into any vehicle and press <strong>R</strong> to open your phone. Access the full music library on-the-go with a sleek mobile interface.</p>
				</div>
				<!-- Slide 5 -->
				<div class="welcome-slide" data-slide="4">
					<h2>Customize Your Character</h2>
					<p>Press <strong>C</strong> anytime to customize your character's appearance. Change colors, patterns, and textures to make your avatar truly unique.</p>
				</div>
				<!-- Slide 6 -->
				<div class="welcome-slide" data-slide="5">
					<h2>Welcome to the Underground</h2>
					<p>This is just the beginning. SUBLAIR 3D is in active development - a disruptive vision of what music discovery can be.</p>
					<p style="margin-top: 16px; font-style: italic; opacity: 0.7;">Think big. Think disruptive. The network beneath.</p>
					<p style="margin-top: 24px; font-size: 14px; opacity: 0.5; text-align: center;">-MF</p>
				</div>
			</div>
			<div class="welcome-footer">
				<div class="welcome-dots">
					<div class="welcome-dot active" onclick="goToSlide(0)"></div>
					<div class="welcome-dot" onclick="goToSlide(1)"></div>
					<div class="welcome-dot" onclick="goToSlide(2)"></div>
					<div class="welcome-dot" onclick="goToSlide(3)"></div>
					<div class="welcome-dot" onclick="goToSlide(4)"></div>
					<div class="welcome-dot" onclick="goToSlide(5)"></div>
				</div>
				<div class="welcome-nav">
					<button class="welcome-btn" id="welcome-prev" onclick="prevSlide()" disabled>Previous</button>
					<button class="welcome-btn" id="welcome-next" onclick="nextSlide()">Next</button>
					<button class="welcome-btn primary" id="welcome-start" onclick="closeWelcome()" style="display: none;">Let's Go!</button>
				</div>
			</div>
		</div>
	</div>

	<!-- CRT Scanline Overlay -->
	<div id="crt-overlay"></div>

	<!-- Grain Overlay -->
	<div id="grain-overlay"></div>

	<!-- Crosshair (hidden by default) -->
	<div class="crosshair" id="crosshair" style="display: none;"></div>

	<!-- Car Radio Interface (Phone) -->
	<div id="car-radio" class="car-radio">
		<button class="car-radio-close" onclick="window.toggleCarRadio()">˅</button>

		<!-- Phone Home Screen -->
		<div id="phone-home" class="phone-home">
			<div class="phone-status-bar">
				<div class="phone-time" id="phone-time">9:41</div>
				<div class="phone-icons">
					<span>📶</span>
					<span>📡</span>
					<span>🔋</span>
				</div>
			</div>

			<div class="phone-app-grid">
				<div class="phone-app" onclick="openPhoneApp('music')">
					<div class="phone-app-icon">
						<img src="public/CIRCLE.png" alt="SUBLAIR" style="width: 100%; height: 100%; object-fit: cover; border-radius: 18px;">
					</div>
					<div class="phone-app-label">SUBLAIR</div>
				</div>
			</div>

			<div class="phone-home-indicator"></div>
		</div>

		<!-- Music App Screen -->
		<div id="phone-music-app" class="phone-music-app">
			<div class="car-radio-header">
				<button class="phone-back-btn" onclick="closePhoneApp()">‹</button>
				<div class="car-radio-title">SUBLAIR</div>
			</div>
			<div class="phone-search-bar">
				<input type="text" id="phone-search-input" placeholder="Search tracks, artists..." />
			</div>
			<div class="car-radio-content" id="radio-tracklist">
				<!-- Tracks will be loaded here -->
			</div>
			<div class="car-radio-bottom-bar">
				<div class="car-radio-now-playing-mini">
					<div class="car-radio-mini-art"></div>
					<div class="car-radio-mini-info">
						<div class="car-radio-mini-title" id="radio-current-title">Not Playing</div>
						<div class="car-radio-mini-artist" id="radio-current-artist">Select a track</div>
					</div>
				</div>
				<div class="car-radio-controls">
					<button class="car-radio-btn" onclick="radioSkipPrev()">⏮</button>
					<button class="car-radio-btn play-pause" id="radio-play-btn" onclick="radioTogglePlay()">▶</button>
					<button class="car-radio-btn" onclick="radioSkipNext()">⏭</button>
				</div>
			</div>
		</div>
	</div>

	<!-- CRT Camera UI -->
	<div id="crt-ui">
		<div id="rec-indicator">
			<div id="rec-dot"></div>
			<span>REC</span>
		</div>
		<div id="timestamp"></div>
	</div>

	<!-- Engine Credit (always visible on main game) -->
	<div id="crt-engine-credit" class="visible">
		Engine: <a href="https://github.com/swift502/Sketchbook" target="_blank">Sketchbook 0.4</a>
	</div>

	<script src="./build/sketchbook.min.js"></script>
	<script>
		// Update CRT timestamp
		function updateTimestamp() {
			const now = new Date();
			const year = now.getFullYear();
			const month = String(now.getMonth() + 1).padStart(2, '0');
			const day = String(now.getDate()).padStart(2, '0');
			const hours = String(now.getHours()).padStart(2, '0');
			const minutes = String(now.getMinutes()).padStart(2, '0');
			const seconds = String(now.getSeconds()).padStart(2, '0');

			document.getElementById('timestamp').textContent =
				`${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
		}

		// Update timestamp every second
		updateTimestamp();
		setInterval(updateTimestamp, 1000);

		// Preload CRT shader before world creation
		let crtShaderReady = false;
		let ShaderPass = null;

		import('https://cdn.skypack.dev/three@0.113.0/examples/jsm/postprocessing/ShaderPass.js')
			.then(module => {
				ShaderPass = module.ShaderPass;
				crtShaderReady = true;
				console.log('✓ CRT ShaderPass preloaded');
			})
			.catch(err => {
				console.error('Failed to preload ShaderPass:', err);
			});

		// Create a simple flat world with a car
		window.world = new Sketchbook.World();
		const world = window.world; // Keep local reference for compatibility

		// Add CRT barrel distortion effect using ShaderPass
		// Apply as soon as world.composer is ready
		const applyCRTEffect = () => {
			if (world.composer && crtShaderReady && ShaderPass) {

					// CRT Shader
					const CRTShader = {
						uniforms: {
							tDiffuse: { value: null },
							distortion: { value: 0.12 },
							distortionX: { value: 0.12 },
							distortionY: { value: 0.15 }
						},
						vertexShader: `
							varying vec2 vUv;
							void main() {
								vUv = uv;
								gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
							}
						`,
						fragmentShader: `
							uniform sampler2D tDiffuse;
							uniform float distortion;
							uniform float distortionX;
							uniform float distortionY;
							varying vec2 vUv;

							vec2 barrelDistortion(vec2 coord, float distX, float distY) {
								vec2 cc = coord - 0.5;
								float dist = dot(cc, cc);
								vec2 result = coord + cc * (distX + distY) * dist;
								return result;
							}

							void main() {
								vec2 uv = barrelDistortion(vUv, distortionX, distortionY);

								// Out of bounds check - show black
								if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
									gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
									return;
								}

								// Sample with barrel distortion
								vec4 color = texture2D(tDiffuse, uv);

								// Add subtle vignette
								vec2 center = vUv - 0.5;
								float vignette = 1.0 - dot(center, center) * 0.35;
								color.rgb *= vignette;

								// Add slight noise
								float noise = fract(sin(dot(vUv * 1000.0, vec2(12.9898, 78.233))) * 43758.5453);
								color.rgb += noise * 0.03;

								gl_FragColor = color;
							}
						`
					};

				const crtPass = new ShaderPass(CRTShader);
				crtPass.renderToScreen = true; // CRT is now the final pass

				// Disable renderToScreen for all previous passes
				const passes = world.composer.passes;
				for (let i = 0; i < passes.length; i++) {
					passes[i].renderToScreen = false;
				}

				world.composer.addPass(crtPass);

				console.log('✓ CRT barrel distortion shader added as final pass!');
			}
		};

		// Try to apply CRT effect immediately and keep retrying
		applyCRTEffect();

		// Load asset colors from localStorage IMMEDIATELY (before assets load)
		(function() {
			let savedCustomization = localStorage.getItem('characterCustomization');
			if (savedCustomization) {
				let customizationData = JSON.parse(savedCustomization);
				window.speakerCabColor = customizationData.speakerCabColor || '#282828';
				window.speakerTrimColor = customizationData.speakerTrimColor || '#282828';
				window.speakerFaceColor = customizationData.speakerFaceColor || '#282828';
				window.speakerFrameColor = customizationData.speakerFrameColor || '#282828';
				window.computerChassisColor = customizationData.computerChassisColor || '#282828';
				window.computerKeyboardColor = customizationData.computerKeyboardColor || '#191919';
				window.computerFeaturesColor = customizationData.computerFeaturesColor || '#bee17b';
				window.carDoorColor = customizationData.carDoorColor || '#282828';
				window.carFrameColor = customizationData.carFrameColor || '#282828';
				window.carHeadlightsColor = customizationData.carHeadlightsColor || '#282828';
				window.carHoodColor = customizationData.carHoodColor || '#282828';
				window.carInteriorColor = customizationData.carInteriorColor || '#282828';
				window.carRimColor = customizationData.carRimColor || '#282828';
				window.carSteeringColor = customizationData.carSteeringColor || '#282828';
				window.carTaillightsColor = customizationData.carTaillightsColor || '#282828';
				window.carTireColor = customizationData.carTireColor || '#282828';
				window.carTrimColor = customizationData.carTrimColor || '#282828';
				console.log('✅ Loaded colors from localStorage');
			} else {
				// Set defaults if no saved data
				window.speakerCabColor = '#282828';
				window.speakerTrimColor = '#282828';
				window.speakerFaceColor = '#282828';
				window.speakerFrameColor = '#282828';
				window.computerChassisColor = '#282828';
				window.computerKeyboardColor = '#191919';
				window.computerFeaturesColor = '#bee17b';
				window.carDoorColor = '#282828';
				window.carFrameColor = '#282828';
				window.carHeadlightsColor = '#282828';
				window.carHoodColor = '#282828';
				window.carInteriorColor = '#282828';
				window.carRimColor = '#282828';
				window.carSteeringColor = '#282828';
				window.carTaillightsColor = '#282828';
				window.carTireColor = '#282828';
				window.carTrimColor = '#282828';
			}
		})();

		// Keep trying to apply CRT effect until it succeeds
		const crtRetryInterval = setInterval(() => {
			if (world.composer && crtShaderReady && ShaderPass) {
				applyCRTEffect();
				clearInterval(crtRetryInterval);
			}
		}, 50);

		// Give up after 5 seconds
		setTimeout(() => {
			clearInterval(crtRetryInterval);
		}, 5000);

		// We need to wait a moment for the world to initialize
		setTimeout(() => {
			// Create a gray grid texture
			const canvas = document.createElement('canvas');
			canvas.width = 512;
			canvas.height = 512;
			const ctx = canvas.getContext('2d');

			// Function to generate grid texture with custom colors
			window.generateGridTexture = function(lineColor = '#bee17b', bgColor = '#2a2a2a') {
				ctx.fillStyle = bgColor;
				ctx.fillRect(0, 0, 512, 512);

				// Draw grid lines
				ctx.strokeStyle = lineColor;
				ctx.lineWidth = 2;

				const gridSize = 64;
				// Vertical lines
				for (let i = 0; i <= 512; i += gridSize) {
					ctx.beginPath();
					ctx.moveTo(i, 0);
					ctx.lineTo(i, 512);
					ctx.stroke();
				}
				// Horizontal lines
				for (let i = 0; i <= 512; i += gridSize) {
					ctx.beginPath();
					ctx.moveTo(0, i);
					ctx.lineTo(512, i);
					ctx.stroke();
				}

				// Update texture
				if (window.gridTexture) {
					window.gridTexture.needsUpdate = true;
				}
			};

			// Initial generation
			window.generateGridTexture('#bee17b', '#2a2a2a');

			// Create texture from canvas
			const gridTexture = new THREE.CanvasTexture(canvas);
			gridTexture.wrapS = THREE.RepeatWrapping;
			gridTexture.wrapT = THREE.RepeatWrapping;
			gridTexture.repeat.set(50, 50);
			window.gridTexture = gridTexture;

			// Add a large ground plane (visual)
			const groundGeometry = new THREE.PlaneGeometry(200, 200, 1, 1);
			const groundMaterial = new THREE.MeshStandardMaterial({
				map: gridTexture,
				emissive: new THREE.Color(0xbee17b), // Green glow matching terminal color
				emissiveMap: gridTexture,
				emissiveIntensity: 0.3, // Subtle glow
				roughness: 0.8,
				metalness: 0.2
			});
			const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
			groundMesh.rotation.x = -Math.PI / 2;
			groundMesh.receiveShadow = true;
			world.graphicsWorld.add(groundMesh);
			window.groundMesh = groundMesh; // Make accessible for customization

			// Setup ground material for shadows
			world.sky.csm.setupMaterial(groundMaterial);

			// Add physics ground (collision) - this is the important part for the car to drive on
			const groundShape = new CANNON.Box(new CANNON.Vec3(100, 0.5, 100));
			const groundBody = new CANNON.Body({
				mass: 0,
				shape: groundShape,
				position: new CANNON.Vec3(0, -0.5, 0)
			});
			world.physicsWorld.addBody(groundBody);


			// Load the car and character
			const loadingManager = new Sketchbook.LoadingManager(world);

			loadingManager.onFinishedCallback = () => {
				world.update(1, 1);
				world.setTimeScale(1);

				Sketchbook.UIManager.setUserInterfaceVisible(false);
				Sketchbook.UIManager.setLoadingScreenVisible(false);

				// Show CRT UI once game is loaded
				document.getElementById('crt-ui').classList.add('visible');
				document.getElementById('crt-engine-credit').classList.add('visible');

				// Ensure welcome screen stays visible above everything
				const welcomeOverlay = document.getElementById('welcome-overlay');
				if (welcomeOverlay && welcomeOverlay.classList.contains('active')) {
					// Keep it visible and above everything
					welcomeOverlay.style.zIndex = '999999';
					welcomeOverlay.style.opacity = '1';
					welcomeOverlay.style.pointerEvents = 'auto';
				}
			};

			window.car = null; // Store car reference globally
			let car = window.car;
			loadingManager.loadGLTF('build/assets/car.glb', (carModel) => {
				console.log('🚗 Car GLB loaded, structure:', carModel.scene);

				// Debug: Log all objects in the scene
				carModel.scene.traverse((child) => {
					if (child.isMesh) {
						console.log('  Mesh:', child.name, 'Material:', child.material?.name);
					}
					if (child.userData?.data) {
						console.log('  UserData:', child.name, 'Data:', child.userData.data);
					}
				});

				console.log('🚗 Car GLB loaded, inspecting structure...');

				// Apply saved car colors BEFORE creating Car object (so materials don't get lost)
				console.log('🎨 Applying car colors to carModel.scene...');
				console.log('   window.carTireColor:', window.carTireColor);
				console.log('   window.carRimColor:', window.carRimColor);

				carModel.scene.traverse((child) => {
					if (child.isMesh && child.material) {
						const matName = child.material.name;

						if (matName === 'DOOR' || matName.toLowerCase().includes('door')) {
							if (window.carDoorColor) {
								child.material.color.set(window.carDoorColor);
								console.log('   ✅ Applied DOOR color to', child.name, ':', window.carDoorColor);
							}
						} else if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
							if (window.carFrameColor) {
								child.material.color.set(window.carFrameColor);
								console.log('   ✅ Applied FRAME color to', child.name, ':', window.carFrameColor);
							}
						} else if (matName === 'HEADLIGHTS' || matName.toLowerCase().includes('headlight')) {
							if (window.carHeadlightsColor) {
								child.material.color.set(window.carHeadlightsColor);
								console.log('   ✅ Applied HEADLIGHTS color to', child.name, ':', window.carHeadlightsColor);
							}
						} else if (matName === 'HOOD' || matName.toLowerCase().includes('hood')) {
							if (window.carHoodColor) {
								child.material.color.set(window.carHoodColor);
								console.log('   ✅ Applied HOOD color to', child.name, ':', window.carHoodColor);
							}
						} else if (matName === 'INTERIOR' || matName.toLowerCase().includes('interior')) {
							if (window.carInteriorColor) {
								child.material.color.set(window.carInteriorColor);
								console.log('   ✅ Applied INTERIOR color to', child.name, ':', window.carInteriorColor);
							}
						} else if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
							if (window.carRimColor) {
								child.material.color.set(window.carRimColor);
								console.log('   ✅ Applied RIMS color to', child.name, ':', window.carRimColor);
							}
						} else if (matName === 'STEERING' || matName.toLowerCase().includes('steering')) {
							if (window.carSteeringColor) {
								child.material.color.set(window.carSteeringColor);
								console.log('   ✅ Applied STEERING color to', child.name, ':', window.carSteeringColor);
							}
						} else if (matName === 'TAILLIGHTS' || matName.toLowerCase().includes('taillight')) {
							if (window.carTaillightsColor) {
								child.material.color.set(window.carTaillightsColor);
								console.log('   ✅ Applied TAILLIGHTS color to', child.name, ':', window.carTaillightsColor);
							}
						} else if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
							if (window.carTireColor) {
								child.material.color.set(window.carTireColor);
								console.log('   ✅ Applied TIRES color to', child.name, ':', window.carTireColor);
							}
						} else if (matName === 'TRIM' || matName.toLowerCase().includes('trim')) {
							if (window.carTrimColor) {
								child.material.color.set(window.carTrimColor);
								console.log('   ✅ Applied TRIM color to', child.name, ':', window.carTrimColor);
							}
						}
					}
				});

				window.car = car = new Sketchbook.Car(carModel);
				car.setPosition(0, 2, 0);

				// Create spawn point for the car (required by physics system)
				car.spawnPoint = new THREE.Object3D();
				car.spawnPoint.position.set(0, 2, 0);
				world.graphicsWorld.add(car.spawnPoint);

				world.add(car);

				// Create spatial audio for the car
				const listener = new THREE.AudioListener();
				world.camera.add(listener);

				window.carPositionalAudio = new THREE.PositionalAudio(listener);
				window.carPositionalAudio.setRefDistance(2); // Audible from 2 units away
				window.carPositionalAudio.setMaxDistance(8); // Max audible distance
				window.carPositionalAudio.setRolloffFactor(2); // Faster falloff
				window.carPositionalAudio.setDistanceModel('exponential'); // More realistic distance model

				// Create car-specific EQ (like actual car speakers)
				const audioContext = window.carPositionalAudio.context;

				// Bass boost (typical car subwoofer)
				window.carEQ = {
					bass: audioContext.createBiquadFilter(),
					lowMid: audioContext.createBiquadFilter(),
					highMid: audioContext.createBiquadFilter(),
					treble: audioContext.createBiquadFilter(),
					outsideLowpass: audioContext.createBiquadFilter() // Muffle when outside car
				};

				// Bass boost at 80Hz (car subwoofer range)
				window.carEQ.bass.type = 'lowshelf';
				window.carEQ.bass.frequency.value = 80;
				window.carEQ.bass.gain.value = 6; // +6dB bass boost

				// Cut low-mids at 250Hz (reduce muddiness)
				window.carEQ.lowMid.type = 'peaking';
				window.carEQ.lowMid.frequency.value = 250;
				window.carEQ.lowMid.Q.value = 1;
				window.carEQ.lowMid.gain.value = -3; // -3dB cut

				// Cut high-mids at 2kHz (reduce harshness)
				window.carEQ.highMid.type = 'peaking';
				window.carEQ.highMid.frequency.value = 2000;
				window.carEQ.highMid.Q.value = 1;
				window.carEQ.highMid.gain.value = -2; // -2dB cut

				// Roll off highs at 8kHz (car speakers don't have great treble)
				window.carEQ.treble.type = 'highshelf';
				window.carEQ.treble.frequency.value = 8000;
				window.carEQ.treble.gain.value = -4; // -4dB rolloff

				// Lowpass for when outside car (starts muffled)
				window.carEQ.outsideLowpass.type = 'lowpass';
				window.carEQ.outsideLowpass.frequency.value = 800; // Muffled when outside
				window.carEQ.outsideLowpass.Q.value = 1;

				// Add the positional audio to the car
				car.add(window.carPositionalAudio);

				// Store car audio position globally
				window.carAudioPosition = new THREE.Vector3();
				window.carPositionalAudio.getWorldPosition(window.carAudioPosition);

				// Create debug visualization for car audio position
				const carMarkerGeometry = new THREE.SphereGeometry(0.3, 16, 16);
				const carMarkerMaterial = new THREE.MeshBasicMaterial({
					color: 0xff00ff, // Magenta for car
					transparent: true,
					opacity: 0.8
				});
				window.debugCarMarker = new THREE.Mesh(carMarkerGeometry, carMarkerMaterial);
				window.debugCarMarker.position.copy(car.position);
				window.debugCarMarker.visible = false;
				world.graphicsWorld.add(window.debugCarMarker);

				// Create arrow showing car audio direction
				const carInitialDir = new THREE.Vector3();
				window.carPositionalAudio.getWorldDirection(carInitialDir);
				const carArrowHelper = new THREE.ArrowHelper(
					carInitialDir,
					car.position,
					3, // length
					0xff00ff, // magenta
					0.5, // headLength
					0.3 // headWidth
				);
				window.debugCarArrow = carArrowHelper;
				window.debugCarArrow.visible = false;
				world.graphicsWorld.add(window.debugCarArrow);

				// Create cone visualization for car (just front green cone)
				// Front cone (145°)
				const carFrontConeAngle = 145 * Math.PI / 180;
				const carFrontConeRadius = Math.tan(carFrontConeAngle / 2) * 10;
				const carFrontConeGeometry = new THREE.ConeGeometry(carFrontConeRadius, 10, 32, 1, false);
				const carFrontConeMaterial = new THREE.MeshBasicMaterial({
					color: 0x00ff00,
					transparent: true,
					opacity: 0.2,
					side: THREE.DoubleSide
				});
				window.debugCarFrontCone = new THREE.Mesh(carFrontConeGeometry, carFrontConeMaterial);

				// Position and rotate cone - car faces forward (positive Z)
				const carFrontConeRotation = new THREE.Euler(-Math.PI / 2, 0, 0, 'XYZ');
				window.debugCarFrontCone.rotation.copy(carFrontConeRotation);

				// Position cone at car position
				const carFrontOffset = new THREE.Vector3(0, 0, 5);
				window.debugCarFrontCone.position.copy(car.position).add(carFrontOffset);

				// Add to scene but hide by default
				window.debugCarFrontCone.visible = false;
				world.graphicsWorld.add(window.debugCarFrontCone);

				console.log('🚗 Car spatial audio system created with car EQ + debug visualizations');
			});

			window.character = null; // Store character reference globally
			let character = window.character; // Local reference for compatibility
			window.customizationOpen = false; // Global scope for all menus to access
			let customizationOpen = window.customizationOpen;
			window.terminalOpen = false; // Global scope for C key check
			let terminalOpen = window.terminalOpen;

			// Create a dummy input receiver that does nothing - global scope
			window.dummyInputReceiver = {
				handleKeyboardEvent: () => {},
				handleMouseButton: () => {},
				handleMouseMove: () => {},
				handleMouseWheel: () => {},
				inputReceiverInit: () => {},
				inputReceiverUpdate: () => {}
			};

			loadingManager.loadGLTF('build/assets/boxman.glb', (charModel) => {
				window.character = character = new Sketchbook.Character(charModel);
				character.setPosition(5, 2, 0);
				world.add(character);
				character.takeControl();

				// Add audio listener to the camera for spatial audio
				world.camera.add(audioListener);

				// Set initial camera to face front of character
				setTimeout(() => {
					world.cameraOperator.theta = 180; // Front facing
				}, 100);

				// Create dark sleek floating button in bottom-right
				setTimeout(() => {
					const customizeButton = document.createElement('button');
					customizeButton.className = 'customize-button';
					customizeButton.innerHTML = 'Customize';
					document.body.appendChild(customizeButton);
					console.log('✅ Dark sleek button created!');

					// Create controls panel
					const controlsPanel = document.createElement('div');
					controlsPanel.className = 'controls-panel';
					controlsPanel.innerHTML = `
						<div style="font-weight: bold; margin-bottom: 8px; color: #bee17b;">CONTROLS</div>
						<div>WASD - Move</div>
						<div>Mouse - Look</div>
						<div>Shift - Sprint</div>
						<div>Space - Jump</div>
						<div>E - Aim Mode (hold)</div>
						<div>F - Interact</div>
						<div>C - Customize</div>
					`;
					document.body.appendChild(controlsPanel);

				// Create custom character customization UI
				const customizationDiv = document.createElement('div');
				customizationDiv.className = 'character-customization';

				const textures = [
					{ name: 'solid', display: 'Solid' },
					{ name: 'stripes', display: 'Stripes' },
					{ name: 'dots', display: 'Dots' },
					{ name: 'checker', display: 'Checker' },
					{ name: 'grid', display: 'Grid' },
					{ name: 'diagonal', display: 'Diagonal' },
					{ name: 'waves', display: 'Waves' },
					{ name: 'stars', display: 'Stars' }
				];

				customizationDiv.innerHTML = `
					<h3>Customization</h3>
					<div class="customization-tabs">
						<button class="customization-tab active" data-tab="character">Character</button>
						<button class="customization-tab" data-tab="environment">Environment</button>
					</div>
					<div class="customization-content" id="character-tab">
						<div class="customization-section">
							<div class="section-label">Skin</div>
							<div class="color-picker-container">
								<input type="color" id="skin-color-picker" value="#bee17b">
								<div class="color-info">
									<div class="color-info-label">Current Color</div>
									<div class="color-info-value" id="skin-color-value">#BEE17B</div>
								</div>
							</div>
						</div>

						<div class="customization-section">
							<div class="section-label">Shirt</div>
							<div class="color-picker-container">
								<input type="color" id="shirt-color-picker" value="#ff1400">
								<div class="color-info">
									<div class="color-info-label">Current Color</div>
									<div class="color-info-value" id="shirt-color-value">#FF1400</div>
								</div>
							</div>
						</div>

						<div class="customization-section">
							<div class="section-label">Pants</div>
							<div class="color-picker-container">
								<input type="color" id="pants-color-picker" value="#0f00ff">
								<div class="color-info">
									<div class="color-info-label">Current Color</div>
									<div class="color-info-value" id="pants-color-value">#0F00FF</div>
								</div>
							</div>
						</div>

						<div class="customization-section">
							<div class="section-label">Hat</div>
							<div class="color-picker-container">
								<input type="color" id="hat-color-picker" value="#191919">
								<div class="color-info">
									<div class="color-info-label">Current Color</div>
									<div class="color-info-value" id="hat-color-value">#191919</div>
								</div>
							</div>
						</div>
					</div>
					<div class="customization-content" id="environment-tab" style="display: none;">
						<!-- Floor Section -->
						<div class="collapsible-section collapsed">
							<div class="collapsible-header">
								<div class="collapsible-title">Floor</div>
								<div class="collapsible-arrow">▼</div>
							</div>
							<div class="collapsible-content">
								<div class="customization-section">
									<div class="section-label">Grid Glow</div>
									<div class="color-picker-container">
										<input type="color" id="floor-glow-picker" value="#bee17b">
										<div class="color-info">
											<div class="color-info-label">Emissive Color</div>
											<div class="color-info-value" id="floor-glow-value">#BEE17B</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Panel Color</div>
									<div class="color-picker-container">
										<input type="color" id="floor-panel-picker" value="#000000">
										<div class="color-info">
											<div class="color-info-label">Base Color</div>
											<div class="color-info-value" id="floor-panel-value">#000000</div>
										</div>
									</div>
								</div>
							</div>
						</div>

						<!-- Speakers Section -->
						<div class="collapsible-section collapsed">
							<div class="collapsible-header">
								<div class="collapsible-title">Speakers</div>
								<div class="collapsible-arrow">▼</div>
							</div>
							<div class="collapsible-content">
								<div class="customization-section">
									<div class="section-label">Cabinet Color</div>
									<div class="color-picker-container">
										<input type="color" id="speaker-cab-picker" value="#191919">
										<div class="color-info">
											<div class="color-info-label">CAB Material</div>
											<div class="color-info-value" id="speaker-cab-value">#191919</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Trim Color</div>
									<div class="color-picker-container">
										<input type="color" id="speaker-trim-picker" value="#ffffff">
										<div class="color-info">
											<div class="color-info-label">TRIM Material</div>
											<div class="color-info-value" id="speaker-trim-value">#FFFFFF</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Face Color</div>
									<div class="color-picker-container">
										<input type="color" id="speaker-face-picker" value="#000000">
										<div class="color-info">
											<div class="color-info-label">FACE Material</div>
											<div class="color-info-value" id="speaker-face-value">#000000</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Frame Color</div>
									<div class="color-picker-container">
										<input type="color" id="speaker-frame-picker" value="#333333">
										<div class="color-info">
											<div class="color-info-label">FRAME Material</div>
											<div class="color-info-value" id="speaker-frame-value">#333333</div>
										</div>
									</div>
								</div>
							</div>
						</div>

						<!-- Computer Section -->
						<div class="collapsible-section collapsed">
							<div class="collapsible-header">
								<div class="collapsible-title">Computer</div>
								<div class="collapsible-arrow">▼</div>
							</div>
							<div class="collapsible-content">
								<div class="customization-section">
									<div class="section-label">Chassis Color</div>
									<div class="color-picker-container">
										<input type="color" id="computer-chassis-picker" value="#ffffff">
										<div class="color-info">
											<div class="color-info-label">CHASIS Material</div>
											<div class="color-info-value" id="computer-chassis-value">#FFFFFF</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Keyboard Color</div>
									<div class="color-picker-container">
										<input type="color" id="computer-keyboard-picker" value="#191919">
										<div class="color-info">
											<div class="color-info-label">KEYBOARD Material</div>
											<div class="color-info-value" id="computer-keyboard-value">#191919</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Features Color</div>
									<div class="color-picker-container">
										<input type="color" id="computer-features-picker" value="#bee17b">
										<div class="color-info">
											<div class="color-info-label">FEATURES Material</div>
											<div class="color-info-value" id="computer-features-value">#BEE17B</div>
										</div>
									</div>
								</div>
							</div>
						</div>

						<!-- Car Section -->
						<div class="collapsible-section collapsed">
							<div class="collapsible-header">
								<div class="collapsible-title">Car</div>
								<div class="collapsible-arrow">▼</div>
							</div>
							<div class="collapsible-content">
								<div class="customization-section">
									<div class="section-label">Door Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-door-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">DOOR Material</div>
											<div class="color-info-value" id="car-door-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Frame Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-frame-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">FRAME Material</div>
											<div class="color-info-value" id="car-frame-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Headlights Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-headlights-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">HEADLIGHTS Material</div>
											<div class="color-info-value" id="car-headlights-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Hood Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-hood-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">HOOD Material</div>
											<div class="color-info-value" id="car-hood-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Interior Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-interior-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">INTERIOR Material</div>
											<div class="color-info-value" id="car-interior-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Rims Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-rim-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">RIMS Material</div>
											<div class="color-info-value" id="car-rim-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Steering Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-steering-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">STEERING Material</div>
											<div class="color-info-value" id="car-steering-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Taillights Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-taillights-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">TAILLIGHTS Material</div>
											<div class="color-info-value" id="car-taillights-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Tires Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-tire-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">TIRES Material</div>
											<div class="color-info-value" id="car-tire-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Trim Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-trim-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">TRIM Material</div>
											<div class="color-info-value" id="car-trim-value">#282828</div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
					<div class="customization-footer">
						<button class="reset-defaults-button" id="reset-defaults-btn">Reset to Defaults</button>
					</div>
				`;

				document.body.appendChild(customizationDiv);

				// Tab switching logic
				const tabs = customizationDiv.querySelectorAll('.customization-tab');
				tabs.forEach(tab => {
					tab.addEventListener('click', () => {
						tabs.forEach(t => t.classList.remove('active'));
						tab.classList.add('active');

						const tabName = tab.getAttribute('data-tab');
						document.getElementById('character-tab').style.display = tabName === 'character' ? 'block' : 'none';
						document.getElementById('environment-tab').style.display = tabName === 'environment' ? 'block' : 'none';
					});
				});

				// Collapsible section logic
				const collapsibleHeaders = customizationDiv.querySelectorAll('.collapsible-header');
				collapsibleHeaders.forEach(header => {
					header.addEventListener('click', () => {
						const section = header.parentElement;
						section.classList.toggle('collapsed');
					});
				});

				// Texture generation functions
				function generateTexture(type, color = '#ffffff', density = 1) {
					const canvas = document.createElement('canvas');
					canvas.width = 256;
					canvas.height = 256;
					const ctx = canvas.getContext('2d');

					ctx.fillStyle = color;
					ctx.fillRect(0, 0, 256, 256);

					ctx.strokeStyle = '#000000';
					ctx.fillStyle = '#000000';
					ctx.lineWidth = 4;

					const spacing = 32 / density;

					switch(type) {
						case 'stripes':
							for (let i = 0; i < 256; i += spacing) {
								ctx.fillRect(i, 0, spacing / 2, 256);
							}
							break;
						case 'dots':
							const dotSize = 8 / density;
							for (let y = spacing / 2; y < 256; y += spacing) {
								for (let x = spacing / 2; x < 256; x += spacing) {
									ctx.beginPath();
									ctx.arc(x, y, dotSize, 0, Math.PI * 2);
									ctx.fill();
								}
							}
							break;
						case 'checker':
							for (let y = 0; y < 256; y += spacing) {
								for (let x = 0; x < 256; x += spacing) {
									if ((Math.floor(x / spacing) + Math.floor(y / spacing)) % 2 === 0) {
										ctx.fillRect(x, y, spacing, spacing);
									}
								}
							}
							break;
						case 'grid':
							for (let i = 0; i <= 256; i += spacing) {
								ctx.beginPath();
								ctx.moveTo(i, 0);
								ctx.lineTo(i, 256);
								ctx.stroke();
								ctx.beginPath();
								ctx.moveTo(0, i);
								ctx.lineTo(256, i);
								ctx.stroke();
							}
							break;
						case 'diagonal':
							for (let i = -256; i < 512; i += spacing) {
								ctx.beginPath();
								ctx.moveTo(i, 0);
								ctx.lineTo(i + 256, 256);
								ctx.stroke();
							}
							break;
						case 'waves':
							const waveFreq = 0.05 * density;
							ctx.beginPath();
							for (let x = 0; x <= 256; x += 4) {
								const y = 128 + Math.sin(x * waveFreq) * 40;
								if (x === 0) ctx.moveTo(x, y);
								else ctx.lineTo(x, y);
							}
							ctx.stroke();
							ctx.beginPath();
							for (let x = 0; x <= 256; x += 4) {
								const y = 128 + Math.sin(x * waveFreq + Math.PI) * 40;
								if (x === 0) ctx.moveTo(x, y);
								else ctx.lineTo(x, y);
							}
							ctx.stroke();
							break;
						case 'stars':
							const starCount = Math.floor(20 * density);
							for (let i = 0; i < starCount; i++) {
								const x = Math.random() * 256;
								const y = Math.random() * 256;
								const size = 8 / Math.sqrt(density);
								ctx.beginPath();
								for (let j = 0; j < 5; j++) {
									const angle = (j * 4 * Math.PI) / 5 - Math.PI / 2;
									const radius = j % 2 === 0 ? size : size / 2;
									const px = x + Math.cos(angle) * radius;
									const py = y + Math.sin(angle) * radius;
									if (j === 0) ctx.moveTo(px, py);
									else ctx.lineTo(px, py);
								}
								ctx.closePath();
								ctx.fill();
							}
							break;
					}

					return new THREE.CanvasTexture(canvas);
				}

				// Draw texture previews
				textures.forEach(tex => {
					const previewCanvas = document.getElementById(`texture-preview-${tex.name}`);
					if (previewCanvas) {
						previewCanvas.width = 64;
						previewCanvas.height = 64;
						const ctx = previewCanvas.getContext('2d');

						// Generate a small preview
						const tempCanvas = document.createElement('canvas');
						tempCanvas.width = 64;
						tempCanvas.height = 64;
						const tempCtx = tempCanvas.getContext('2d');

						tempCtx.fillStyle = '#667eea';
						tempCtx.fillRect(0, 0, 64, 64);
						tempCtx.strokeStyle = '#ffffff';
						tempCtx.fillStyle = '#ffffff';
						tempCtx.lineWidth = 2;

						switch(tex.name) {
							case 'stripes':
								for (let i = 0; i < 64; i += 8) {
									tempCtx.fillRect(i, 0, 4, 64);
								}
								break;
							case 'dots':
								for (let y = 8; y < 64; y += 16) {
									for (let x = 8; x < 64; x += 16) {
										tempCtx.beginPath();
										tempCtx.arc(x, y, 3, 0, Math.PI * 2);
										tempCtx.fill();
									}
								}
								break;
							case 'checker':
								for (let y = 0; y < 64; y += 16) {
									for (let x = 0; x < 64; x += 16) {
										if ((x + y) / 16 % 2 === 0) {
											tempCtx.fillRect(x, y, 16, 16);
										}
									}
								}
								break;
							case 'grid':
								for (let i = 0; i <= 64; i += 16) {
									tempCtx.beginPath();
									tempCtx.moveTo(i, 0);
									tempCtx.lineTo(i, 64);
									tempCtx.stroke();
									tempCtx.beginPath();
									tempCtx.moveTo(0, i);
									tempCtx.lineTo(64, i);
									tempCtx.stroke();
								}
								break;
							case 'diagonal':
								for (let i = -64; i < 128; i += 16) {
									tempCtx.beginPath();
									tempCtx.moveTo(i, 0);
									tempCtx.lineTo(i + 64, 64);
									tempCtx.stroke();
								}
								break;
							case 'waves':
								tempCtx.beginPath();
								for (let x = 0; x <= 64; x += 2) {
									const y = 32 + Math.sin(x * 0.2) * 10;
									if (x === 0) tempCtx.moveTo(x, y);
									else tempCtx.lineTo(x, y);
								}
								tempCtx.stroke();
								break;
							case 'stars':
								for (let i = 0; i < 5; i++) {
									const x = 16 + (i % 3) * 16;
									const y = 16 + Math.floor(i / 3) * 16;
									tempCtx.font = '12px Arial';
									tempCtx.fillText('★', x, y);
								}
								break;
						}

						ctx.drawImage(tempCanvas, 0, 0);
					}
				});

				// Load saved customization from localStorage or use defaults
				let savedCustomization = localStorage.getItem('characterCustomization');
				let customizationData = savedCustomization ? JSON.parse(savedCustomization) : {
					skinColor: '#bee17b',
					shirtColor: '#282828',
					pantsColor: '#282828',
					hatColor: '#282828',
					floorGlowColor: '#bee17b',
					floorPanelColor: '#282828',
					speakerCabColor: '#282828',
					speakerTrimColor: '#282828',
					speakerFaceColor: '#282828',
					speakerFrameColor: '#282828',
					computerChassisColor: '#282828',
					computerKeyboardColor: '#191919',
					computerFeaturesColor: '#bee17b',
					carDoorColor: '#282828',
					carFrameColor: '#282828',
					carHeadlightsColor: '#282828',
					carHoodColor: '#282828',
					carInteriorColor: '#282828',
					carRimColor: '#282828',
					carSteeringColor: '#282828',
					carTaillightsColor: '#282828',
					carTireColor: '#282828',
					carTrimColor: '#282828',
					textureType: 'solid',
					textureScale: 1.0,
					textureRotation: 0,
					textureDensity: 1.0
				};

				// Store colors for each part
				let skinColor = customizationData.skinColor;
				let shirtColor = customizationData.shirtColor;
				let pantsColor = customizationData.pantsColor;
				let hatColor = customizationData.hatColor;
				let floorGlowColor = customizationData.floorGlowColor || '#bee17b';
				let floorPanelColor = customizationData.floorPanelColor || '#282828';
				let speakerCabColor = customizationData.speakerCabColor || '#282828';
				let speakerTrimColor = customizationData.speakerTrimColor || '#282828';
				let speakerFaceColor = customizationData.speakerFaceColor || '#282828';
				let speakerFrameColor = customizationData.speakerFrameColor || '#282828';
				let computerChassisColor = customizationData.computerChassisColor || '#282828';
				let computerKeyboardColor = customizationData.computerKeyboardColor || '#191919';
				let computerFeaturesColor = customizationData.computerFeaturesColor || '#bee17b';
				let carDoorColor = customizationData.carDoorColor || '#282828';
				let carFrameColor = customizationData.carFrameColor || '#282828';
				let carHeadlightsColor = customizationData.carHeadlightsColor || '#282828';
				let carHoodColor = customizationData.carHoodColor || '#282828';
				let carInteriorColor = customizationData.carInteriorColor || '#282828';
				let carRimColor = customizationData.carRimColor || '#282828';
				let carSteeringColor = customizationData.carSteeringColor || '#282828';
				let carTaillightsColor = customizationData.carTaillightsColor || '#282828';
				let carTireColor = customizationData.carTireColor || '#282828';
				let carTrimColor = customizationData.carTrimColor || '#282828';
				let savedCameraTheta, savedCameraPhi, savedCameraRadius;

				// Set colors globally IMMEDIATELY so they're available when assets load
				window.speakerCabColor = speakerCabColor;
				window.speakerTrimColor = speakerTrimColor;
				window.speakerFaceColor = speakerFaceColor;
				window.speakerFrameColor = speakerFrameColor;
				window.computerChassisColor = computerChassisColor;
				window.computerKeyboardColor = computerKeyboardColor;
				window.computerFeaturesColor = computerFeaturesColor;
				window.carDoorColor = carDoorColor;
				window.carFrameColor = carFrameColor;
				window.carHeadlightsColor = carHeadlightsColor;
				window.carHoodColor = carHoodColor;
				window.carInteriorColor = carInteriorColor;
				window.carRimColor = carRimColor;
				window.carSteeringColor = carSteeringColor;
				window.carTaillightsColor = carTaillightsColor;
				window.carTireColor = carTireColor;
				window.carTrimColor = carTrimColor;

				// Function to save customization to localStorage
				function saveCustomization() {
					const data = {
						skinColor,
						shirtColor,
						pantsColor,
						hatColor,
						floorGlowColor,
						floorPanelColor,
						speakerCabColor,
						speakerTrimColor,
						speakerFaceColor,
						speakerFrameColor,
						computerChassisColor,
						computerKeyboardColor,
						computerFeaturesColor,
						carDoorColor,
						carFrameColor,
						carHeadlightsColor,
						carHoodColor,
						carInteriorColor,
						carRimColor,
						carSteeringColor,
						carTaillightsColor,
						carTireColor,
						carTrimColor,
						textureType: document.getElementById('texture-type')?.value || 'solid',
						textureScale: parseFloat(document.getElementById('texture-scale')?.value || 1.0),
						textureRotation: parseFloat(document.getElementById('texture-rotation')?.value || 0),
						textureDensity: parseFloat(document.getElementById('texture-density')?.value || 1.0)
					};
					localStorage.setItem('characterCustomization', JSON.stringify(data));
					console.log('💾 Customization saved:', data);
				}

				function updateCharacter() {
					character.traverse((child) => {
						if (child.isMesh && child.material) {
							const materialName = child.material.name.toLowerCase();

							// Apply color based on material name
							if (materialName.includes('skin')) {
								child.material.color.set(skinColor);
							} else if (materialName.includes('shirt')) {
								child.material.color.set(shirtColor);
							} else if (materialName.includes('pants')) {
								child.material.color.set(pantsColor);
							} else if (materialName.includes('hat')) {
								// If hat has username texture, regenerate it with new color
								if (child.material.map && window.authState?.isLoggedIn) {
									child.material.color.set(hatColor);
									const username = window.authState.user?.username ||
													 window.authState.user?.displayName ||
													 window.authState.email?.split('@')[0] ||
													 'USER';
									window.updateHatWithUsername(username);
								} else {
									child.material.color.set(hatColor);
								}
							}

							// Remove any texture EXCEPT on hat (preserve username texture)
							if (!materialName.includes('hat')) {
								child.material.map = null;
							}
							child.material.needsUpdate = true;
						}
					});
				}

						let isOpeningCustomization = false;

						function openCustomization() {
							if (customizationOpen || isOpeningCustomization) return; // Already open or opening
							isOpeningCustomization = true;

							// Set movement target to zero to slow down naturally (while controls still active)
							character.velocitySimulator.target.set(0, 0, 0);

							// Check velocity every frame until character stops
							let checkStopInterval = setInterval(() => {
								const speed = character.velocity.length();

								// If character is nearly stopped (velocity < 0.1)
								if (speed < 0.1) {
									clearInterval(checkStopInterval);
									window.customizationOpen = customizationOpen = true;
									isOpeningCustomization = false;

									// Disable character controls NOW
									world.inputManager.inputReceiver = window.dummyInputReceiver;

									// Fully stop the character
									character.velocity.set(0, 0, 0);
									character.velocitySimulator.position.set(0, 0, 0);
									character.velocitySimulator.velocity.set(0, 0, 0);
									character.velocitySimulator.target.set(0, 0, 0);
									character.angularVelocity = 0;

									// Save camera position
									savedCameraTheta = world.cameraOperator.theta;
									savedCameraPhi = world.cameraOperator.phi;
									savedCameraRadius = world.cameraOperator.radius;

									// Move camera to front of character
									// Character rotation.y is in radians, theta is also in radians
									// Add PI to face the front (opposite direction of character's facing)
									const characterRotation = character.rotation.y;
									world.cameraOperator.theta = characterRotation + Math.PI;
									world.cameraOperator.phi = 0;
									world.cameraOperator.radius = 2.5;

									// Enable mouse cursor - exit pointer lock
									if (document.pointerLockElement) {
										document.exitPointerLock();
									}

									// Show menu
									customizationDiv.classList.add('active');
									customizeButton.innerHTML = 'Close';
								}
							}, 16); // Check every frame (~60fps)
						}

						function closeCustomization() {
							if (!customizationOpen) return; // Already closed
							window.customizationOpen = customizationOpen = false;

							// Hide menu
							customizationDiv.classList.remove('active');
							customizeButton.innerHTML = 'Customize';

							// Restore camera position
							world.cameraOperator.theta = savedCameraTheta;
							world.cameraOperator.phi = savedCameraPhi;
							world.cameraOperator.radius = savedCameraRadius;

							// Re-enable character controls
							character.takeControl();

							// Re-lock pointer for game controls
							setTimeout(() => {
								world.renderer.domElement.requestPointerLock();
							}, 100);
						}

						function toggleCustomization() {
							if (customizationOpen) {
								closeCustomization();
							} else {
								openCustomization();
							}
						}

						customizeButton.addEventListener('click', toggleCustomization);

						// C key to toggle customization
						document.addEventListener('keydown', (e) => {
							if (e.key === 'c' || e.key === 'C') {
								if (!terminalOpen) {
									e.preventDefault();
									e.stopPropagation();
									e.stopImmediatePropagation();
									toggleCustomization();
									return false;
								}
							}
						}, true);

						// ESC key to close customization
						document.addEventListener('keydown', (e) => {
							if (e.key === 'Escape' && customizationOpen) {
								e.preventDefault();
								e.stopPropagation();
								e.stopImmediatePropagation();
								closeCustomization();
								return false;
							}
						}, true);

						// Click outside to lock camera and enable free look (like normal gameplay)
						let cameraLocked = false;
						document.addEventListener('click', (e) => {
							if (customizationOpen) {
								// Check if click is outside the customization menu and customize button
								if (!customizationDiv.contains(e.target) && !customizeButton.contains(e.target)) {
									if (!cameraLocked) {
										// Lock pointer and enable camera control
										cameraLocked = true;
										world.inputManager.inputReceiver = world.cameraOperator;
										world.renderer.domElement.requestPointerLock();
									} else {
										// Unlock pointer - toggle off
										cameraLocked = false;
										world.inputManager.inputReceiver = window.dummyInputReceiver;
										if (document.pointerLockElement) {
											document.exitPointerLock();
										}
									}
								}
							}
						});

						// When pointer lock is released (ESC), restore menu control
						document.addEventListener('pointerlockchange', () => {
							if (customizationOpen && !document.pointerLockElement && cameraLocked) {
								cameraLocked = false;
								world.inputManager.inputReceiver = window.dummyInputReceiver;
							}
						});

					// Color picker input handlers
					const skinColorPicker = document.getElementById('skin-color-picker');
					const shirtColorPicker = document.getElementById('shirt-color-picker');
					const pantsColorPicker = document.getElementById('pants-color-picker');
					const hatColorPicker = document.getElementById('hat-color-picker');
					const floorGlowPicker = document.getElementById('floor-glow-picker');
					const floorPanelPicker = document.getElementById('floor-panel-picker');
					const speakerCabPicker = document.getElementById('speaker-cab-picker');
					const speakerTrimPicker = document.getElementById('speaker-trim-picker');
					const speakerFacePicker = document.getElementById('speaker-face-picker');
					const speakerFramePicker = document.getElementById('speaker-frame-picker');
					const computerChassisPicker = document.getElementById('computer-chassis-picker');
					const computerKeyboardPicker = document.getElementById('computer-keyboard-picker');
					const computerFeaturesPicker = document.getElementById('computer-features-picker');
					const carDoorPicker = document.getElementById('car-door-picker');
					const carFramePicker = document.getElementById('car-frame-picker');
					const carHeadlightsPicker = document.getElementById('car-headlights-picker');
					const carHoodPicker = document.getElementById('car-hood-picker');
					const carInteriorPicker = document.getElementById('car-interior-picker');
					const carRimPicker = document.getElementById('car-rim-picker');
					const carSteeringPicker = document.getElementById('car-steering-picker');
					const carTaillightsPicker = document.getElementById('car-taillights-picker');
					const carTirePicker = document.getElementById('car-tire-picker');
					const carTrimPicker = document.getElementById('car-trim-picker');

					const skinColorValue = document.getElementById('skin-color-value');
					const shirtColorValue = document.getElementById('shirt-color-value');
					const pantsColorValue = document.getElementById('pants-color-value');
					const hatColorValue = document.getElementById('hat-color-value');
					const floorGlowValue = document.getElementById('floor-glow-value');
					const floorPanelValue = document.getElementById('floor-panel-value');
					const speakerCabValue = document.getElementById('speaker-cab-value');
					const speakerTrimValue = document.getElementById('speaker-trim-value');
					const speakerFaceValue = document.getElementById('speaker-face-value');
					const speakerFrameValue = document.getElementById('speaker-frame-value');
					const computerChassisValue = document.getElementById('computer-chassis-value');
					const computerKeyboardValue = document.getElementById('computer-keyboard-value');
					const computerFeaturesValue = document.getElementById('computer-features-value');
					const carDoorValue = document.getElementById('car-door-value');
					const carFrameValue = document.getElementById('car-frame-value');
					const carHeadlightsValue = document.getElementById('car-headlights-value');
					const carHoodValue = document.getElementById('car-hood-value');
					const carInteriorValue = document.getElementById('car-interior-value');
					const carRimValue = document.getElementById('car-rim-value');
					const carSteeringValue = document.getElementById('car-steering-value');
					const carTaillightsValue = document.getElementById('car-taillights-value');
					const carTireValue = document.getElementById('car-tire-value');
					const carTrimValue = document.getElementById('car-trim-value');

					// Initialize UI with saved values
					skinColorPicker.value = skinColor;
					skinColorValue.textContent = skinColor.toUpperCase();
					shirtColorPicker.value = shirtColor;
					shirtColorValue.textContent = shirtColor.toUpperCase();
					pantsColorPicker.value = pantsColor;
					pantsColorValue.textContent = pantsColor.toUpperCase();
					hatColorPicker.value = hatColor;
					hatColorValue.textContent = hatColor.toUpperCase();
					floorGlowPicker.value = floorGlowColor;
					floorGlowValue.textContent = floorGlowColor.toUpperCase();
					floorPanelPicker.value = floorPanelColor;
					floorPanelValue.textContent = floorPanelColor.toUpperCase();
					speakerCabPicker.value = speakerCabColor;
					speakerCabValue.textContent = speakerCabColor.toUpperCase();
					speakerTrimPicker.value = speakerTrimColor;
					speakerTrimValue.textContent = speakerTrimColor.toUpperCase();
					speakerFacePicker.value = speakerFaceColor;
					speakerFaceValue.textContent = speakerFaceColor.toUpperCase();
					speakerFramePicker.value = speakerFrameColor;
					speakerFrameValue.textContent = speakerFrameColor.toUpperCase();
					computerChassisPicker.value = computerChassisColor;
					computerChassisValue.textContent = computerChassisColor.toUpperCase();
					computerKeyboardPicker.value = computerKeyboardColor;
					computerKeyboardValue.textContent = computerKeyboardColor.toUpperCase();
					computerFeaturesPicker.value = computerFeaturesColor;
					computerFeaturesValue.textContent = computerFeaturesColor.toUpperCase();
					carDoorPicker.value = carDoorColor;
					carDoorValue.textContent = carDoorColor.toUpperCase();
					carFramePicker.value = carFrameColor;
					carFrameValue.textContent = carFrameColor.toUpperCase();
					carHeadlightsPicker.value = carHeadlightsColor;
					carHeadlightsValue.textContent = carHeadlightsColor.toUpperCase();
					carHoodPicker.value = carHoodColor;
					carHoodValue.textContent = carHoodColor.toUpperCase();
					carInteriorPicker.value = carInteriorColor;
					carInteriorValue.textContent = carInteriorColor.toUpperCase();
					carRimPicker.value = carRimColor;
					carRimValue.textContent = carRimColor.toUpperCase();
					carSteeringPicker.value = carSteeringColor;
					carSteeringValue.textContent = carSteeringColor.toUpperCase();
					carTaillightsPicker.value = carTaillightsColor;
					carTaillightsValue.textContent = carTaillightsColor.toUpperCase();
					carTirePicker.value = carTireColor;
					carTireValue.textContent = carTireColor.toUpperCase();
					carTrimPicker.value = carTrimColor;
					carTrimValue.textContent = carTrimColor.toUpperCase();

					// Make colors globally accessible for applying to objects loaded later
					window.speakerCabColor = speakerCabColor;
					window.speakerTrimColor = speakerTrimColor;
					window.speakerFaceColor = speakerFaceColor;
					window.speakerFrameColor = speakerFrameColor;
					window.computerChassisColor = computerChassisColor;
					window.computerKeyboardColor = computerKeyboardColor;
					window.computerFeaturesColor = computerFeaturesColor;
					window.carDoorColor = carDoorColor;
					window.carFrameColor = carFrameColor;
					window.carHeadlightsColor = carHeadlightsColor;
					window.carHoodColor = carHoodColor;
					window.carInteriorColor = carInteriorColor;
					window.carRimColor = carRimColor;
					window.carSteeringColor = carSteeringColor;
					window.carTaillightsColor = carTaillightsColor;
					window.carTireColor = carTireColor;
					window.carTrimColor = carTrimColor;

					// Apply floor colors immediately
					if (window.groundMesh && window.generateGridTexture) {
						window.generateGridTexture(floorGlowColor, floorPanelColor);
						window.groundMesh.material.emissive.set(floorGlowColor);
						window.groundMesh.material.color.set(floorPanelColor);
					}

					// Apply saved customization immediately
					updateCharacter();

					// Skin color picker
					skinColorPicker.addEventListener('input', (e) => {
						skinColor = e.target.value;
						skinColorValue.textContent = skinColor.toUpperCase();
						updateCharacter();
						saveCustomization();
					});

					// Shirt color picker
					shirtColorPicker.addEventListener('input', (e) => {
						shirtColor = e.target.value;
						shirtColorValue.textContent = shirtColor.toUpperCase();
						updateCharacter();
						saveCustomization();
					});

					// Pants color picker
					pantsColorPicker.addEventListener('input', (e) => {
						pantsColor = e.target.value;
						pantsColorValue.textContent = pantsColor.toUpperCase();
						updateCharacter();
						saveCustomization();
					});

					// Hat color picker
					hatColorPicker.addEventListener('input', (e) => {
						hatColor = e.target.value;
						hatColorValue.textContent = hatColor.toUpperCase();
						updateCharacter();
						saveCustomization();
					});

					// Floor glow color picker
					floorGlowPicker.addEventListener('input', (e) => {
						floorGlowColor = e.target.value;
						floorGlowValue.textContent = floorGlowColor.toUpperCase();
						if (window.groundMesh && window.generateGridTexture) {
							window.generateGridTexture(floorGlowColor, floorPanelColor);
							window.groundMesh.material.emissive.set(floorGlowColor);
						}
						saveCustomization();
					});

					// Floor panel color picker
					floorPanelPicker.addEventListener('input', (e) => {
						floorPanelColor = e.target.value;
						floorPanelValue.textContent = floorPanelColor.toUpperCase();
						if (window.groundMesh && window.generateGridTexture) {
							window.generateGridTexture(floorGlowColor, floorPanelColor);
							window.groundMesh.material.color.set(floorPanelColor);
						}
						saveCustomization();
					});

					// Speaker cabinet color picker
					speakerCabPicker.addEventListener('input', (e) => {
						speakerCabColor = e.target.value;
						window.speakerCabColor = speakerCabColor; // Update global
						speakerCabValue.textContent = speakerCabColor.toUpperCase();
						if (window.speakers) {
							window.speakers.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'CAB' || matName.toLowerCase().includes('cab')) {
										child.material.color.set(speakerCabColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Speaker trim color picker
					speakerTrimPicker.addEventListener('input', (e) => {
						speakerTrimColor = e.target.value;
						window.speakerTrimColor = speakerTrimColor; // Update global
						speakerTrimValue.textContent = speakerTrimColor.toUpperCase();
						if (window.speakers) {
							window.speakers.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'TRIM' || matName === 'SPEAKER_TRIM' || (matName.toLowerCase().includes('trim') && matName.toLowerCase().includes('speaker'))) {
										child.material.color.set(speakerTrimColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Speaker face color picker
					speakerFacePicker.addEventListener('input', (e) => {
						speakerFaceColor = e.target.value;
						window.speakerFaceColor = speakerFaceColor; // Update global
						speakerFaceValue.textContent = speakerFaceColor.toUpperCase();
						if (window.speakers) {
							window.speakers.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'FACE' || matName.toLowerCase().includes('face')) {
										child.material.color.set(speakerFaceColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Speaker frame color picker
					speakerFramePicker.addEventListener('input', (e) => {
						speakerFrameColor = e.target.value;
						window.speakerFrameColor = speakerFrameColor; // Update global
						speakerFrameValue.textContent = speakerFrameColor.toUpperCase();
						if (window.speakers) {
							window.speakers.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'FRAME' || matName === 'SPEAKER_FRAME' || (matName.toLowerCase().includes('frame') && matName.toLowerCase().includes('speaker'))) {
										child.material.color.set(speakerFrameColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Computer chassis color picker
					computerChassisPicker.addEventListener('input', (e) => {
						computerChassisColor = e.target.value;
						window.computerChassisColor = computerChassisColor; // Update global
						computerChassisValue.textContent = computerChassisColor.toUpperCase();
						if (window.computer) {
							window.computer.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'CHASIS' || matName.toLowerCase().includes('chasis')) {
										child.material.color.set(computerChassisColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Computer keyboard color picker
					computerKeyboardPicker.addEventListener('input', (e) => {
						computerKeyboardColor = e.target.value;
						window.computerKeyboardColor = computerKeyboardColor; // Update global
						computerKeyboardValue.textContent = computerKeyboardColor.toUpperCase();
						if (window.computer) {
							window.computer.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'KEYBOARD' || matName.toLowerCase().includes('keyboard')) {
										child.material.color.set(computerKeyboardColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Computer features color picker
					computerFeaturesPicker.addEventListener('input', (e) => {
						computerFeaturesColor = e.target.value;
						window.computerFeaturesColor = computerFeaturesColor; // Update global
						computerFeaturesValue.textContent = computerFeaturesColor.toUpperCase();
						if (window.computer) {
							window.computer.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'FEATURES' || matName.toLowerCase().includes('features')) {
										child.material.color.set(computerFeaturesColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car door color picker
					carDoorPicker.addEventListener('input', (e) => {
						carDoorColor = e.target.value;
						window.carDoorColor = carDoorColor;
						carDoorValue.textContent = carDoorColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'DOOR' || matName.toLowerCase().includes('door')) {
										child.material.color.set(carDoorColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car frame color picker
					carFramePicker.addEventListener('input', (e) => {
						carFrameColor = e.target.value;
						window.carFrameColor = carFrameColor;
						carFrameValue.textContent = carFrameColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
										child.material.color.set(carFrameColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car headlights color picker
					carHeadlightsPicker.addEventListener('input', (e) => {
						carHeadlightsColor = e.target.value;
						window.carHeadlightsColor = carHeadlightsColor;
						carHeadlightsValue.textContent = carHeadlightsColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'HEADLIGHTS' || matName.toLowerCase().includes('headlight')) {
										child.material.color.set(carHeadlightsColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car hood color picker
					carHoodPicker.addEventListener('input', (e) => {
						carHoodColor = e.target.value;
						window.carHoodColor = carHoodColor;
						carHoodValue.textContent = carHoodColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'HOOD' || matName.toLowerCase().includes('hood')) {
										child.material.color.set(carHoodColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car interior color picker
					carInteriorPicker.addEventListener('input', (e) => {
						carInteriorColor = e.target.value;
						window.carInteriorColor = carInteriorColor;
						carInteriorValue.textContent = carInteriorColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'INTERIOR' || matName.toLowerCase().includes('interior')) {
										child.material.color.set(carInteriorColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car rims color picker
					carRimPicker.addEventListener('input', (e) => {
						carRimColor = e.target.value;
						window.carRimColor = carRimColor;
						carRimValue.textContent = carRimColor.toUpperCase();
						if (window.car) {
							// Traverse car body
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
										child.material.color.set(carRimColor);
									}
								}
							});
							// Also traverse wheel objects (they're separate)
							if (window.car.wheels) {
								window.car.wheels.forEach((wheel) => {
									wheel.wheelObject.traverse((child) => {
										if (child.isMesh && child.material) {
											const matName = child.material.name;
											if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
												child.material.color.set(carRimColor);
											}
										}
									});
								});
							}
						}
						saveCustomization();
					});

					// Car steering color picker
					carSteeringPicker.addEventListener('input', (e) => {
						carSteeringColor = e.target.value;
						window.carSteeringColor = carSteeringColor;
						carSteeringValue.textContent = carSteeringColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'STEERING' || matName.toLowerCase().includes('steering')) {
										child.material.color.set(carSteeringColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car taillights color picker
					carTaillightsPicker.addEventListener('input', (e) => {
						carTaillightsColor = e.target.value;
						window.carTaillightsColor = carTaillightsColor;
						carTaillightsValue.textContent = carTaillightsColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'TAILLIGHTS' || matName.toLowerCase().includes('taillight')) {
										child.material.color.set(carTaillightsColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car tires color picker
					carTirePicker.addEventListener('input', (e) => {
						carTireColor = e.target.value;
						window.carTireColor = carTireColor;
						carTireValue.textContent = carTireColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
										child.material.color.set(carTireColor);
									}
								}
							});
							if (window.car.wheels) {
								window.car.wheels.forEach((wheel) => {
									wheel.wheelObject.traverse((child) => {
										if (child.isMesh && child.material) {
											const matName = child.material.name;
											if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
												child.material.color.set(carTireColor);
											}
										}
									});
								});
							}
						}
						saveCustomization();
					});

					// Car trim color picker
					carTrimPicker.addEventListener('input', (e) => {
						carTrimColor = e.target.value;
						window.carTrimColor = carTrimColor;
						carTrimValue.textContent = carTrimColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'TRIM' || matName.toLowerCase().includes('trim')) {
										child.material.color.set(carTrimColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Reset to Defaults button
					const resetButton = document.getElementById('reset-defaults-btn');
					resetButton.addEventListener('click', () => {
						if (confirm('Reset all colors to defaults? This will clear your saved customization.')) {
							// Clear localStorage
							localStorage.removeItem('characterCustomization');

							// Define default colors
							const defaults = {
								skinColor: '#bee17b',
								shirtColor: '#282828',
								pantsColor: '#282828',
								hatColor: '#282828',
								floorGlowColor: '#bee17b',
								floorPanelColor: '#282828',
								speakerCabColor: '#282828',
								speakerTrimColor: '#282828',
								speakerFaceColor: '#282828',
								speakerFrameColor: '#282828',
								computerChassisColor: '#282828',
								computerKeyboardColor: '#191919',
								computerFeaturesColor: '#bee17b',
								carDoorColor: '#282828',
								carFrameColor: '#282828',
								carHeadlightsColor: '#282828',
								carHoodColor: '#282828',
								carInteriorColor: '#282828',
								carRimColor: '#282828',
								carSteeringColor: '#282828',
								carTaillightsColor: '#282828',
								carTireColor: '#282828',
								carTrimColor: '#282828'
							};

							// Update all pickers and values
							skinColorPicker.value = defaults.skinColor;
							skinColorValue.textContent = defaults.skinColor.toUpperCase();
							skinColor = defaults.skinColor;

							shirtColorPicker.value = defaults.shirtColor;
							shirtColorValue.textContent = defaults.shirtColor.toUpperCase();
							shirtColor = defaults.shirtColor;

							pantsColorPicker.value = defaults.pantsColor;
							pantsColorValue.textContent = defaults.pantsColor.toUpperCase();
							pantsColor = defaults.pantsColor;

							hatColorPicker.value = defaults.hatColor;
							hatColorValue.textContent = defaults.hatColor.toUpperCase();
							hatColor = defaults.hatColor;

							floorGlowPicker.value = defaults.floorGlowColor;
							floorGlowValue.textContent = defaults.floorGlowColor.toUpperCase();
							floorGlowColor = defaults.floorGlowColor;

							floorPanelPicker.value = defaults.floorPanelColor;
							floorPanelValue.textContent = defaults.floorPanelColor.toUpperCase();
							floorPanelColor = defaults.floorPanelColor;

							speakerCabPicker.value = defaults.speakerCabColor;
							speakerCabValue.textContent = defaults.speakerCabColor.toUpperCase();
							speakerCabColor = defaults.speakerCabColor;

							speakerTrimPicker.value = defaults.speakerTrimColor;
							speakerTrimValue.textContent = defaults.speakerTrimColor.toUpperCase();
							speakerTrimColor = defaults.speakerTrimColor;

							speakerFacePicker.value = defaults.speakerFaceColor;
							speakerFaceValue.textContent = defaults.speakerFaceColor.toUpperCase();
							speakerFaceColor = defaults.speakerFaceColor;

							speakerFramePicker.value = defaults.speakerFrameColor;
							speakerFrameValue.textContent = defaults.speakerFrameColor.toUpperCase();
							speakerFrameColor = defaults.speakerFrameColor;

							computerChassisPicker.value = defaults.computerChassisColor;
							computerChassisValue.textContent = defaults.computerChassisColor.toUpperCase();
							computerChassisColor = defaults.computerChassisColor;

							computerKeyboardPicker.value = defaults.computerKeyboardColor;
							computerKeyboardValue.textContent = defaults.computerKeyboardColor.toUpperCase();
							computerKeyboardColor = defaults.computerKeyboardColor;

							computerFeaturesPicker.value = defaults.computerFeaturesColor;
							computerFeaturesValue.textContent = defaults.computerFeaturesColor.toUpperCase();
							computerFeaturesColor = defaults.computerFeaturesColor;

							carDoorPicker.value = defaults.carDoorColor;
							carDoorValue.textContent = defaults.carDoorColor.toUpperCase();
							carDoorColor = defaults.carDoorColor;

							carFramePicker.value = defaults.carFrameColor;
							carFrameValue.textContent = defaults.carFrameColor.toUpperCase();
							carFrameColor = defaults.carFrameColor;

							carHeadlightsPicker.value = defaults.carHeadlightsColor;
							carHeadlightsValue.textContent = defaults.carHeadlightsColor.toUpperCase();
							carHeadlightsColor = defaults.carHeadlightsColor;

							carHoodPicker.value = defaults.carHoodColor;
							carHoodValue.textContent = defaults.carHoodColor.toUpperCase();
							carHoodColor = defaults.carHoodColor;

							carInteriorPicker.value = defaults.carInteriorColor;
							carInteriorValue.textContent = defaults.carInteriorColor.toUpperCase();
							carInteriorColor = defaults.carInteriorColor;

							carRimPicker.value = defaults.carRimColor;
							carRimValue.textContent = defaults.carRimColor.toUpperCase();
							carRimColor = defaults.carRimColor;

							carSteeringPicker.value = defaults.carSteeringColor;
							carSteeringValue.textContent = defaults.carSteeringColor.toUpperCase();
							carSteeringColor = defaults.carSteeringColor;

							carTaillightsPicker.value = defaults.carTaillightsColor;
							carTaillightsValue.textContent = defaults.carTaillightsColor.toUpperCase();
							carTaillightsColor = defaults.carTaillightsColor;

							carTirePicker.value = defaults.carTireColor;
							carTireValue.textContent = defaults.carTireColor.toUpperCase();
							carTireColor = defaults.carTireColor;

							carTrimPicker.value = defaults.carTrimColor;
							carTrimValue.textContent = defaults.carTrimColor.toUpperCase();
							carTrimColor = defaults.carTrimColor;

							// Update globals
							window.speakerCabColor = defaults.speakerCabColor;
							window.speakerTrimColor = defaults.speakerTrimColor;
							window.speakerFaceColor = defaults.speakerFaceColor;
							window.speakerFrameColor = defaults.speakerFrameColor;
							window.computerChassisColor = defaults.computerChassisColor;
							window.computerKeyboardColor = defaults.computerKeyboardColor;
							window.computerFeaturesColor = defaults.computerFeaturesColor;
							window.carDoorColor = defaults.carDoorColor;
							window.carFrameColor = defaults.carFrameColor;
							window.carHeadlightsColor = defaults.carHeadlightsColor;
							window.carHoodColor = defaults.carHoodColor;
							window.carInteriorColor = defaults.carInteriorColor;
							window.carRimColor = defaults.carRimColor;
							window.carSteeringColor = defaults.carSteeringColor;
							window.carTaillightsColor = defaults.carTaillightsColor;
							window.carTireColor = defaults.carTireColor;
							window.carTrimColor = defaults.carTrimColor;

							// Apply to character
							updateCharacter();

							// Apply to floor
							if (window.groundMesh && window.generateGridTexture) {
								window.generateGridTexture(defaults.floorGlowColor, defaults.floorPanelColor);
								window.groundMesh.material.emissive.set(defaults.floorGlowColor);
								window.groundMesh.material.color.set(defaults.floorPanelColor);
								window.groundMesh.material.needsUpdate = true;
							}

							// Apply to speakers
							if (window.speakers) {
								window.speakers.traverse((child) => {
									if (child.isMesh && child.material) {
										const matName = child.material.name;
										if (matName === 'CAB' || matName.toLowerCase().includes('cab')) {
											child.material.color.set(defaults.speakerCabColor);
										} else if (matName === 'TRIM' || matName === 'SPEAKER_TRIM' || (matName.toLowerCase().includes('trim') && matName.toLowerCase().includes('speaker'))) {
											child.material.color.set(defaults.speakerTrimColor);
										} else if (matName === 'FACE' || matName.toLowerCase().includes('face')) {
											child.material.color.set(defaults.speakerFaceColor);
										} else if (matName === 'FRAME' || matName === 'SPEAKER_FRAME' || (matName.toLowerCase().includes('frame') && matName.toLowerCase().includes('speaker'))) {
											child.material.color.set(defaults.speakerFrameColor);
										}
										child.material.needsUpdate = true;
									}
								});
							}

							// Apply to computer
							if (window.computer) {
								window.computer.traverse((child) => {
									if (child.isMesh && child.material) {
										const matName = child.material.name;
										if (matName === 'CHASIS' || matName.toLowerCase().includes('chasis')) {
											child.material.color.set(defaults.computerChassisColor);
										} else if (matName === 'KEYBOARD' || matName.toLowerCase().includes('keyboard')) {
											child.material.color.set(defaults.computerKeyboardColor);
										} else if (matName === 'FEATURES' || matName.toLowerCase().includes('features')) {
											child.material.color.set(defaults.computerFeaturesColor);
										}
										child.material.needsUpdate = true;
									}
								});
							}

							// Apply to car
							if (window.car) {
								window.car.traverse((child) => {
									if (child.isMesh && child.material) {
										const matName = child.material.name;
										if (matName === 'DOOR' || matName.toLowerCase().includes('door')) {
											child.material.color.set(defaults.carDoorColor);
										} else if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
											child.material.color.set(defaults.carFrameColor);
										} else if (matName === 'HEADLIGHTS' || matName.toLowerCase().includes('headlight')) {
											child.material.color.set(defaults.carHeadlightsColor);
										} else if (matName === 'HOOD' || matName.toLowerCase().includes('hood')) {
											child.material.color.set(defaults.carHoodColor);
										} else if (matName === 'INTERIOR' || matName.toLowerCase().includes('interior')) {
											child.material.color.set(defaults.carInteriorColor);
										} else if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
											child.material.color.set(defaults.carRimColor);
										} else if (matName === 'STEERING' || matName.toLowerCase().includes('steering')) {
											child.material.color.set(defaults.carSteeringColor);
										} else if (matName === 'TAILLIGHTS' || matName.toLowerCase().includes('taillight')) {
											child.material.color.set(defaults.carTaillightsColor);
										} else if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
											child.material.color.set(defaults.carTireColor);
										} else if (matName === 'TRIM' || matName.toLowerCase().includes('trim')) {
											child.material.color.set(defaults.carTrimColor);
										}
										child.material.needsUpdate = true;
									}
								});
								if (window.car.wheels) {
									window.car.wheels.forEach((wheel) => {
										wheel.wheelObject.traverse((child) => {
											if (child.isMesh && child.material) {
												const matName = child.material.name;
												if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
													child.material.color.set(defaults.carRimColor);
												} else if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
													child.material.color.set(defaults.carTireColor);
												}
												child.material.needsUpdate = true;
											}
										});
									});
								}
							}

							saveCustomization();
							console.log('✅ Reset to defaults complete!');
						}
					});
				}, 1000);
			});

			// Create OS system
			const osDiv = document.createElement('div');
			osDiv.className = 'terminal-login';
			osDiv.innerHTML = `
				<div class="os-container">
					<!-- OS Taskbar -->
					<div class="os-taskbar">
						<div class="os-logo">SUBLAIR OS v1.0</div>
						<div class="os-taskbar-apps">
							<div class="taskbar-app active" data-app="desktop">
								[DESKTOP]
							</div>
							<div class="taskbar-app" data-app="music">
								[MUSIC]
							</div>
							<div class="taskbar-app" data-app="eq">
								[EQ]
							</div>
							<div class="taskbar-app" data-app="chat">
								[CHAT]
							</div>
						</div>
						<button class="desktop-profile-btn" id="profile-btn">
							<span id="profile-status">GUEST</span>
						</button>
						<div class="os-close" id="os-close">[X]</div>
					</div>

					<!-- Desktop View -->
					<div class="os-view" id="desktop-view">
						<div class="desktop-split">

							<div class="desktop-icons">
								<div class="desktop-icon" data-app="music">
									<div class="icon">[S]</div>
									<div class="label">SUBLAIR.EXE</div>
								</div>
								<div class="desktop-icon" data-app="eq">
									<div class="icon">[E]</div>
									<div class="label">EQ.EXE</div>
								</div>
								<div class="desktop-icon" data-app="chat">
									<div class="icon">[C]</div>
									<div class="label">CHAT.EXE</div>
								</div>
							</div>
							<div class="desktop-audio-player">
								<div class="audio-player-header">♪ MEDIA PLAYER</div>
								<div class="audio-player-body">
									<div class="audio-album-art-container">
										<div id="desktop-album-art">NO ARTWORK</div>
									</div>
									<div class="audio-info-controls">
										<div id="desktop-audio-status" class="audio-status">NO TRACK LOADED</div>
										<div id="desktop-audio-controls" class="audio-controls">
											<button id="audio-play-pause" class="audio-btn" disabled>▶ PLAY</button>
											<button id="audio-stop" class="audio-btn" disabled>■ STOP</button>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>

					<!-- Music Player App -->
					<div class="os-view" id="music-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">MUSIC PLAYER v1.0</div>
								<input type="text" id="search-input" placeholder="Search tracks..." />
							</div>
							<div class="app-content">
								<div id="tracks-container">
									<div style="text-align: center; color: #bee17b; padding: 20px;">Loading tracks...</div>
								</div>
							</div>
						</div>
					</div>

					<!-- EQ App -->
					<div class="os-view" id="eq-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">EQUALIZER v1.0</div>
							</div>
							<div class="app-content">
								<!-- Visualizer -->
								<div style="background: #000; border: 2px solid #bee17b; padding: 15px; margin-bottom: 10px;">
									<div style="color: #bee17b; font-weight: bold; margin-bottom: 10px; font-size: 14px;">[FREQUENCY ANALYZER]</div>
									<canvas id="eq-visualizer" width="800" height="120" style="width: 100%; height: 120px; background: #000; border: 1px solid #bee17b;"></canvas>

									<!-- dB Meter -->
									<div style="margin-top: 15px;">
										<div style="color: #bee17b; font-weight: bold; margin-bottom: 8px; font-size: 12px; display: flex; justify-content: space-between; align-items: center;">
											<span>[dB METER]</span>
											<span id="clip-indicator" style="color: #ff0000; font-weight: bold; opacity: 0; transition: opacity 0.1s;">CLIP</span>
										</div>
										<canvas id="db-meter" width="800" height="40" style="width: 100%; height: 40px; background: #000; border: 1px solid #bee17b;"></canvas>
									</div>

									<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px; font-size: 12px;">
										<div style="color: #bee17b;">PEAK: <span id="peak-db">-∞ dB</span></div>
										<div style="color: #bee17b;">RMS: <span id="rms-db">-∞ dB</span></div>
										<div style="color: #bee17b;">LUFS: <span id="lufs-value">-∞ LUFS</span></div>
										<div style="color: #bee17b;">PEAK LUFS: <span id="peak-lufs">-∞ LUFS</span></div>
									</div>
									<button id="reset-peak-lufs" class="audio-btn" style="margin-top: 10px; width: 100%;">[RESET PEAK]</button>
								</div>

								<!-- 3-Band EQ -->
								<div style="background: #000; border: 2px solid #bee17b; padding: 15px; margin-bottom: 10px;">
									<div style="color: #bee17b; font-weight: bold; margin-bottom: 10px; font-size: 14px;">[3-BAND EQUALIZER]</div>
									<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">LOW</label>
											<input type="range" id="eq-low" min="-12" max="12" value="0" step="0.5" style="width: 100%;" />
											<div id="eq-low-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">0 dB</div>
										</div>
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">MID</label>
											<input type="range" id="eq-mid" min="-12" max="12" value="0" step="0.5" style="width: 100%;" />
											<div id="eq-mid-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">0 dB</div>
										</div>
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">HIGH</label>
											<input type="range" id="eq-high" min="-12" max="12" value="0" step="0.5" style="width: 100%;" />
											<div id="eq-high-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">0 dB</div>
										</div>
									</div>
								</div>

								<!-- Filters -->
								<div style="background: #000; border: 2px solid #bee17b; padding: 15px; margin-bottom: 10px;">
									<div style="color: #bee17b; font-weight: bold; margin-bottom: 10px; font-size: 14px;">[FILTERS]</div>
									<div style="margin-bottom: 15px;">
										<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">MASTER VOLUME</label>
										<input type="range" id="master-volume" min="0" max="100" value="100" step="1" style="width: 100%;" />
										<div id="master-volume-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">100%</div>
									</div>
									<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">LOW PASS</label>
											<input type="range" id="filter-lowpass" min="20" max="20000" value="20000" step="10" style="width: 100%;" />
											<div id="filter-lowpass-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">20000 Hz</div>
										</div>
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">HIGH PASS</label>
											<input type="range" id="filter-highpass" min="20" max="20000" value="20" step="10" style="width: 100%;" />
											<div id="filter-highpass-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">20 Hz</div>
										</div>
									</div>
								</div>

								<button id="eq-reset" class="audio-btn" style="width: 100%;">[RESET ALL]</button>
							</div>
						</div>
					</div>

					<!-- Text Reader App -->
					<div class="os-view" id="text-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">TEXT READER v1.0</div>
								<div class="file-path" id="text-file-name">UNTITLED.TXT</div>
								<button id="text-close" class="audio-btn" style="margin-left: auto; width: auto;">[CLOSE]</button>
							</div>
							<div class="app-content">
								<div id="text-content" style="font-family: 'Share', 'Courier New', monospace; color: #bee17b; line-height: 1.6; white-space: pre-wrap; padding: 20px; background: #000;"></div>
							</div>
						</div>
					</div>

					<!-- Chat View -->
					<div class="os-view" id="chat-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">CHAT.EXE v1.0</div>
								<div class="file-path">SUBLAIR GLOBAL CHAT</div>
							</div>
							<div class="app-content" style="display: flex; flex-direction: row; height: 100%;">
								<!-- Messages Area -->
								<div style="flex: 1; display: flex; flex-direction: column;">
									<div id="chat-messages" style="flex: 1; overflow-y: auto; padding: 20px; background: #000; font-family: 'Share', monospace; color: #bee17b; font-size: 14px;">
										<div style="color: #666; text-align: center; padding: 20px;">
											[CONNECTING TO CHAT SERVER...]
										</div>
									</div>
									<div style="padding: 15px; background: #111; border-top: 1px solid #bee17b; display: flex; gap: 10px;">
										<input type="text" id="chat-input" placeholder="Type message..." style="flex: 1; padding: 10px; background: #000; border: 1px solid #bee17b; color: #bee17b; font-family: 'Share', monospace; font-size: 14px;" />
										<button id="chat-send" class="audio-btn" style="width: auto; padding: 10px 20px;">[SEND]</button>
									</div>
								</div>
								<!-- Online Users Sidebar -->
								<div style="width: 250px; border-left: 1px solid #bee17b; background: #000; display: flex; flex-direction: column;">
									<div style="padding: 15px; border-bottom: 1px solid #bee17b; font-family: 'Share', monospace; color: #bee17b; font-weight: bold; font-size: 14px;">
										ONLINE USERS (<span id="online-count">0</span>)
									</div>
									<div id="online-users" style="flex: 1; overflow-y: auto; padding: 10px; font-family: 'Share', monospace; font-size: 13px;">
										<div style="color: #666; text-align: center; padding: 20px;">
											[LOADING...]
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>

					<!-- Login Modal -->
					<div class="login-modal-overlay" id="login-modal">
						<div class="login-modal-box">
							<div class="login-modal-header">
								<span>SUBLAIR LOGIN</span>
								<button class="login-modal-close" id="login-modal-close">[X]</button>
							</div>
							<div class="login-modal-body">
								<form id="login-form">
									<div class="login-form-group">
										<label>EMAIL</label>
										<input type="email" id="login-email" placeholder="user@sublair.com" required />
									</div>
									<div class="login-form-group">
										<label>PASSWORD</label>
										<input type="password" id="login-password" placeholder="••••••••" required />
									</div>
									<div class="login-error" id="login-error">Invalid credentials</div>
									<button type="submit" class="login-submit-btn">LOGIN</button>
								</form>
							</div>
						</div>
					</div>
				</div>
			`;
			document.body.appendChild(osDiv);

			// ========================================
			// AUDIO VISUALIZER SETUP (after OS is added to DOM)
			// ========================================

			// Initialize visualizer after a short delay to ensure elements exist
			setTimeout(() => {
				const canvas = document.getElementById('eq-visualizer');
				if (!canvas) return;

				const canvasCtx = canvas.getContext('2d');
				const bufferLength = window.audioAnalyser.frequencyBinCount;
				const dataArray = new Uint8Array(bufferLength);
				const timeDataArray = new Uint8Array(bufferLength);

				// dB Meter setup
				const dbMeterCanvas = document.getElementById('db-meter');
				const dbMeterCtx = dbMeterCanvas ? dbMeterCanvas.getContext('2d') : null;
				const clipIndicator = document.getElementById('clip-indicator');
				let peakHold = -Infinity;
				let peakHoldTime = 0;
				let clipDetected = false;
				let clipHoldTime = 0;

				// Track peak LUFS
				let peakLUFS = -Infinity;

				function calculateLUFS(rmsValue) {
					// Simplified LUFS calculation (ITU-R BS.1770)
					const dbFS = 20 * Math.log10(rmsValue);
					return dbFS + 0.691; // Rough conversion to LUFS
				}

				// Reset peak LUFS button
				const resetPeakBtn = document.getElementById('reset-peak-lufs');
				if (resetPeakBtn) {
					resetPeakBtn.addEventListener('click', () => {
						peakLUFS = -Infinity;
						const peakLufsEl = document.getElementById('peak-lufs');
						if (peakLufsEl) peakLufsEl.textContent = '-∞ LUFS';
					});
				}

				function drawVisualizer() {
					requestAnimationFrame(drawVisualizer);

					if (!positionalAudio.isPlaying) {
						// Clear when not playing
						canvasCtx.fillStyle = '#000';
						canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
						return;
					}

					window.audioAnalyser.getByteTimeDomainData(timeDataArray);
					window.audioAnalyser.getByteFrequencyData(dataArray);

					// Calculate Peak and RMS properly
					let peak = 0;
					let sumSquares = 0;

					// Use byte time domain data and convert properly
					// Byte range is 0-255, center is at 128
					// Convert to -1 to +1 range
					for (let i = 0; i < bufferLength; i++) {
						const normalized = (timeDataArray[i] - 128) / 128.0;
						const abs = Math.abs(normalized);
						if (abs > peak) peak = abs;
						sumSquares += normalized * normalized;
					}

					const rms = Math.sqrt(sumSquares / bufferLength);

					// Calculate true dBFS
					const peakDB = peak > 0.0000001 ? 20 * Math.log10(peak) : -Infinity;
					const rmsDB = rms > 0.0000001 ? 20 * Math.log10(rms) : -Infinity;
					const lufs = calculateLUFS(rms);

					// Track peak LUFS
					if (isFinite(lufs) && lufs > peakLUFS) {
						peakLUFS = lufs;
					}

					// Update meters
					const peakEl = document.getElementById('peak-db');
					const rmsEl = document.getElementById('rms-db');
					const lufsEl = document.getElementById('lufs-value');
					const peakLufsEl = document.getElementById('peak-lufs');

					if (peakEl) peakEl.textContent = isFinite(peakDB) ? peakDB.toFixed(1) + ' dB' : '-∞ dB';
					if (rmsEl) rmsEl.textContent = isFinite(rmsDB) ? rmsDB.toFixed(1) + ' dB' : '-∞ dB';
					if (lufsEl) lufsEl.textContent = isFinite(lufs) ? lufs.toFixed(1) + ' LUFS' : '-∞ LUFS';
					if (peakLufsEl) peakLufsEl.textContent = isFinite(peakLUFS) ? peakLUFS.toFixed(1) + ' LUFS' : '-∞ LUFS';

					// Draw frequency spectrum (20Hz - 20kHz)
					canvasCtx.fillStyle = '#000';
					canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

					// Draw frequency bars
					const barWidth = (canvas.width / bufferLength) * 2.5;
					let x = 0;

					for (let i = 0; i < bufferLength; i++) {
						const barHeight = (dataArray[i] / 255) * canvas.height;

						// Color gradient based on frequency
						const hue = (i / bufferLength) * 60; // 0-60 = green range
						canvasCtx.fillStyle = `hsl(${80 + hue}, 70%, 50%)`;

						// Use green for consistency
						canvasCtx.fillStyle = '#bee17b';

						canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
						x += barWidth + 1;
					}

					// Draw frequency labels
					canvasCtx.fillStyle = '#bee17b';
					canvasCtx.font = '10px Share';
					canvasCtx.fillText('20Hz', 5, 15);
					canvasCtx.fillText('1kHz', canvas.width / 2 - 15, 15);
					canvasCtx.fillText('20kHz', canvas.width - 40, 15);

					// Draw grid lines
					canvasCtx.strokeStyle = '#bee17b22';
					canvasCtx.lineWidth = 1;
					for (let i = 0; i < 4; i++) {
						const y = (canvas.height / 4) * i;
						canvasCtx.beginPath();
						canvasCtx.moveTo(0, y);
						canvasCtx.lineTo(canvas.width, y);
						canvasCtx.stroke();
					}

					// ========================================
					// DRAW dB METER
					// ========================================
					if (dbMeterCtx) {
						// Clear meter
						dbMeterCtx.fillStyle = '#000';
						dbMeterCtx.fillRect(0, 0, dbMeterCanvas.width, dbMeterCanvas.height);

						if (positionalAudio.isPlaying) {
							// Map peakDB from -48dB to +6dB for better resolution
							const dbMin = -48;
							const dbMax = 6; // Allow +6dB headroom to show clipping
							let normalizedPeak = (peakDB - dbMin) / (dbMax - dbMin);
							normalizedPeak = Math.max(0, Math.min(1, normalizedPeak));

							// Update peak hold
							const currentTime = Date.now();
							if (peakDB > peakHold) {
								peakHold = peakDB;
								peakHoldTime = currentTime;
							} else if (currentTime - peakHoldTime > 1500) {
								// Decay peak hold after 1.5 seconds
								peakHold = Math.max(peakDB, peakHold - 0.5);
							}

							// Check for clipping (above -1dB or peak >= 0.95 is clipping)
							// In digital audio, 0 dBFS is the absolute maximum
							if (peakDB > -1.0) {
								clipDetected = true;
								clipHoldTime = currentTime;
							}

							// Hide clip indicator after 2 seconds
							if (currentTime - clipHoldTime > 2000) {
								clipDetected = false;
							}

							// Update clip indicator
							if (clipIndicator) {
								clipIndicator.style.opacity = clipDetected ? '1' : '0';
							}

							// Draw segmented meter bars (classic VU meter style)
							const padding = 4;
							const meterHeight = dbMeterCanvas.height - (padding * 2);
							const meterWidth = dbMeterCanvas.width - (padding * 2);
							const segmentCount = 60;
							const segmentWidth = (meterWidth / segmentCount) - 2;

							for (let i = 0; i < segmentCount; i++) {
								const segmentLevel = i / segmentCount;
								const segmentDB = dbMin + (segmentLevel * (dbMax - dbMin));
								const x = padding + (i * (segmentWidth + 2));

								// Determine segment color based on actual dB level
								let color;
								if (segmentDB < -12) {
									// Green zone (-48dB to -12dB)
									color = '#00ff00';
								} else if (segmentDB < -3) {
									// Yellow zone (-12dB to -3dB)
									color = '#ffff00';
								} else if (segmentDB < 0) {
									// Orange zone (-3dB to 0dB)
									color = '#ff9900';
								} else {
									// Red zone (0dB to +6dB) - CLIPPING!
									color = '#ff0000';
								}

								// Draw segment if below peak level
								if (segmentLevel <= normalizedPeak) {
									dbMeterCtx.fillStyle = color;
									dbMeterCtx.fillRect(x, padding, segmentWidth, meterHeight);
								} else {
									// Draw dim background segments
									dbMeterCtx.fillStyle = '#1a1a1a';
									dbMeterCtx.fillRect(x, padding, segmentWidth, meterHeight);
								}
							}

							// Draw peak hold indicator
							if (isFinite(peakHold) && peakHold > dbMin) {
								const peakNormalized = Math.max(0, Math.min(1, (peakHold - dbMin) / (dbMax - dbMin)));
								const peakX = padding + (peakNormalized * meterWidth);
								dbMeterCtx.fillStyle = '#ffffff';
								dbMeterCtx.fillRect(peakX - 1, padding, 2, meterHeight);
							}

							// Draw dB scale labels with better positioning
							dbMeterCtx.fillStyle = '#bee17b';
							dbMeterCtx.font = '9px Share';

							// Calculate positions based on actual dB values
							const labelPositions = [
								{ db: -48, label: '-48' },
								{ db: -24, label: '-24' },
								{ db: -12, label: '-12' },
								{ db: -6, label: '-6' },
								{ db: -3, label: '-3' },
								{ db: 0, label: '0' },
								{ db: 3, label: '+3' },
								{ db: 6, label: '+6' }
							];

							labelPositions.forEach(pos => {
								const normPos = (pos.db - dbMin) / (dbMax - dbMin);
								const xPos = padding + (normPos * meterWidth);
								dbMeterCtx.fillText(pos.label, xPos - 8, 12);
							});
						}
					}
				}

				// Start visualizer
				drawVisualizer();
			}, 100);

			// ========================================
			// SOUND ENGINE CLASS (will be initialized later)
			// ========================================

			class SoundEngine {
				constructor(listener) {
					this.listener = listener;
					this.sounds = {};
					this.audioLoader = new THREE.AudioLoader();
				}

				// Load a sound file
				loadSound(name, path, options = {}) {
					return new Promise((resolve, reject) => {
						this.audioLoader.load(path,
							(buffer) => {
								const sound = new THREE.Audio(this.listener);
								sound.setBuffer(buffer);
								sound.setVolume(options.volume || 1.0);
								sound.setLoop(options.loop || false);

								this.sounds[name] = {
									audio: sound,
									buffer: buffer,
									options: options
								};

								console.log(`Sound loaded: ${name}`);
								resolve(sound);
							},
							undefined,
							(error) => {
								console.error(`Error loading sound ${name}:`, error);
								reject(error);
							}
						);
					});
				}

				// Load multiple sounds
				async loadSounds(soundList) {
					const promises = soundList.map(({name, path, options}) =>
						this.loadSound(name, path, options)
					);
					return Promise.all(promises);
				}

				// Play a sound
				play(name, options = {}) {
					const sound = this.sounds[name];
					if (!sound) {
						console.warn(`Sound not found: ${name}`);
						return null;
					}

					// Debug: Log footstep plays
					const isFootstep = name.startsWith('footstep');
					if (isFootstep) {
						console.log(`🔊 Playing ${name}: volume=${options.volume}, isPlaying=${sound.audio.isPlaying}, contextState=${this.listener.context.state}`);
					}

					// If already playing and not allowing overlaps, stop first
					if (sound.audio.isPlaying && !options.allowOverlap) {
						sound.audio.stop();
					}

					// Create new instance for overlap
					if (options.allowOverlap && sound.audio.isPlaying) {
						const newSound = new THREE.Audio(this.listener);
						newSound.setBuffer(sound.buffer);
						newSound.setVolume(options.volume || sound.options.volume || 1.0);
						newSound.setLoop(false);

						// Set playback rate (pitch) if specified
						if (options.pitch !== undefined) {
							newSound.setPlaybackRate(options.pitch);
						}

						newSound.play();
						return newSound;
					}

					// Set volume if specified
					if (options.volume !== undefined) {
						sound.audio.setVolume(options.volume);
					}

					// Set playback rate (pitch) if specified
					if (options.pitch !== undefined) {
						sound.audio.setPlaybackRate(options.pitch);
					}

					try {
						sound.audio.play();
						if (isFootstep) {
							console.log(`✅ ${name} play() called successfully`);
						}
					} catch (err) {
						console.error(`❌ Error playing ${name}:`, err);
					}
					return sound.audio;
				}

				// Stop a sound
				stop(name) {
					const sound = this.sounds[name];
					if (sound && sound.audio.isPlaying) {
						sound.audio.stop();
					}
				}

				// Play random sound from array
				playRandom(names, options = {}) {
					const randomName = names[Math.floor(Math.random() * names.length)];
					return this.play(randomName, options);
				}

				// Check if sound is playing
				isPlaying(name) {
					const sound = this.sounds[name];
					return sound ? sound.audio.isPlaying : false;
				}
			}

			// Sound engine will be initialized after audioListener is created
			let soundEngine = null;
			let lastFootstepTime = 0;
			let lastFootstepSound = -1; // Track last played sound to avoid immediate repeats
			const footstepSounds = ['footstep1', 'footstep2', 'footstep3', 'footstep4', 'footstep5', 'footstep6', 'footstep7'];

			// Get random footstep sound (avoid playing same one twice in a row)
			function getRandomFootstep() {
				let randomIndex;
				do {
					randomIndex = Math.floor(Math.random() * footstepSounds.length);
				} while (randomIndex === lastFootstepSound && footstepSounds.length > 1);

				lastFootstepSound = randomIndex;
				return footstepSounds[randomIndex];
			}

			// Check if character is in a walking/running state
			function isMovingState(character) {
				if (!character || !character.charState) return false;
				const stateName = character.charState.constructor.name;
				return stateName === 'Walk' || stateName === 'Sprint' ||
				       stateName === 'JumpRunning' || stateName === 'DropRunning';
			}

			// Get footstep interval based on character state
			function getFootstepInterval(character) {
				if (!character || !character.charState) return 500;

				const stateName = character.charState.constructor.name;
				const animationLength = character.charState.animationLength || 1.0;

				// 2 footsteps per animation cycle (left foot, right foot)
				let baseInterval = (animationLength / 2) * 1000; // Convert to milliseconds

				// Adjust based on state
				if (stateName === 'Sprint') {
					baseInterval *= 0.85; // Sprint is faster
				} else if (stateName === 'Walk') {
					baseInterval *= 1.0; // Normal walk
				} else if (stateName === 'JumpRunning' || stateName === 'DropRunning') {
					baseInterval *= 0.9; // Slightly faster
				}

				// Clamp to reasonable values
				return Math.max(200, Math.min(600, baseInterval));
			}

			// OS Navigation System
			function switchToApp(appName) {
				// Hide all views
				document.querySelectorAll('.os-view').forEach(view => {
					view.style.display = 'none';
				});

				// Show selected view
				document.getElementById(`${appName}-view`).style.display = 'block';

				// Update taskbar active states
				document.querySelectorAll('.taskbar-app').forEach(app => {
					app.classList.remove('active');
				});
				document.querySelector(`.taskbar-app[data-app="${appName}"]`).classList.add('active');
			}

			// Taskbar app click handlers
			document.querySelectorAll('.taskbar-app').forEach(app => {
				app.addEventListener('click', function() {
					const appName = this.getAttribute('data-app');
					switchToApp(appName);
				});
			});

			// Desktop icon click handlers
			document.querySelectorAll('.desktop-icon').forEach(icon => {
				icon.addEventListener('click', function() {
					const appName = this.getAttribute('data-app');
					switchToApp(appName);
				});
			});

			// Function to close OS
			function closeOS() {
				osDiv.classList.remove('active');
				window.terminalOpen = terminalOpen = false;
				character.takeControl();
				setTimeout(() => {
					world.renderer.domElement.requestPointerLock();

					// Resume AudioContext on first user interaction (fixes browser autoplay policy)
					if (audioListener && audioListener.context.state === 'suspended') {
						audioListener.context.resume().then(() => {
							console.log('🔊 AudioContext resumed for footsteps');
						});
					}
				}, 100);
			}

			// OS close button
			document.getElementById('os-close').addEventListener('click', closeOS);

			// Close OS when clicking outside the OS container
			const osContainer = document.querySelector('.os-container');
			document.addEventListener('click', (e) => {
				if (terminalOpen && !customizationOpen) {
					// Check if click is outside the OS container
					if (!osContainer.contains(e.target)) {
						closeOS();
					}
				}
			}, true);

			// Text Reader functionality
			function openTextReader(fileName, content) {
				document.getElementById('text-file-name').textContent = fileName;
				document.getElementById('text-content').textContent = content;
				switchToApp('text');
			}

			// Chat System
			const chatMessages = document.getElementById('chat-messages');
			const chatInput = document.getElementById('chat-input');
			const chatSend = document.getElementById('chat-send');
			const onlineUsers = document.getElementById('online-users');
			const onlineCount = document.getElementById('online-count');
			let lastMessageTimestamp = null;
			let chatPollInterval = null;
			let presencePollInterval = null;

			function addChatMessage(username, message, timestamp, photoURL, messageId, uid) {
				const messageDiv = document.createElement('div');
				messageDiv.style.marginBottom = '10px';
				messageDiv.style.display = 'flex';
				messageDiv.style.alignItems = 'center';
				messageDiv.style.justifyContent = 'space-between';
				const time = new Date(timestamp).toLocaleTimeString();

				const isMyMessage = window.authState?.uid === uid;

				messageDiv.innerHTML = `
					<div style="flex: 1;">
						<span style="color: #666;">[${time}]</span>
						<span style="color: #bee17b; font-weight: bold;">${username}:</span>
						<span style="color: #fff;">${message}</span>
					</div>
					${isMyMessage ? `<button class="delete-msg-btn" data-msg-id="${messageId}" style="padding: 4px 10px; background: #000; color: #f00; border: 1px solid #f00; cursor: pointer; font-family: 'Share', monospace; font-size: 12px; margin-left: 10px; transition: all 0.2s;">[DELETE]</button>` : ''}
				`;

				chatMessages.appendChild(messageDiv);

				// Add delete handler if it's the user's message
				if (isMyMessage && messageId) {
					const deleteBtn = messageDiv.querySelector('.delete-msg-btn');
					deleteBtn.addEventListener('click', () => deleteMessage(messageId, messageDiv));
				}

				chatMessages.scrollTop = chatMessages.scrollHeight;
			}

			async function deleteMessage(messageId, messageDiv) {
				if (!confirm('Delete this message?')) return;

				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/chat/messages/${messageId}`, {
						method: 'DELETE',
						headers: {
							'Content-Type': 'application/json',
							'Authorization': `Bearer ${window.authState.idToken}`
						}
					});

					const result = await response.json();

					if (result.success) {
						messageDiv.remove();
					} else {
						alert('Failed to delete message');
					}
				} catch (error) {
					console.error('Error deleting message:', error);
					alert('Failed to delete message');
				}
			}

			async function loadChatMessages() {
				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/chat/messages?limit=50`);
					const result = await response.json();

					if (result.success && result.data.length > 0) {
						chatMessages.innerHTML = '';
						result.data.forEach(msg => {
							addChatMessage(msg.username, msg.text, msg.createdAt, msg.photoURL, msg.id, msg.uid);
							lastMessageTimestamp = msg.createdAt;
						});
					} else {
						chatMessages.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">[NO MESSAGES YET]</div>';
					}
				} catch (error) {
					console.error('Error loading messages:', error);
					chatMessages.innerHTML = '<div style="color: #f00; text-align: center; padding: 20px;">[ERROR LOADING MESSAGES]</div>';
				}
			}

			async function pollNewMessages() {
				if (!lastMessageTimestamp) return;

				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/chat/messages?limit=10`);
					const result = await response.json();

					if (result.success && result.data.length > 0) {
						result.data.forEach(msg => {
							if (msg.createdAt > lastMessageTimestamp) {
								addChatMessage(msg.username, msg.text, msg.createdAt, msg.photoURL, msg.id, msg.uid);
								lastMessageTimestamp = msg.createdAt;
							}
						});
					}
				} catch (error) {
					console.error('Error polling messages:', error);
				}
			}

			async function sendChatMessage() {
				const message = chatInput.value.trim();
				if (!message) return;

				if (!window.authState?.isLoggedIn) {
					alert('You must be logged in to send messages');
					return;
				}

				if (message.length > 500) {
					alert('Message too long (max 500 characters)');
					return;
				}

				try {
					chatSend.disabled = true;
					chatSend.textContent = '[SENDING...]';

					const username = window.authState.user?.username ||
									 window.authState.user?.displayName ||
									 window.authState.email?.split('@')[0] ||
									 'USER';

					const response = await fetch(`${API_BASE_URL}/api/v1/chat/messages`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							text: message,
							idToken: window.authState.idToken
						})
					});

					const result = await response.json();

					if (!result.success) {
						throw new Error(result.error || 'Failed to send message');
					}

					// Clear placeholder if it exists
					const placeholder = chatMessages.querySelector('[style*="text-align: center"]');
					if (placeholder) {
						chatMessages.innerHTML = '';
					}

					// Immediately add message to UI
					addChatMessage(username, message, Date.now(), window.authState.user?.photoURL, result.data.id, window.authState.uid);
					lastMessageTimestamp = Date.now();

					chatInput.value = '';
				} catch (error) {
					console.error('Error sending message:', error);
					alert(error.message || 'Failed to send message');
				} finally {
					chatSend.disabled = false;
					chatSend.textContent = '[SEND]';
				}
			}

			async function updatePresence() {
				if (!window.authState?.isLoggedIn) return;

				try {
					await fetch(`${API_BASE_URL}/api/v1/chat/presence`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							idToken: window.authState.idToken,
							status: 'online'
						})
					});
				} catch (error) {
					console.error('Error updating presence:', error);
				}
			}

			async function loadOnlineUsers() {
				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/chat/presence`);
					const result = await response.json();

					if (result.success) {
						onlineCount.textContent = result.data.length;

						if (result.data.length === 0) {
							onlineUsers.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">[NO USERS ONLINE]</div>';
						} else {
							onlineUsers.innerHTML = result.data.map(user => {
								return `<div style="padding: 8px; border-bottom: 1px solid #222; color: #bee17b;">${user.username}</div>`;
							}).join('');
						}
					}
				} catch (error) {
					console.error('Error loading online users:', error);
				}
			}

			function startChatPolling() {
				if (chatPollInterval) return;

				loadChatMessages();
				loadOnlineUsers();

				if (window.authState?.isLoggedIn) {
					updatePresence();
				}

				chatPollInterval = setInterval(pollNewMessages, 2000);
				presencePollInterval = setInterval(() => {
					loadOnlineUsers();
					if (window.authState?.isLoggedIn) {
						updatePresence();
					}
				}, 10000);
			}

			function stopChatPolling() {
				if (chatPollInterval) {
					clearInterval(chatPollInterval);
					chatPollInterval = null;
				}
				if (presencePollInterval) {
					clearInterval(presencePollInterval);
					presencePollInterval = null;
				}
			}

			chatSend.addEventListener('click', sendChatMessage);
			chatInput.addEventListener('keypress', (e) => {
				if (e.key === 'Enter') {
					sendChatMessage();
				}
			});

			// Start polling when chat view opens
			const originalSwitchToApp = switchToApp;
			switchToApp = function(appName) {
				originalSwitchToApp(appName);
				if (appName === 'chat') {
					startChatPolling();
				} else {
					stopChatPolling();
				}
			};

			// Text reader close button
			document.getElementById('text-close').addEventListener('click', () => {
				switchToApp('files');
			});

			// Login Modal Handlers
			const loginModal = document.getElementById('login-modal');
			const profileBtn = document.getElementById('profile-btn');
			const loginModalClose = document.getElementById('login-modal-close');
			const loginForm = document.getElementById('login-form');
			const loginError = document.getElementById('login-error');

			// Close login modal
			loginModalClose.addEventListener('click', () => {
				loginModal.classList.remove('show');
				loginError.classList.remove('show');
			});

			// Close when clicking outside
			loginModal.addEventListener('click', (e) => {
				if (e.target === loginModal) {
					loginModal.classList.remove('show');
					loginError.classList.remove('show');
				}
			});

			// Global auth state
			window.authState = {
				isLoggedIn: false,
				user: null,
				idToken: null,
				refreshToken: null
			};

			// Save auth to localStorage
			function saveAuth(authData) {
				localStorage.setItem('sublair_auth', JSON.stringify(authData));
				window.authState = authData;
			}

			// Load auth from localStorage and verify/refresh token
			async function loadAuth() {
				const saved = localStorage.getItem('sublair_auth');
				if (!saved) {
					console.log('No saved auth found');
					return false;
				}

				try {
					const authData = JSON.parse(saved);
					window.authState = authData;

					// Check if token is expired or about to expire (within 5 minutes)
					const tokenAge = Date.now() - (authData.loginTime || 0);
					const tokenLifetime = parseInt(authData.expiresIn) * 1000; // Convert to ms
					const timeUntilExpiry = tokenLifetime - tokenAge;

					console.log('Token age:', Math.floor(tokenAge / 1000 / 60), 'minutes');
					console.log('Time until expiry:', Math.floor(timeUntilExpiry / 1000 / 60), 'minutes');

					// If token expires in less than 5 minutes or already expired, refresh it
					if (timeUntilExpiry < 5 * 60 * 1000) {
						console.log('Token expired or expiring soon, refreshing...');
						await refreshAuthToken();
					} else {
						console.log('Token still valid, user auto-logged in');
						updateUIForAuth();
					}

					return true;
				} catch (error) {
					console.error('Error loading auth:', error);
					clearAuth();
					return false;
				}
			}

			// Refresh authentication token
			async function refreshAuthToken() {
				if (!window.authState.refreshToken) {
					console.error('No refresh token available');
					clearAuth();
					return false;
				}

				try {
					console.log('Refreshing auth token...');
					const response = await fetch(`${API_BASE_URL}/api/v1/auth/refresh`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							refreshToken: window.authState.refreshToken
						})
					});

					const result = await response.json();

					if (!response.ok || !result.success) {
						throw new Error(result.error || 'Token refresh failed');
					}

					// Update tokens
					window.authState.idToken = result.data.idToken;
					window.authState.refreshToken = result.data.refreshToken;
					window.authState.expiresIn = result.data.expiresIn;
					window.authState.loginTime = Date.now();

					// Save updated auth
					saveAuth(window.authState);
					updateUIForAuth();

					console.log('Token refreshed successfully');
					return true;

				} catch (error) {
					console.error('Token refresh failed:', error);
					clearAuth();
					return false;
				}
			}

			// Start automatic token refresh timer
			function startTokenRefreshTimer() {
				// Refresh token every 50 minutes (tokens typically last 1 hour)
				setInterval(async () => {
					if (window.authState.isLoggedIn) {
						console.log('Auto-refreshing token...');
						await refreshAuthToken();
					}
				}, 50 * 60 * 1000); // 50 minutes
			}

			// Clear auth
			function clearAuth() {
				localStorage.removeItem('sublair_auth');
				window.authState = {
					isLoggedIn: false,
					user: null,
					idToken: null,
					refreshToken: null
				};
				updateUIForAuth();
			}

			// Update UI based on auth state
			function updateUIForAuth() {
				const profileStatus = document.getElementById('profile-status');

				console.log('Updating auth UI - isLoggedIn:', window.authState.isLoggedIn);
				console.log('Auth state:', window.authState);

				if (window.authState.isLoggedIn) {
					const username = window.authState.user?.username ||
									 window.authState.user?.displayName ||
									 window.authState.email?.split('@')[0] ||
									 'USER';
					console.log('Setting username to:', username.toUpperCase());
					profileStatus.textContent = username.toUpperCase();

					// Update computer screen with user's photoURL
					const photoURL = window.authState.user?.photoURL;
					if (photoURL && window.updateComputerScreen) {
						console.log('Updating computer screen with user photo:', photoURL);
						window.updateComputerScreen(photoURL);
					}

					// Update hat material with username text
					if (window.updateHatWithUsername) {
						window.updateHatWithUsername(username);
					}
				} else {
					console.log('Setting to GUEST');
					profileStatus.textContent = 'GUEST';
					// Clear computer screen when logged out
					if (window.updateComputerScreen) {
						window.updateComputerScreen(null);
					}
				}
			}

			// Logout function
			function logout() {
				clearAuth();
				console.log('User logged out');
			}

			// Handle profile button clicks
			profileBtn.addEventListener('click', () => {
				if (window.authState.isLoggedIn) {
					// User is logged in, show confirmation
					if (confirm('Do you want to logout?')) {
						logout();
					}
				} else {
					// User is not logged in, show login modal
					loginModal.classList.add('show');
				}
			});

			// Form submit
			loginForm.addEventListener('submit', async (e) => {
				e.preventDefault();
				const email = document.getElementById('login-email').value;
				const password = document.getElementById('login-password').value;

				loginError.classList.remove('show');
				const submitBtn = document.getElementById('login-form').querySelector('.login-submit-btn');
				submitBtn.textContent = 'LOGGING IN...';
				submitBtn.disabled = true;

				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/auth/login`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ email, password })
					});

					const result = await response.json();

					if (!response.ok || !result.success) {
						throw new Error(result.error || 'Login failed');
					}

					// Fetch full user profile from users endpoint
					const userProfileResponse = await fetch(`${API_BASE_URL}/api/v1/users/${result.data.localId}`);
					const userProfileResult = await userProfileResponse.json();

					if (!userProfileResponse.ok || !userProfileResult.success) {
						console.warn('Could not fetch full user profile, using minimal data');
					}

					// Save auth data with login timestamp and full user profile
					saveAuth({
						isLoggedIn: true,
						user: userProfileResult.success ? userProfileResult.data : result.data.user,
						email: result.data.email,
						uid: result.data.localId,
						idToken: result.data.idToken,
						refreshToken: result.data.refreshToken,
						expiresIn: result.data.expiresIn,
						loginTime: Date.now()
					});

					console.log('Login successful:', result.data.email);

					// Update UI
					updateUIForAuth();

					// Close modal
					loginModal.classList.remove('show');
					loginForm.reset();

				} catch (error) {
					console.error('Login error:', error);
					loginError.textContent = error.message || 'Login failed';
					loginError.classList.add('show');
				} finally {
					submitBtn.textContent = 'LOGIN';
					submitBtn.disabled = false;
				}
			});

			// ========================================
			// INITIALIZE AUTHENTICATION ON PAGE LOAD
			// ========================================
			setTimeout(async () => {
				console.log('Initializing authentication system...');
				await loadAuth();
				startTokenRefreshTimer();
				console.log('Authentication system initialized');
			}, 500);

			// Shuffle array function
			function shuffleArray(array) {
				const shuffled = [...array];
				for (let i = shuffled.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
				}
				return shuffled;
			}

			// API endpoint configuration
			const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
				? 'http://localhost:3000'
				: window.location.origin; // Use same domain as the app (Vercel)

			// Fetch tracks and users from API
			let tracksData = [];
			let usersData = {};
			let currentTrackIndex = -1;

			// Fetch both tracks and users
			Promise.all([
				fetch(`${API_BASE_URL}/api/v1/tracks`).then(r => r.json()),
				fetch(`${API_BASE_URL}/api/v1/users`).then(r => r.json())
			])
				.then(([tracksResult, usersResult]) => {
					if (tracksResult.success && tracksResult.data) {
						tracksData = tracksResult.data;
					} else {
						throw new Error('Failed to load tracks');
					}

					if (usersResult.success && usersResult.data) {
						usersData = usersResult.data;
					}

					// Merge user data into tracks
					tracksData = tracksData.map(track => {
						if (track.user_id && usersData[track.user_id]) {
							const user = usersData[track.user_id];
							return {
								...track,
								artistName: user.displayName || user.username || 'Unknown Artist',
								artistUsername: user.username || null
							};
						}
						return {
							...track,
							artistName: 'Unknown Artist',
							artistUsername: null
						};
					});

					// Shuffle the tracks for random order
					tracksData = shuffleArray(tracksData);
					displayTracks(tracksData);
				})
				.catch(error => {
					console.error('Error loading data from API:', error);
					document.getElementById('tracks-container').innerHTML = '<div style="text-align: center; color: #ff0000; padding: 20px;">Failed to load tracks. Make sure API server is running.</div>';
				});

			// Setup search
			document.getElementById('search-input').addEventListener('input', (e) => {
				const query = e.target.value.toLowerCase();
				const filtered = tracksData.filter(track =>
					(track.title && track.title.toLowerCase().includes(query)) ||
					(track.genre && track.genre.toLowerCase().includes(query)) ||
					(track.description && track.description.toLowerCase().includes(query)) ||
					(track.artistName && track.artistName.toLowerCase().includes(query))
				);
				displayTracks(filtered);
			});

			function displayTracks(tracks) {
				const container = document.getElementById('tracks-container');

				if (tracks.length === 0) {
					container.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No tracks found</div>';
					return;
				}

				container.innerHTML = tracks.map((track, index) => {
					const artistDisplay = track.artistUsername
						? `<a href="https://www.sublair.com/u/${track.artistUsername}" target="_blank" class="artist-link" onclick="event.stopPropagation();">${track.artistName}</a>`
						: (track.artistName || 'Unknown Artist');

					return `
						<div class="track-item" data-track-index="${index}" data-track-id="${track.id}" data-title="${track.title || 'UNKNOWN'}" data-artwork="${track.artwork_url || ''}">
							<div class="track-title">${track.title}</div>
							<div class="track-meta">${artistDisplay} • ${track.genre || 'Unknown'}</div>
						</div>
					`;
				}).join('');

				// Add click handlers to play tracks
			document.querySelectorAll('.track-item').forEach(item => {
				item.addEventListener('click', function() {
					const trackIndex = parseInt(this.getAttribute('data-track-index'));
					const trackId = this.getAttribute('data-track-id');
					const trackTitle = this.getAttribute('data-title');
					const artworkUrl = this.getAttribute('data-artwork');
					// Use API stream proxy instead of direct URL
					const streamUrl = `${API_BASE_URL}/api/v1/stream/${trackId}`;
					currentTrackIndex = trackIndex;
					playTrack(streamUrl, trackTitle, artworkUrl);
				});
			});
			}

			let currentTrack = null;
			let currentTrackTitle = '';
			let isAudioPaused = false;

			// Audio play/pause button
			document.getElementById('audio-play-pause').addEventListener('click', () => {
				if (!positionalAudio.buffer) return; // No track loaded

				if (positionalAudio.isPlaying) {
					// Pause
					positionalAudio.pause();
					isAudioPaused = true;
					document.getElementById('audio-play-pause').textContent = '▶ PLAY';
					document.getElementById('desktop-audio-status').textContent = 'PAUSED';
				} else {
					// Play/Resume
					positionalAudio.play();
					isAudioPaused = false;
					document.getElementById('audio-play-pause').textContent = '❚❚ PAUSE';
					document.getElementById('desktop-audio-status').textContent = `NOW PLAYING:\n${currentTrackTitle}`;
				}
			});

			// Audio stop button
			document.getElementById('audio-stop').addEventListener('click', () => {
				if (positionalAudio.buffer) {
					positionalAudio.stop();
					isAudioPaused = false;
					document.getElementById('desktop-audio-status').textContent = 'STOPPED';
					document.getElementById('audio-play-pause').textContent = '▶ PLAY';
					document.getElementById('audio-play-pause').disabled = true;
					document.getElementById('audio-stop').disabled = true;
				}
			});

			// EQ Controls
			document.getElementById('eq-low').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.low.gain.value = value;
				document.getElementById('eq-low-value').textContent = `${value > 0 ? '+' : ''}${value} dB`;
			});

			document.getElementById('eq-mid').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.mid.gain.value = value;
				document.getElementById('eq-mid-value').textContent = `${value > 0 ? '+' : ''}${value} dB`;
			});

			document.getElementById('eq-high').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.high.gain.value = value;
				document.getElementById('eq-high-value').textContent = `${value > 0 ? '+' : ''}${value} dB`;
			});

			document.getElementById('master-volume').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				if (window.eqFilters && window.eqFilters.masterGain) {
					window.eqFilters.masterGain.gain.value = value / 100;
				}
				document.getElementById('master-volume-value').textContent = `${value}%`;
			});

			document.getElementById('filter-lowpass').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.lowpass.frequency.value = value;
				document.getElementById('filter-lowpass-value').textContent = `${value} Hz`;
			});

			document.getElementById('filter-highpass').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.highpass.frequency.value = value;
				document.getElementById('filter-highpass-value').textContent = `${value} Hz`;
			});

			document.getElementById('eq-reset').addEventListener('click', () => {
				// Reset all EQ filters to 0
				window.eqFilters.low.gain.value = 0;
				window.eqFilters.mid.gain.value = 0;
				window.eqFilters.high.gain.value = 0;

				// Reset lowpass/highpass to defaults
				window.eqFilters.lowpass.frequency.value = 20000;
				window.eqFilters.highpass.frequency.value = 20;

				// Reset UI
				document.getElementById('eq-low').value = 0;
				document.getElementById('eq-mid').value = 0;
				document.getElementById('eq-high').value = 0;
				document.getElementById('eq-low-value').textContent = '0 dB';
				document.getElementById('eq-mid-value').textContent = '0 dB';
				document.getElementById('eq-high-value').textContent = '0 dB';

				document.getElementById('filter-lowpass').value = 20000;
				document.getElementById('filter-highpass').value = 20;
				document.getElementById('filter-lowpass-value').textContent = '20000 Hz';
				document.getElementById('filter-highpass-value').textContent = '20 Hz';
			});

			function playTrack(url, title, artworkUrl) {
				// Update desktop audio player
				document.getElementById('desktop-audio-status').textContent = 'LOADING...';
				document.getElementById('audio-play-pause').disabled = false;
				document.getElementById('audio-stop').disabled = false;
				currentTrackTitle = title || 'UNKNOWN TRACK';

				// Show loading indicator
				const loadingDiv = document.getElementById('audio-loading');
				loadingDiv.classList.add('show');
				loadingDiv.innerHTML = 'Loading audio... 0%';

				// Stop current track if playing
				if (positionalAudio.isPlaying) {
					positionalAudio.stop();
				}

				// Load and play new track
				const audioLoader = new THREE.AudioLoader();
				audioLoader.load(url, (buffer) => {
					positionalAudio.setBuffer(buffer);
					positionalAudio.setLoop(false);
					positionalAudio.setVolume(1.0);

					// Connect EQ filters chain: source -> directional bass -> directional lowpass -> vehicle lowpass -> lowpass -> highpass -> low -> mid -> high -> analyser -> destination
					const source = positionalAudio.getOutput();
					source.disconnect();
					source.connect(window.speakerDirectionalBass);
					window.speakerDirectionalBass.connect(window.speakerDirectionalLowpass);
					window.speakerDirectionalLowpass.connect(window.eqFilters.vehicleLowpass);
					window.eqFilters.vehicleLowpass.connect(window.eqFilters.lowpass);
					window.eqFilters.lowpass.connect(window.eqFilters.highpass);
					window.eqFilters.highpass.connect(window.eqFilters.low);
					window.eqFilters.low.connect(window.eqFilters.mid);
					window.eqFilters.mid.connect(window.eqFilters.high);
					window.eqFilters.high.connect(window.eqFilters.masterGain);
					window.eqFilters.masterGain.connect(window.audioAnalyser);
					window.audioAnalyser.connect(positionalAudio.context.destination);

					positionalAudio.play();
					currentTrack = url;

					// Auto-play next track when current one ends
					positionalAudio.onEnded = function() {
						console.log('🔄 Track ended, playing next...');
						playNextTrack();
					};

					// Update desktop audio player
					document.getElementById('desktop-audio-status').textContent = `NOW PLAYING:\n${currentTrackTitle}`;
					document.getElementById('audio-play-pause').textContent = '❚❚ PAUSE';
					document.getElementById('audio-play-pause').disabled = false;
					document.getElementById('audio-stop').disabled = false;
					isAudioPaused = false;

					// Update desktop album art
					const albumArtEl = document.getElementById('desktop-album-art');
					if (artworkUrl) {
						albumArtEl.style.backgroundImage = `url(${artworkUrl})`;
						albumArtEl.style.backgroundSize = 'cover';
						albumArtEl.style.backgroundPosition = 'center';
						albumArtEl.textContent = '';
					} else {
						albumArtEl.style.backgroundImage = 'none';
						albumArtEl.textContent = 'NO ARTWORK';
					}

					// Update computer screen with artwork
					if (window.updateComputerScreen) {
						window.updateComputerScreen(artworkUrl);
					}

					// Hide loading indicator and show success
					loadingDiv.innerHTML = 'NOW PLAYING';
					setTimeout(() => {
						loadingDiv.classList.remove('show');
					}, 2000);
				},
				(progress) => {
					const percent = (progress.loaded / progress.total * 100).toFixed(0);
					loadingDiv.innerHTML = `Loading audio... ${percent}%`;
					document.getElementById('desktop-audio-status').textContent = `LOADING... ${percent}%`;
					console.log('Loading audio:', percent + '%');
				},
				(error) => {
					console.error('Error loading audio:', error);
					loadingDiv.innerHTML = 'ERROR LOADING AUDIO';
					document.getElementById('desktop-audio-status').textContent = 'ERROR: FAILED TO LOAD';
					document.getElementById('audio-play-pause').disabled = true;
					document.getElementById('audio-stop').disabled = true;
					setTimeout(() => {
						loadingDiv.classList.remove('show');
					}, 3000);
				});
			}

			// Play next track (random shuffle)
			function playNextTrack() {
				if (tracksData.length === 0) return;

				// Pick a random next track
				const nextIndex = Math.floor(Math.random() * tracksData.length);
				currentTrackIndex = nextIndex;

				const track = tracksData[nextIndex];
				const streamUrl = `${API_BASE_URL}/api/v1/stream/${track.id}`;
				playTrack(streamUrl, track.title, track.artwork_url);
			}

			// Create interaction prompt
			const interactionPrompt = document.createElement('div');
			interactionPrompt.className = 'interaction-prompt';
			interactionPrompt.innerHTML = 'Press <kbd>F</kbd> to use computer';
			document.body.appendChild(interactionPrompt);

			// Create audio loading indicator
			const audioLoadingDiv = document.createElement('div');
			audioLoadingDiv.id = 'audio-loading';
			audioLoadingDiv.innerHTML = 'Loading audio...';
			document.body.appendChild(audioLoadingDiv);

			// Load the retro computer
			let computerPosition = new THREE.Vector3(-5, 0.75, 5);
			loadingManager.loadGLTF('build/assets/retro_computer.glb', (computerModel) => {
				const computer = computerModel.scene;
				window.computer = computer; // Make globally accessible for customization
				computer.position.copy(computerPosition);
				computer.scale.set(1, 1, 1);

				// Add to world
				world.graphicsWorld.add(computer);

				// Setup materials for shadows, apply saved colors, and find screen
				let screenMesh = null;
				computer.traverse((child) => {
					if (child.isMesh) {
						child.castShadow = true;
						child.receiveShadow = true;
						if (child.material) {
							world.sky.csm.setupMaterial(child.material);

							// Apply saved customization colors - check both lowercase and uppercase
							const matName = child.material.name;
							if ((matName === 'CHASIS' || matName.toLowerCase().includes('chasis')) && window.computerChassisColor) {
								child.material.color.set(window.computerChassisColor);
								console.log('✅ Applied CHASIS color:', window.computerChassisColor);
							} else if ((matName === 'KEYBOARD' || matName.toLowerCase().includes('keyboard')) && window.computerKeyboardColor) {
								child.material.color.set(window.computerKeyboardColor);
								console.log('✅ Applied KEYBOARD color:', window.computerKeyboardColor);
							} else if ((matName === 'FEATURES' || matName.toLowerCase().includes('features')) && window.computerFeaturesColor) {
								child.material.color.set(window.computerFeaturesColor);
								console.log('✅ Applied FEATURES color:', window.computerFeaturesColor);
							}
						}

					// Look for screen material by name
					if (child.material && child.material.name &&
					    child.material.name.toLowerCase().includes('screen')) {
						screenMesh = child;
						console.log('✅ Found screen mesh:', child.name, 'with material:', child.material.name);
					}
					}
				});

				// Make screen glow and store reference globally
				if (screenMesh) {
					// Clone material to avoid affecting other meshes
					screenMesh.material = screenMesh.material.clone();
					screenMesh.material.color = new THREE.Color(0x000000); // Dark screen
					screenMesh.material.emissive = new THREE.Color(0x000000); // No glow initially
					screenMesh.material.emissiveIntensity = 0;

					// Store screen mesh globally for updating album art
					window.computerScreenMesh = screenMesh;

					// Add point light for screen glow (off initially)
					const screenLight = new THREE.PointLight(0x000000, 0, 3);
					screenLight.position.copy(computerPosition);
					screenLight.position.y += 0.5; // Raise light to screen height
					world.graphicsWorld.add(screenLight);
					window.computerScreenLight = screenLight;

					console.log('💻 Computer screen ready for album art display');
				} else {
					// Fallback: create manual screen plane
					const screenGeometry = new THREE.PlaneGeometry(0.3, 0.2);
					const screenMaterial = new THREE.MeshStandardMaterial({
						color: 0x000000,
						emissive: 0xbee17b,
						emissiveIntensity: 0.5
					});
					const screenPlane = new THREE.Mesh(screenGeometry, screenMaterial);
					screenPlane.position.copy(computerPosition);
					screenPlane.position.y += 0.3;
					screenPlane.position.z += 0.3;
					computer.add(screenPlane);

					window.computerScreenMesh = screenPlane;

					// Add point light
					const screenLight = new THREE.PointLight(0xbee17b, 1.5, 3);
					screenLight.position.copy(computerPosition);
					screenLight.position.y += 0.5;
					world.graphicsWorld.add(screenLight);
					window.computerScreenLight = screenLight;

					console.log('💻 Computer screen (fallback) ready for album art display');
				}

				// Add physics collision box for the computer
				const computerShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.75, 0.5));
				const computerBody = new CANNON.Body({
					mass: 0, // Static object (won't move)
					shape: computerShape,
					position: new CANNON.Vec3(-5, 0.75, 5)
				});
				world.physicsWorld.addBody(computerBody);
			});


		// Function to update computer screen with album artwork
		window.updateComputerScreen = function(artworkUrl) {
			if (!window.computerScreenMesh) {
				console.warn('Computer screen mesh not ready');
				return;
			}

			if (!artworkUrl) {
				// No artwork - show green glow
				if (window.computerScreenMesh.material.map) {
					window.computerScreenMesh.material.map.dispose();
					window.computerScreenMesh.material.map = null;
				}
				window.computerScreenMesh.material.emissive = new THREE.Color(0xbee17b);
				window.computerScreenMesh.material.emissiveIntensity = 0.5;
				window.computerScreenMesh.material.needsUpdate = true;
				if (window.computerScreenLight) {
					window.computerScreenLight.color = new THREE.Color(0xbee17b);
				}
				return;
			}

			// Load artwork image
			const loader = new THREE.TextureLoader();
			loader.crossOrigin = "anonymous";
			loader.load(artworkUrl, (texture) => {
				// Create normalized square canvas with artwork centered
				const size = 512; // Fixed square size

				// Draw everything in normal orientation
				const canvas = document.createElement('canvas');
				const ctx = canvas.getContext('2d');
				canvas.width = size;
				canvas.height = size;

				// Fill with black background
				ctx.fillStyle = '#000000';
				ctx.fillRect(0, 0, size, size);

				// Calculate dimensions to fit image in square while maintaining aspect ratio
				const img = texture.image;
				const scale = Math.min(size / img.width, size / img.height) * 0.5; // Scale down to 50% for padding
				const scaledWidth = img.width * scale;
				const scaledHeight = img.height * scale;

				// Draw the album art centered, with space at top for VU meters
				const artY = (size - scaledHeight) / 2 + 40; // Offset down for VU meters
				const artX = (size - scaledWidth) / 2;
				ctx.drawImage(img, artX, artY, scaledWidth, scaledHeight);

				// Store the base canvas for animation (normal orientation)
				window.screenBaseCanvas = canvas;
				window.screenBaseImage = ctx.getImageData(0, 0, size, size);

				// Create animated canvas with glitch effects
				const animCanvas = document.createElement('canvas');
				animCanvas.width = size;
				animCanvas.height = size;
				const animCtx = animCanvas.getContext('2d');

				// Create new texture from animated canvas
				const normalizedTexture = new THREE.CanvasTexture(animCanvas);
				normalizedTexture.wrapS = THREE.ClampToEdgeWrapping;
				normalizedTexture.wrapT = THREE.ClampToEdgeWrapping;

				// Update screen material with normalized artwork
				if (window.computerScreenMesh.material.map) {
					window.computerScreenMesh.material.map.dispose();
				}
				window.computerScreenMesh.material.map = normalizedTexture;
				window.computerScreenMesh.material.color = new THREE.Color(0xffffff); // White to show texture
				window.computerScreenMesh.material.emissive = new THREE.Color(0x222222);
				window.computerScreenMesh.material.emissiveIntensity = 0.3;
				window.computerScreenMesh.material.needsUpdate = true;

				// Glitch animation loop
				let glitchOffset = 0;
				let scanlineOffset = 0;
				let glitchIntensity = 0;
				let nextGlitch = Date.now() + Math.random() * 3000 + 2000; // Random glitch every 2-5 seconds

				// Waveform history for Rekordbox-style display
				const waveformHistory = [];
				const waveformMaxBars = 60;

				function animateScreen() {
					if (!window.screenBaseCanvas || !window.screenBaseImage) return;

					// Get audio data for reactive effects
					let audioLevel = 0;
					let bassLevel = 0;
					let trebleLevel = 0;

					if (window.audioAnalyser && positionalAudio && positionalAudio.isPlaying) {
						const frequencyData = new Uint8Array(window.audioAnalyser.frequencyBinCount);
						window.audioAnalyser.getByteFrequencyData(frequencyData);

						// Calculate bass (low frequencies)
						let bassSum = 0;
						for (let i = 0; i < frequencyData.length * 0.1; i++) {
							bassSum += frequencyData[i];
						}
						bassLevel = bassSum / (frequencyData.length * 0.1) / 255;

						// Calculate treble (high frequencies)
						let trebleSum = 0;
						for (let i = Math.floor(frequencyData.length * 0.7); i < frequencyData.length; i++) {
							trebleSum += frequencyData[i];
						}
						trebleLevel = trebleSum / (frequencyData.length * 0.3) / 255;

						// Overall audio level
						let sum = 0;
						for (let i = 0; i < frequencyData.length; i++) {
							sum += frequencyData[i];
						}
						audioLevel = sum / frequencyData.length / 255;
					}

					// Put base image on animated canvas
					animCtx.putImageData(window.screenBaseImage, 0, 0);

					// Draw mini VU meters, Stereoscope, and Waveform (inline, 75% width)
					if (window.audioAnalyser && positionalAudio && positionalAudio.isPlaying) {
						const frequencyData = new Uint8Array(window.audioAnalyser.frequencyBinCount);
						window.audioAnalyser.getByteFrequencyData(frequencyData);

						const timeData = new Uint8Array(window.audioAnalyser.frequencyBinCount);
						window.audioAnalyser.getByteTimeDomainData(timeData);

						const baseY = size / 2 - 135; // Moved up more to clear cover art
						const totalContainerWidth = size * 0.75; // 75% of screen width
						const containerStartX = (size - totalContainerWidth) / 2;
						const gap = 10; // Gap between blocks
						const blockWidth = (totalContainerWidth - gap * 2) / 3; // Each block gets 1/3

						// ==== VU METERS (Left side) ====
						const meterCount = 20; // Fewer meters to fit in smaller space
						const meterWidth = Math.floor(blockWidth / meterCount) - 2;
						const meterMaxHeight = 40;
						const meterY = baseY;
						const meterStartX = containerStartX;

						// Dark background for VU meters
						animCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
						animCtx.fillRect(meterStartX - 5, meterY - 10, blockWidth + 10, meterMaxHeight + 20);

						for (let i = 0; i < meterCount; i++) {
							const dataIndex = Math.floor((i / meterCount) * frequencyData.length);
							const value = frequencyData[dataIndex] / 255;
							const meterHeight = value * meterMaxHeight;
							const x = meterStartX + i * (meterWidth + 2);

							// Color based on height
							let color;
							if (value < 0.5) {
								color = '#00ff00';
							} else if (value < 0.8) {
								color = '#ffff00';
							} else {
								color = '#ff0000';
							}

							animCtx.fillStyle = color;
							animCtx.fillRect(x, meterY + meterMaxHeight - meterHeight, meterWidth, meterHeight);

							animCtx.strokeStyle = '#bee17b';
							animCtx.lineWidth = 1;
							animCtx.strokeRect(x, meterY, meterWidth, meterMaxHeight);
						}

						// ==== STEREOSCOPE (Middle) ====
						const scopeY = baseY;
						const scopeWidth = blockWidth;
						const scopeHeight = 40; // Match VU meter height
						const scopeStartX = containerStartX + blockWidth + gap;

						// Dark background for stereoscope
						animCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
						animCtx.fillRect(scopeStartX - 5, scopeY - 10, scopeWidth + 10, scopeHeight + 20);

						// Draw oscilloscope waveform
						animCtx.strokeStyle = '#00ff00';
						animCtx.lineWidth = 2;
						animCtx.beginPath();

						const sliceWidth = scopeWidth / timeData.length;
						let x = scopeStartX;

						for (let i = 0; i < timeData.length; i++) {
							const v = timeData[i] / 128.0;
							const y = scopeY + (v * scopeHeight / 2);

							if (i === 0) {
								animCtx.moveTo(x, y);
							} else {
								animCtx.lineTo(x, y);
							}

							x += sliceWidth;
						}

						animCtx.stroke();

						// Draw border
						animCtx.strokeStyle = '#bee17b';
						animCtx.lineWidth = 1;
						animCtx.strokeRect(scopeStartX, scopeY, scopeWidth, scopeHeight);

						// ==== WAVEFORM (Right side - Rekordbox RGB style) ====
						const waveY = baseY;
						const waveWidth = blockWidth;
						const waveHeight = 40;
						const waveStartX = containerStartX + (blockWidth + gap) * 2;

						// Calculate frequency bands for RGB waveform
						const bassEnd = Math.floor(frequencyData.length * 0.1); // Low frequencies
						const midEnd = Math.floor(frequencyData.length * 0.5); // Mid frequencies
						// Rest is highs

						let bassLevel = 0;
						let midLevel = 0;
						let highLevel = 0;

						// Sum up each frequency band
						for (let i = 0; i < bassEnd; i++) {
							bassLevel += frequencyData[i];
						}
						for (let i = bassEnd; i < midEnd; i++) {
							midLevel += frequencyData[i];
						}
						for (let i = midEnd; i < frequencyData.length; i++) {
							highLevel += frequencyData[i];
						}

						// Normalize to 0-1 range
						bassLevel = (bassLevel / bassEnd) / 255;
						midLevel = (midLevel / (midEnd - bassEnd)) / 255;
						highLevel = (highLevel / (frequencyData.length - midEnd)) / 255;

						// Add to waveform history
						waveformHistory.push({ bass: bassLevel, mid: midLevel, high: highLevel });
						if (waveformHistory.length > waveformMaxBars) {
							waveformHistory.shift(); // Remove oldest
						}

						// Dark background for waveform
						animCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
						animCtx.fillRect(waveStartX - 5, waveY - 10, waveWidth + 10, waveHeight + 20);

						// Draw center line
						animCtx.strokeStyle = '#333333';
						animCtx.lineWidth = 1;
						animCtx.beginPath();
						animCtx.moveTo(waveStartX, waveY + waveHeight / 2);
						animCtx.lineTo(waveStartX + waveWidth, waveY + waveHeight / 2);
						animCtx.stroke();

						// Draw RGB waveform bars (Rekordbox style)
						const barWidth = waveWidth / waveformMaxBars;
						const centerY = waveY + waveHeight / 2;

						for (let i = 0; i < waveformHistory.length; i++) {
							const frame = waveformHistory[i];
							const barX = waveStartX + i * barWidth;

							// Calculate total amplitude and individual band heights
							const totalAmplitude = (frame.bass + frame.mid + frame.high) / 3;
							const maxBarHeight = waveHeight / 2;

							// Draw stacked frequency bands (from center outward)
							// Red (bass) at bottom/top
							const bassHeight = frame.bass * maxBarHeight;
							animCtx.fillStyle = '#ff0000';
							animCtx.fillRect(barX, centerY - bassHeight, barWidth - 1, bassHeight);
							animCtx.fillRect(barX, centerY, barWidth - 1, bassHeight);

							// Green (mids) on top of bass
							const midHeight = frame.mid * maxBarHeight;
							animCtx.fillStyle = '#00ff00';
							animCtx.fillRect(barX, centerY - bassHeight - midHeight, barWidth - 1, midHeight);
							animCtx.fillRect(barX, centerY + bassHeight, barWidth - 1, midHeight);

							// Blue (highs) on top of everything
							const highHeight = frame.high * maxBarHeight;
							animCtx.fillStyle = '#0088ff';
							animCtx.fillRect(barX, centerY - bassHeight - midHeight - highHeight, barWidth - 1, highHeight);
							animCtx.fillRect(barX, centerY + bassHeight + midHeight, barWidth - 1, highHeight);
						}

						// Draw border
						animCtx.strokeStyle = '#bee17b';
						animCtx.lineWidth = 1;
						animCtx.strokeRect(waveStartX, waveY, waveWidth, waveHeight);
					}

					// Scanline effect - speed varies with music
					const scanlineSpeed = 2 + (audioLevel * 8);
					scanlineOffset = (scanlineOffset + scanlineSpeed) % size;
					const scanlineOpacity = 0.03 + (audioLevel * 0.1);
					animCtx.fillStyle = `rgba(0, 255, 0, ${scanlineOpacity})`;
					for (let i = scanlineOffset; i < size; i += 4) {
						animCtx.fillRect(0, i, size, 1);
					}

					// Bass-triggered glitch
					if (bassLevel > 0.7) {
						glitchIntensity = Math.max(glitchIntensity, bassLevel);
					}

					// Random glitch effect
					const now = Date.now();
					if (now > nextGlitch) {
						glitchIntensity = 1.0;
						nextGlitch = now + Math.random() * 3000 + 2000;
					}

					if (glitchIntensity > 0) {
						// RGB shift glitch - intensity based on music
						const shift = Math.floor(glitchIntensity * 10 * (1 + audioLevel));
						const imgData = animCtx.getImageData(0, 0, size, size);
						const data = imgData.data;

						for (let i = 0; i < data.length; i += 4) {
							const shiftIndex = i + shift * 4;
							if (shiftIndex < data.length) {
								data[i] = data[shiftIndex]; // R channel shift
							}
						}
						animCtx.putImageData(imgData, 0, 0);

						// Random horizontal glitch lines
						if (Math.random() > 0.7) {
							const y = Math.floor(Math.random() * size);
							const height = Math.floor(Math.random() * 20) + 5;
							const offset = (Math.random() - 0.5) * 30 * glitchIntensity;

							const sliceData = animCtx.getImageData(0, y, size, height);
							animCtx.putImageData(sliceData, offset, y);
						}

						glitchIntensity *= 0.85; // Decay glitch effect
					}

					// Screen flicker - treble reactive
					if (trebleLevel > 0.6 || Math.random() > 0.95) {
						animCtx.fillStyle = `rgba(190, 225, 123, ${Math.random() * 0.1 * (1 + trebleLevel)})`;
						animCtx.fillRect(0, 0, size, size);
					}

					// Pulse glow effect on bass hits
					if (bassLevel > 0.65) {
						const pulseGradient = animCtx.createRadialGradient(size / 2, size / 2 + 40, 0, size / 2, size / 2 + 40, size / 2);
						pulseGradient.addColorStop(0, `rgba(190, 225, 123, ${bassLevel * 0.3})`);
						pulseGradient.addColorStop(1, 'rgba(190, 225, 123, 0)');
						animCtx.fillStyle = pulseGradient;
						animCtx.fillRect(0, 0, size, size);
					}

					// NOW apply rotation and flip to a final canvas
					const rotatedCanvas = document.createElement('canvas');
					rotatedCanvas.width = size;
					rotatedCanvas.height = size;
					const rotatedCtx = rotatedCanvas.getContext('2d');

					rotatedCtx.save();
					rotatedCtx.translate(size / 2, size / 2);
					rotatedCtx.rotate(-Math.PI / 2);
					rotatedCtx.scale(1, -1);
					rotatedCtx.drawImage(animCanvas, -size / 2, -size / 2);
					rotatedCtx.restore();

					// Copy rotated result back to animCanvas
					animCtx.clearRect(0, 0, size, size);
					animCtx.drawImage(rotatedCanvas, 0, 0);

					// Update texture
					normalizedTexture.needsUpdate = true;

					requestAnimationFrame(animateScreen);
				}

				// Start animation
				animateScreen();

				// Extract dominant color for light (sample center of normalized canvas)
				const centerX = Math.floor(size / 2);
				const centerY = Math.floor(size / 2);
				const pixel = ctx.getImageData(centerX, centerY, 1, 1).data;
				const dominantColor = new THREE.Color(pixel[0] / 255, pixel[1] / 255, pixel[2] / 255);

				if (window.computerScreenLight) {
					window.computerScreenLight.color = dominantColor;
					window.computerScreenLight.intensity = 2.0;
				}

				console.log('💻 Computer screen updated with artwork:', artworkUrl);
			}, undefined, (error) => {
				console.error('Failed to load artwork for computer screen:', error);
				// Fallback to green glow
				window.updateComputerScreen(null);
			});
		};

		// Function to update hat material with username text
		window.updateHatWithUsername = function(username) {
			if (!window.character) {
				console.warn('Character not ready for hat update');
				return;
			}

			// Find the hat mesh in the character model (use character.traverse, not modelContainer)
			let hatMesh = null;
			console.log('🔍 Searching for hat mesh on character...');
			window.character.traverse((child) => {
				if (child.isMesh && child.material) {
					const materialName = child.material.name?.toLowerCase() || '';
					console.log('  Character mesh:', child.name, 'material:', child.material.name);
					if (materialName.includes('hat')) {
						hatMesh = child;
						console.log('✅ Found hat mesh:', child.name, 'material:', child.material.name);
					}
				}
			});

			if (!hatMesh) {
				console.warn('Hat mesh not found on character');
				return;
			}

			// Clone the material so we don't affect other instances
			if (!hatMesh.userData.originalMaterial) {
				hatMesh.userData.originalMaterial = hatMesh.material;
			}
			hatMesh.material = hatMesh.material.clone();

			// Create canvas with hat color as background and fixed text color
			const canvas = document.createElement('canvas');
			canvas.width = 512;
			canvas.height = 512;
			const ctx = canvas.getContext('2d');

			// Fill entire canvas with current hat color (darker to compensate for white material)
			const currentColor = hatMesh.material.color;
			const r = Math.floor(currentColor.r * 255 * 0.6); // Darken by 40%
			const g = Math.floor(currentColor.g * 255 * 0.6);
			const b = Math.floor(currentColor.b * 255 * 0.6);
			ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			// Draw username text with fixed SUBLAIR green (smaller, centered once)
			const text = username.toUpperCase();
			ctx.fillStyle = '#bee17b'; // SUBLAIR green - always this color
			ctx.font = 'bold 16px Arial';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';

			// Add outline for better visibility
			ctx.strokeStyle = '#000000';
			ctx.lineWidth = 1;

			// Mirror horizontally and move up slightly
			ctx.save();
			ctx.scale(-1, 1); // Mirror horizontally
			ctx.strokeText(text, -canvas.width / 2, canvas.height / 2 - 50); // Move up 50px
			ctx.fillText(text, -canvas.width / 2, canvas.height / 2 - 50);
			ctx.restore();

			// Create texture from canvas
			const texture = new THREE.CanvasTexture(canvas);
			texture.wrapS = THREE.ClampToEdgeWrapping; // Prevent wrapping
			texture.wrapT = THREE.ClampToEdgeWrapping; // Prevent wrapping
			texture.needsUpdate = true;

			// Apply texture to hat material
			if (hatMesh.material.map) {
				hatMesh.material.map.dispose();
			}
			hatMesh.material.map = texture;
			hatMesh.material.color = new THREE.Color(0xffffff); // Set to white so texture colors show exactly
			hatMesh.material.roughness = 1.0; // Make it less glossy
			hatMesh.material.metalness = 0.0; // No metallic effect
			hatMesh.material.needsUpdate = true;

			console.log('🧢 Hat updated with username:', username.toUpperCase());
			console.log('Hat material:', hatMesh.material);
			console.log('Hat has texture:', !!hatMesh.material.map);
		};

			// Load the dome surrounding everything
			loadingManager.loadGLTF('build/assets/dome.glb', (domeModel) => {
				const dome = domeModel.scene;
				dome.position.set(0, -15, 0); // Lower to prevent base collision
				dome.scale.set(20, 20, 20);

				// Add to world
				world.graphicsWorld.add(dome);

				// Create hollow sphere collision using multiple planes facing inward
				const domeRadius = 80; // Collision radius
				const segments = 12; // More segments for better coverage
				const rings = 12; // More rings for better coverage

				for (let lat = 0; lat < segments; lat++) {
					const theta = (lat / segments) * Math.PI; // 0 to PI

					for (let lon = 0; lon < rings; lon++) {
						const phi = (lon / rings) * Math.PI * 2; // 0 to 2PI

						// Calculate position on sphere
						const x = domeRadius * Math.sin(theta) * Math.cos(phi);
						const y = domeRadius * Math.cos(theta) - 5; // Offset by dome position
						const z = domeRadius * Math.sin(theta) * Math.sin(phi);

						// Create plane facing inward (toward center)
						const planeShape = new CANNON.Plane();
						const planeBody = new CANNON.Body({
							mass: 0,
							shape: planeShape,
							position: new CANNON.Vec3(x, y, z)
						});

						// Point the plane normal toward center (0, -5, 0)
						const centerX = 0;
						const centerY = -5;
						const centerZ = 0;

						const normalX = centerX - x;
						const normalY = centerY - y;
						const normalZ = centerZ - z;

						const length = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
						const nx = normalX / length;
						const ny = normalY / length;
						const nz = normalZ / length;

						// Use lookAt-style quaternion calculation
						const quaternion = new CANNON.Quaternion();
						quaternion.setFromVectors(new CANNON.Vec3(0, 0, 1), new CANNON.Vec3(nx, ny, nz));
						planeBody.quaternion.copy(quaternion);

						world.physicsWorld.addBody(planeBody);
					}
				}
			});

			// Create spatial audio setup
			const audioListener = new THREE.AudioListener();
			const positionalAudio = new THREE.PositionalAudio(audioListener);
			let speakers; // Store speakers reference globally

			// Create 3-band EQ using Web Audio API
			const audioContext = audioListener.context;
			const lowFilter = audioContext.createBiquadFilter();
			const midFilter = audioContext.createBiquadFilter();
			const highFilter = audioContext.createBiquadFilter();
			const lowpassFilter = audioContext.createBiquadFilter();
			const highpassFilter = audioContext.createBiquadFilter();

			// Configure EQ filters
			lowFilter.type = 'lowshelf';
			lowFilter.frequency.value = 320; // Low frequencies
			lowFilter.gain.value = 0;

			midFilter.type = 'peaking';
			midFilter.frequency.value = 1000; // Mid frequencies
			midFilter.Q.value = 0.5;
			midFilter.gain.value = 0;

			highFilter.type = 'highshelf';
			highFilter.frequency.value = 3200; // High frequencies
			highFilter.gain.value = 0;

			// Configure lowpass/highpass filters
			lowpassFilter.type = 'lowpass';
			lowpassFilter.frequency.value = 20000; // Default max
			lowpassFilter.Q.value = 1;

			highpassFilter.type = 'highpass';
			highpassFilter.frequency.value = 20; // Default min
			highpassFilter.Q.value = 1;

			// Create vehicle lowpass filter for in-car effect
			const vehicleLowpass = audioContext.createBiquadFilter();
			vehicleLowpass.type = 'lowpass';
			vehicleLowpass.frequency.value = 20000; // Default off (full range)
			vehicleLowpass.Q.value = 1;

			// Create master volume gain node
			const masterGain = audioContext.createGain();
			masterGain.gain.value = 1.0; // 100%

			// Create analyzer node (AFTER all filters to see post-processed audio)
			const analyser = audioContext.createAnalyser();
			analyser.fftSize = 2048;
			analyser.smoothingTimeConstant = 0.8;

			// Store filters globally for access
			window.eqFilters = {
				low: lowFilter,
				mid: midFilter,
				high: highFilter,
				lowpass: lowpassFilter,
				highpass: highpassFilter,
				vehicleLowpass: vehicleLowpass,
				masterGain: masterGain
			};

			window.audioAnalyser = analyser;

			// Initialize sound engine now that audioListener exists
			soundEngine = new SoundEngine(audioListener);

			// Load all sounds
			soundEngine.loadSounds([
				// Footstep sounds
				{ name: 'footstep1', path: 'build/snds/step1.wav', options: { volume: 0.5 } },
				{ name: 'footstep2', path: 'build/snds/step2.wav', options: { volume: 0.5 } },
				{ name: 'footstep3', path: 'build/snds/step3.wav', options: { volume: 0.5 } },
				{ name: 'footstep4', path: 'build/snds/step4.wav', options: { volume: 0.5 } },
				{ name: 'footstep5', path: 'build/snds/step5.wav', options: { volume: 0.5 } },
				{ name: 'footstep6', path: 'build/snds/step6.wav', options: { volume: 0.5 } },
				{ name: 'footstep7', path: 'build/snds/step7.wav', options: { volume: 0.5 } },
				// Ambient background music
				{ name: 'ambience', path: 'build/snds/ambience.mp3', options: { volume: 0.15, loop: true } }
			]).then(() => {
				console.log('All sounds loaded!');

				// Resume AudioContext on first user interaction (required by browser autoplay policy)
				const resumeAudio = () => {
					console.log('🎯 User interaction detected, AudioContext state:', audioListener.context.state);
					if (audioListener.context.state === 'suspended') {
						audioListener.context.resume().then(() => {
							console.log('✅ AudioContext resumed - footsteps should work now');
						}).catch(err => {
							console.error('❌ Failed to resume AudioContext:', err);
						});
					} else {
						console.log('✅ AudioContext already running:', audioListener.context.state);
					}
					// Remove listeners after first interaction
					document.removeEventListener('click', resumeAudio);
					document.removeEventListener('keydown', resumeAudio);
				};
				document.addEventListener('click', resumeAudio);
				document.addEventListener('keydown', resumeAudio);

				// Also check immediately
				console.log('🔍 Initial AudioContext state:', audioListener.context.state);

				// Start playing ambient music immediately
				soundEngine.play('ambience');
				console.log('Ambient music started');
			}).catch(error => {
				console.error('Error loading sounds:', error);
			});

			// Update crosshair visibility based on aim mode
			const crosshairElement = document.getElementById('crosshair');
			setInterval(() => {
				if (window.character && crosshairElement) {
					// Show crosshair only when in aim mode (holding E)
					crosshairElement.style.display = window.character.aimMode ? 'block' : 'none';
				}
			}, 16); // 60fps

			// Monitor character movement for footsteps
			let footstepDebugCount = 0;
			let debugCounter = 0;
			setInterval(() => {
				const char = window.character; // Use global reference

				// Debug every 100 cycles (5 seconds)
				if (debugCounter % 100 === 0 && char) {
					console.log(`🔍 Footstep check: character=${!!char}, terminal=${terminalOpen}, custom=${customizationOpen}, soundEngine=${!!soundEngine}, moving=${isMovingState(char)}, grounded=${char.rayHasHit}`);
				}
				debugCounter++;

				if (char && !terminalOpen && !customizationOpen && soundEngine) {
					// Check if character is in a moving state and on ground
					if (isMovingState(char) && char.rayHasHit) {
						const now = Date.now();
						const dynamicInterval = getFootstepInterval(char);

						if (now - lastFootstepTime > dynamicInterval) {
							// Add organic variation to volume and pitch
							const volumeVariation = 0.8 + Math.random() * 0.4; // 0.8 to 1.2
							const pitchVariation = 0.95 + Math.random() * 0.1; // 0.95 to 1.05

							// Calculate volume based on movement speed
							const velocity = char.velocity;
							const speed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
							const speedMultiplier = Math.min(1.0, 0.5 + speed * 0.3); // Louder when faster

							const finalVolume = 0.10 * volumeVariation * speedMultiplier;

							// Play random footstep sound with variation
							const footstepName = getRandomFootstep();

							// Debug logging (only show every 5th footstep to avoid spam)
							if (footstepDebugCount % 5 === 0) {
								console.log(`🦶 Footstep #${footstepDebugCount}: ${footstepName}, vol: ${finalVolume.toFixed(3)}, pitch: ${pitchVariation.toFixed(2)}, speed: ${speed.toFixed(2)}, AudioContext: ${audioListener.context.state}`);
							}
							footstepDebugCount++;

							soundEngine.play(footstepName, {
								allowOverlap: false,
								volume: finalVolume,
								pitch: pitchVariation
							});
							lastFootstepTime = now;
						}
					}
				}
			}, 50);

			// Load the speakers behind the computer
			loadingManager.loadGLTF('build/assets/speakers.glb', (speakersModel) => {
				const speakers = speakersModel.scene;
				window.speakers = speakers; // Make globally accessible for customization
				speakers.position.set(-10, 0, 5); // Behind the computer, Y at ground level
				speakers.scale.set(1, 1, 1);

				// Calculate bounding box BEFORE rotation
				const bbox = new THREE.Box3().setFromObject(speakers);
				const size = new THREE.Vector3();
				bbox.getSize(size);

				// Now rotate the visual model
				speakers.rotation.y = Math.PI / 2; // Rotate 90 degrees

				// Add to world
				world.graphicsWorld.add(speakers);

				// Add positional audio to speakers
				speakers.add(positionalAudio);
				positionalAudio.position.set(1, 1, -3.5); // Offset on X, Y, and Z in local space
				positionalAudio.setRefDistance(10); // Distance at which volume starts to drop
				positionalAudio.setMaxDistance(50); // Max distance audio can be heard
				positionalAudio.setRolloffFactor(1); // How quickly sound fades with distance

				// Store globally for direction calculations
				window.positionalAudio = positionalAudio;

				// Make it directional like a real festival speaker (front-facing cone)
				positionalAudio.setDirectionalCone(120, 230, 0.3); // innerAngle, outerAngle, outerGain
				// innerAngle: 120° - Full volume cone in front
				// outerAngle: 230° - Volume drops outside this cone
				// outerGain: 0.3 - Behind the speaker is 70% quieter

				// Create a dynamic lowpass filter for directional muffling
				window.speakerDirectionalLowpass = audioContext.createBiquadFilter();
				window.speakerDirectionalLowpass.type = 'lowpass';
				window.speakerDirectionalLowpass.frequency.value = 20000; // Start at full range
				window.speakerDirectionalLowpass.Q.value = 1;

				// Create bass boost for behind-speaker effect (clippy bass)
				window.speakerDirectionalBass = audioContext.createBiquadFilter();
				window.speakerDirectionalBass.type = 'lowshelf';
				window.speakerDirectionalBass.frequency.value = 150;
				window.speakerDirectionalBass.gain.value = 0; // Start at 0, boost when behind

				console.log('🔊 Directional speaker cone configured with dynamic lowpass');

				// Store speaker position globally for direction calculation
				// Account for the positionalAudio offset in world space
				window.speakerPosition = new THREE.Vector3();
				positionalAudio.getWorldPosition(window.speakerPosition);

				// Create debug visualization for speaker position
				const speakerMarkerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
				const speakerMarkerMaterial = new THREE.MeshBasicMaterial({
					color: 0xff0000,
					transparent: true,
					opacity: 0.8
				});
				window.debugSpeakerMarker = new THREE.Mesh(speakerMarkerGeometry, speakerMarkerMaterial);
				window.debugSpeakerMarker.position.copy(window.speakerPosition);
				window.debugSpeakerMarker.visible = false;
				world.graphicsWorld.add(window.debugSpeakerMarker);

				// Create arrow showing speaker direction (will be updated to actual direction)
				const initialDir = new THREE.Vector3();
				positionalAudio.getWorldDirection(initialDir);
				const arrowHelper = new THREE.ArrowHelper(
					initialDir, // direction
					window.speakerPosition, // origin
					5, // length
					0x00ffff, // cyan color
					1, // headLength
					0.5 // headWidth
				);
				window.debugSpeakerArrow = arrowHelper;
				window.debugSpeakerArrow.visible = false;
				world.graphicsWorld.add(window.debugSpeakerArrow);

				// Create cone visualizations - simpler and more visible
				// Inner cone (145°)
				const innerConeAngle = 145 * Math.PI / 180;
				const innerConeRadius = Math.tan(innerConeAngle / 2) * 15;
				const innerConeGeometry = new THREE.ConeGeometry(innerConeRadius, 15, 32, 1, false);
				const innerConeMaterial = new THREE.MeshBasicMaterial({
					color: 0x00ff00,
					transparent: true,
					opacity: 0.2,
					side: THREE.DoubleSide
				});
				window.debugInnerCone = new THREE.Mesh(innerConeGeometry, innerConeMaterial);

				// Outer cone (230°)
				const outerConeAngle = 230 * Math.PI / 180;
				const outerConeRadius = Math.tan(outerConeAngle / 2) * 15;
				const outerConeGeometry = new THREE.ConeGeometry(outerConeRadius, 15, 32, 1, false);
				const outerConeMaterial = new THREE.MeshBasicMaterial({
					color: 0xffff00,
					transparent: true,
					opacity: 0.15,
					side: THREE.DoubleSide
				});
				window.debugOuterCone = new THREE.Mesh(outerConeGeometry, outerConeMaterial);

				// Back cone (90° to 180° behind - distortion zone)
				// This is a 180° cone (full hemisphere) pointing backwards
				const backConeAngle = 180 * Math.PI / 180; // 180° cone for full rear hemisphere
				const backConeRadius = Math.tan(backConeAngle / 2) * 20; // Massive radius for 180°
				const backConeGeometry = new THREE.ConeGeometry(backConeRadius, 20, 32, 1, false);
				const backConeMaterial = new THREE.MeshBasicMaterial({
					color: 0xff0000,
					transparent: true,
					opacity: 0.25,
					side: THREE.DoubleSide
				});
				window.debugBackCone = new THREE.Mesh(backConeGeometry, backConeMaterial);

				// Position and rotate cones - point from speaker position in positive X direction
				// Cone geometry points down -Y by default, so we rotate to point along +X
				const coneRotation = new THREE.Euler(-Math.PI / 2, 0, Math.PI / 2, 'XYZ');
				window.debugInnerCone.rotation.copy(coneRotation);
				window.debugOuterCone.rotation.copy(coneRotation);

				// Back cone points opposite direction (rotate 180° more on Y)
				const backConeRotation = new THREE.Euler(-Math.PI / 2, 0, -Math.PI / 2, 'XYZ');
				window.debugBackCone.rotation.copy(backConeRotation);

				// Position cones at speaker position, offset along direction
				const coneOffset = new THREE.Vector3(7.5, 0, 0); // Half the cone height along X axis
				window.debugInnerCone.position.copy(window.speakerPosition).add(coneOffset);
				window.debugOuterCone.position.copy(window.speakerPosition).add(coneOffset);

				// Back cone offset in opposite direction (longer cone needs bigger offset)
				const backConeOffset = new THREE.Vector3(-10, 0, 0); // Negative X (backwards)
				window.debugBackCone.position.copy(window.speakerPosition).add(backConeOffset);

				// Add to scene but hide by default
				window.debugInnerCone.visible = false;
				window.debugOuterCone.visible = false;
				window.debugBackCone.visible = false;
				world.graphicsWorld.add(window.debugInnerCone);
				world.graphicsWorld.add(window.debugOuterCone);
				world.graphicsWorld.add(window.debugBackCone);

				console.log('🔍 Debug speaker cones created (press Q to toggle)');

				// Setup materials for shadows and apply saved colors
				speakers.traverse((child) => {
					if (child.isMesh) {
						child.castShadow = true;
						child.receiveShadow = true;
						if (child.material) {
							world.sky.csm.setupMaterial(child.material);

							// Apply saved customization colors - check both lowercase and uppercase
							const matName = child.material.name;
							if ((matName === 'CAB' || matName.toLowerCase().includes('cab')) && window.speakerCabColor) {
								child.material.color.set(window.speakerCabColor);
								console.log('✅ Applied CAB color:', window.speakerCabColor);
							} else if ((matName === 'TRIM' || matName === 'SPEAKER_TRIM' || (matName.toLowerCase().includes('trim') && matName.toLowerCase().includes('speaker'))) && window.speakerTrimColor) {
								child.material.color.set(window.speakerTrimColor);
								console.log('✅ Applied SPEAKER TRIM color:', window.speakerTrimColor);
							} else if ((matName === 'FACE' || matName.toLowerCase().includes('face')) && window.speakerFaceColor) {
								child.material.color.set(window.speakerFaceColor);
								console.log('✅ Applied FACE color:', window.speakerFaceColor);
							} else if ((matName === 'FRAME' || matName === 'SPEAKER_FRAME' || (matName.toLowerCase().includes('frame') && matName.toLowerCase().includes('speaker'))) && window.speakerFrameColor) {
								child.material.color.set(window.speakerFrameColor);
								console.log('✅ Applied SPEAKER FRAME color:', window.speakerFrameColor);
							}
						}
					}
				});

				// Get center position after rotation
				const rotatedBbox = new THREE.Box3().setFromObject(speakers);
				const center = new THREE.Vector3();
				rotatedBbox.getCenter(center);

				// Add physics collision box - swap X and Z because of 90 degree rotation
				const speakersShape = new CANNON.Box(new CANNON.Vec3(size.z / 2, size.y / 2, size.x / 2));
				const speakersBody = new CANNON.Body({
					mass: 0, // Static object (won't move)
					shape: speakersShape,
					position: new CANNON.Vec3(center.x, center.y, center.z)
				});
				world.physicsWorld.addBody(speakersBody);
			});

			// Computer interaction system
			let nearComputer = false;
			let nearCar = false;
			let radioPromptDismissed = false;

			// Vehicle audio transition
			let vehicleAudioTransition = 0; // 0 = not in vehicle, 1 = fully in vehicle
			let vehicleTransitionStartTime = null;
			const VEHICLE_ENTER_DURATION = 500; // 0.5 seconds to fully fade in/out
			const VEHICLE_EXIT_DURATION = 500; // 0.5 seconds to fade back

			// Bass bounce tracking
			let lastBassLevel = 0;
			let lastBassHitTime = 0;
			const BASS_HIT_COOLDOWN = 150; // Minimum 150ms between hits

			// Check distance to computer every frame
			function checkComputerProximity() {
				if (!character) return;

				const charPos = character.position;
				const distance = charPos.distanceTo(computerPosition);

				if (distance < 3 && !terminalOpen) {
					nearComputer = true;
					interactionPrompt.innerHTML = 'Press <kbd>F</kbd> to use computer';
					interactionPrompt.classList.add('show');
				} else {
					nearComputer = false;
					if (!nearCar) {
						interactionPrompt.classList.remove('show');
					}
				}
			}

			// Check if character is in a car
			function checkCarProximity() {
				if (!character) return;

				// Check if character is sitting in a vehicle (has controlledObject)
				const inVehicle = character.controlledObject && character.controlledObject.rayCastVehicle;

				if (inVehicle && !nearCar && !radioPromptDismissed) {
					nearCar = true;
					interactionPrompt.innerHTML = 'Press <kbd>R</kbd> for phone';
					interactionPrompt.classList.add('show');
				} else if (!inVehicle && nearCar) {
					nearCar = false;
					// Reset the dismissed flag when exiting vehicle
					radioPromptDismissed = false;
					if (!nearComputer) {
						interactionPrompt.classList.remove('show');
					}
				}
			}

			// Add to update loop
			const updateInterval = setInterval(() => {
				if (character) {
					checkComputerProximity();
					checkCarProximity();

					// Update vehicle audio transition with time-based animation
					const inVehicle = character.controlledObject && character.controlledObject.rayCastVehicle;
					const currentTime = Date.now();

					if (inVehicle && vehicleAudioTransition < 1) {
						// Entering vehicle - start timer if not started
						if (vehicleTransitionStartTime === null) {
							vehicleTransitionStartTime = currentTime;
						}

						// Calculate progress based on time elapsed
						const elapsed = currentTime - vehicleTransitionStartTime;
						vehicleAudioTransition = Math.min(1, elapsed / VEHICLE_ENTER_DURATION);
					} else if (!inVehicle && vehicleAudioTransition > 0) {
						// Exiting vehicle - start timer if not started
						if (vehicleTransitionStartTime === null) {
							vehicleTransitionStartTime = currentTime;
						}

						// Calculate progress based on time elapsed
						const elapsed = currentTime - vehicleTransitionStartTime;
						vehicleAudioTransition = Math.max(0, 1 - (elapsed / VEHICLE_EXIT_DURATION));
					} else {
						// Transition complete, reset timer
						vehicleTransitionStartTime = null;
					}

					// Update directional lowpass based on position relative to speakers
					if (window.speakerPosition && window.speakerDirectionalLowpass && window.speakerDirectionalBass && window.world && window.positionalAudio) {
						const camera = window.world.camera;
						// Get the actual world direction the speaker is facing
						const speakerDir = new THREE.Vector3();
						window.positionalAudio.getWorldDirection(speakerDir);
						const toListener = new THREE.Vector3().subVectors(camera.position, window.speakerPosition).normalize();

						// Calculate angle between speaker direction and listener direction
						const angle = speakerDir.angleTo(toListener) * (180 / Math.PI);

						// Apply lowpass based on angle - INSTANT snap, no transition
						// 0-90° = clear (20kHz), 90-180° = BEHIND speakers (180° cone of distortion)
						if (angle < 90) {
							// Front hemisphere - crystal clear
							window.speakerDirectionalLowpass.frequency.value = 20000;
							window.speakerDirectionalBass.gain.value = 0;
						} else {
							// Behind speakers (entire rear 180°) - INSTANT heavy distortion
							window.speakerDirectionalLowpass.frequency.value = 200; // Heavy lowpass to 200Hz
							window.speakerDirectionalBass.gain.value = 18; // +18dB bass boost (clippy)
						}

						// Apply vehicle transition - apply lowpass filter when getting in car
						// Smoothly transition the vehicle lowpass filter based on vehicleAudioTransition
						if (window.eqFilters && window.eqFilters.vehicleLowpass) {
							// Main speakers: When vehicleAudioTransition = 0 (outside): freq = 20000 (no effect)
							//                When vehicleAudioTransition = 1 (inside): freq = 800 (heavy muffling)
							const targetFreq = 20000 - (vehicleAudioTransition * 19200);
							window.eqFilters.vehicleLowpass.frequency.value = targetFreq;
						}

						// Car audio: INVERSE of main speakers
						// When outside car (vehicleAudioTransition = 0): car audio is muffled (800Hz) and quieter
						// When inside car (vehicleAudioTransition = 1): car audio is clear (20000Hz) and full volume
						if (window.carEQ && window.carEQ.outsideLowpass) {
							const carTargetFreq = 800 + (vehicleAudioTransition * 19200);
							window.carEQ.outsideLowpass.frequency.value = carTargetFreq;
						}

						// Adjust car audio volume based on whether inside or outside
						// Outside (0): 30% volume, Inside (1): 100% volume
						if (window.carPositionalAudio) {
							const carVolume = 0.3 + (vehicleAudioTransition * 0.7);
							window.carPositionalAudio.setVolume(carVolume);
						}
					}

					// Update car debug visualizations to follow car
					if (window.car) {
						if (window.debugCarMarker) {
							window.debugCarMarker.position.copy(window.car.position);
						}
						if (window.debugCarArrow) {
							const carDir = new THREE.Vector3();
							window.car.getWorldDirection(carDir);
							window.debugCarArrow.position.copy(window.car.position);
							window.debugCarArrow.setDirection(carDir);
						}
						if (window.debugCarFrontCone) {
							const carFrontOffset = new THREE.Vector3(0, 0, 5);
							carFrontOffset.applyQuaternion(window.car.quaternion);
							window.debugCarFrontCone.position.copy(window.car.position).add(carFrontOffset);
							window.debugCarFrontCone.rotation.copy(window.car.rotation);
							window.debugCarFrontCone.rotation.x += -Math.PI / 2;
						}

						// Bass-reactive suspension - CONSTANT SUB SHAKE!
						if (inVehicle && window.carPositionalAudio && window.carPositionalAudio.isPlaying && window.audioAnalyser && character.controlledObject) {
							const frequencyData = new Uint8Array(window.audioAnalyser.frequencyBinCount);
							window.audioAnalyser.getByteFrequencyData(frequencyData);

							// Focus on DEEP SUB BASS (20Hz - 100Hz, roughly bins 0-10)
							let subBassSum = 0;
							const subBassRange = 10; // Focus on deepest frequencies
							for (let i = 0; i < subBassRange; i++) {
								subBassSum += frequencyData[i];
							}
							const subBassLevel = subBassSum / subBassRange / 255; // Normalize to 0-1

							// Get the vehicle's physics body
							const vehicle = character.controlledObject;
							const vehicleBody = vehicle.rayCastVehicle ? vehicle.rayCastVehicle.chassisBody : null;

							// CONSTANT SHAKING based on sub bass level - suspension wobble!
							if (subBassLevel > 0.1 && vehicleBody) { // Lower threshold
								// Scale shake intensity with bass level - MORE AGGRESSIVE
								const shakeIntensity = (subBassLevel - 0.1) * 200;

								// Apply TORQUE instead of impulse - makes it shake/wobble without moving position
								const randomTorqueX = (Math.random() - 0.5) * shakeIntensity;
								const randomTorqueY = (Math.random() - 0.5) * shakeIntensity * 0.3; // Less rotation around Y
								const randomTorqueZ = (Math.random() - 0.5) * shakeIntensity;

								// Apply angular (rotational) impulse - pure suspension shake!
								vehicleBody.torque.x += randomTorqueX;
								vehicleBody.torque.y += randomTorqueY;
								vehicleBody.torque.z += randomTorqueZ;

								// Also detect PEAKS for extra bounce on bass drops
								const bassDelta = subBassLevel - lastBassLevel;
								const timeSinceLastHit = currentTime - lastBassHitTime;
								const isPeak = bassDelta > 0.05 && subBassLevel > 0.3; // Lower thresholds
								const canHit = timeSinceLastHit > BASS_HIT_COOLDOWN;

								if (isPeak && canHit) {
									// EXTRA VERTICAL IMPULSE on bass drop - bigger bounce
									const bounceStrength = subBassLevel * 100;
									vehicleBody.applyImpulse(
										new CANNON.Vec3(0, bounceStrength, 0),
										new CANNON.Vec3(0, 0, 0)
									);
									lastBassHitTime = currentTime;
									console.log('💥 BASS DROP! Sub:', subBassLevel.toFixed(2), 'Bounce:', bounceStrength.toFixed(2));
								}
							}

							lastBassLevel = subBassLevel;
						}
					}
				}
			}, 100);

			// Handle ` (backtick) key for debug mode toggle
			document.addEventListener('keydown', (e) => {
				if (e.key === '`') {
					let isVisible = false;

					// Toggle speaker cones
					if (window.debugInnerCone && window.debugOuterCone && window.debugBackCone) {
						window.debugInnerCone.visible = !window.debugInnerCone.visible;
						window.debugOuterCone.visible = !window.debugOuterCone.visible;
						window.debugBackCone.visible = !window.debugBackCone.visible;
						isVisible = window.debugInnerCone.visible;
					}

					// Toggle speaker marker and arrow
					if (window.debugSpeakerMarker) {
						window.debugSpeakerMarker.visible = !window.debugSpeakerMarker.visible;
					}
					if (window.debugSpeakerArrow) {
						window.debugSpeakerArrow.visible = !window.debugSpeakerArrow.visible;
					}

					// Toggle car visualizations
					if (window.debugCarMarker) {
						window.debugCarMarker.visible = !window.debugCarMarker.visible;
					}
					if (window.debugCarArrow) {
						window.debugCarArrow.visible = !window.debugCarArrow.visible;
					}
					if (window.debugCarFrontCone) {
						window.debugCarFrontCone.visible = !window.debugCarFrontCone.visible;
					}

					console.log('🔍 Debug cones:', isVisible ? 'VISIBLE' : 'HIDDEN');

					// Show detailed debug info when toggling on
					if (isVisible && window.speakerPosition && window.world && window.positionalAudio) {
						const speakerDir = new THREE.Vector3();
						window.positionalAudio.getWorldDirection(speakerDir);

						console.log('═══════════════════════════════════');
						console.log('🔊 SPEAKER DEBUG INFO:');
						console.log('Speaker Position:', window.speakerPosition);
						console.log('Speaker Direction:', speakerDir);
						console.log('Inner Cone: 120° (Green)');
						console.log('Outer Cone: 230° (Yellow)');

						const camera = window.world.camera;
						const toListener = new THREE.Vector3().subVectors(camera.position, window.speakerPosition).normalize();
						const angle = speakerDir.angleTo(toListener) * (180 / Math.PI);

						console.log('═══════════════════════════════════');
						console.log('📍 YOUR POSITION:');
						console.log('Camera Position:', camera.position);
						console.log('Direction from Speaker:', toListener);
						console.log('Angle from Speaker Front:', angle.toFixed(1) + '°');

						if (angle < 120) {
							console.log('🟢 STATUS: FRONT of speaker (clear audio)');
						} else {
							console.log('🔴 STATUS: BEHIND speaker (muffled + bass boost)');
							const factor = (angle - 120) / 60;
							console.log('Muffling Factor:', (factor * 100).toFixed(1) + '%');
						}
						console.log('═══════════════════════════════════');
					}
				}
			});

			// Handle F key press
			document.addEventListener('keydown', (e) => {
				if (e.key === 'f' || e.key === 'F') {
					if (nearComputer && !terminalOpen && !customizationOpen) {
						// Prevent default F key behavior (vehicle entry)
						e.preventDefault();
						e.stopPropagation();
						e.stopImmediatePropagation();

						// Open OS
						window.terminalOpen = terminalOpen = true;
						osDiv.classList.add('active');
						interactionPrompt.classList.remove('show');

						// Disable character controls
						world.inputManager.inputReceiver = window.dummyInputReceiver;

						// Enable mouse cursor - exit pointer lock directly
						if (document.pointerLockElement) {
							document.exitPointerLock();
						}

						return false;
					}
				}
			}, true);

			// Handle R key press for radio
			document.addEventListener('keydown', (e) => {
				if (e.key === 'r' || e.key === 'R') {
					if (nearCar && !radioPromptDismissed) {
						// Dismiss the prompt
						radioPromptDismissed = true;
						interactionPrompt.classList.remove('show');
					}
				}
			}, true);

		}, 100);

		// ========== CAR RADIO FUNCTIONALITY ==========
		const RADIO_API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
			? 'http://localhost:3000'
			: window.location.origin; // Use same domain as the app (Vercel)

		// Shuffle array helper
		function radioShuffleArray(array) {
			const shuffled = [...array];
			for (let i = shuffled.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
			}
			return shuffled;
		}

		window.radioOpen = false;
	let radioOpen = window.radioOpen;
		let radioTracksData = [];
		let radioCurrentIndex = -1;
		const carRadioDiv = document.getElementById('car-radio');

		// Toggle car radio
		window.toggleCarRadio = function() {
			window.radioOpen = radioOpen = !radioOpen;
			if (radioOpen) {
				carRadioDiv.classList.add('active');
				// Show home screen, hide music app
				document.getElementById('phone-home').classList.remove('hidden');
				document.getElementById('phone-music-app').classList.remove('active');
				// Update phone time
				updatePhoneTime();
				// Exit pointer lock for UI interaction
				document.exitPointerLock();
				// Disable character controls
				if (window.character && window.dummyInputReceiver && window.world) {
					window.world.inputManager.inputReceiver = window.dummyInputReceiver;
				}
				// Load radio tracks if not loaded
				if (radioTracksData.length === 0) {
					loadRadioTracks();
				}
			} else {
				carRadioDiv.classList.remove('active');
				// Re-enable character controls
				if (window.character) {
					window.character.takeControl();
				}
			}
		};

		// Open phone app
		window.openPhoneApp = function(appName) {
			if (appName === 'music') {
				document.getElementById('phone-home').classList.add('hidden');
				document.getElementById('phone-music-app').classList.add('active');
			}
		};

		// Close music app back to home
		window.closePhoneApp = function() {
			document.getElementById('phone-music-app').classList.remove('active');
			document.getElementById('phone-home').classList.remove('hidden');
		};

		// Update phone time
		function updatePhoneTime() {
			const now = new Date();
			const hours = now.getHours();
			const minutes = now.getMinutes().toString().padStart(2, '0');
			document.getElementById('phone-time').textContent = `${hours}:${minutes}`;
		}

		// Click outside to close car radio
		document.addEventListener('click', (e) => {
			if (radioOpen && !customizationOpen) {
				// Check if click is outside the car radio menu
				if (!carRadioDiv.contains(e.target)) {
					window.toggleCarRadio();
				}
			}
		}, true);

		// Load tracks for radio
		function loadRadioTracks() {
			console.log('📻 Loading radio tracks from:', RADIO_API_BASE_URL);
			Promise.all([
				fetch(`${RADIO_API_BASE_URL}/api/v1/tracks`).then(r => r.json()),
				fetch(`${RADIO_API_BASE_URL}/api/v1/users`).then(r => r.json())
			])
			.then(([tracksResult, usersResult]) => {
				console.log('📻 Tracks result:', tracksResult);
				console.log('📻 Users result:', usersResult);

				if (tracksResult.success && tracksResult.data) {
					radioTracksData = tracksResult.data;
				}

				const usersData = usersResult.success ? usersResult.data : {};

				// Merge user data
				radioTracksData = radioTracksData.map(track => {
					if (track.user_id && usersData[track.user_id]) {
						const user = usersData[track.user_id];
						return {
							...track,
							artistName: user.displayName || user.username || 'Unknown Artist',
							artistUsername: user.username || null
						};
					}
					return {
						...track,
						artistName: 'Unknown Artist',
						artistUsername: null
					};
				});

				// Shuffle tracks for random order
				radioTracksData = radioShuffleArray(radioTracksData);

				console.log('📻 Loaded', radioTracksData.length, 'tracks');
				displayRadioTracks();
			})
			.catch(error => {
				console.error('Error loading radio tracks:', error);
				document.getElementById('radio-tracklist').innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">Failed to load tracks</div>';
			});
		}

		// Display tracks in radio (supports filtering)
		function displayRadioTracks(tracksToDisplay = radioTracksData) {
			const container = document.getElementById('radio-tracklist');
			container.innerHTML = tracksToDisplay.map((track, displayIndex) => {
				// Find the actual index in the full radioTracksData array
				const actualIndex = radioTracksData.indexOf(track);

				const artistDisplay = track.artistUsername
					? `<a href="https://www.sublair.com/u/${track.artistUsername}" target="_blank" class="artist-link" onclick="event.stopPropagation();">${track.artistName}</a>`
					: (track.artistName || 'Unknown Artist');

				return `
					<div class="car-radio-track-item ${actualIndex === radioCurrentIndex ? 'playing' : ''}" onclick="playRadioTrack(${actualIndex})">
						<div class="car-radio-track-number">${displayIndex + 1}</div>
						<div class="car-radio-track-details">
							<div class="car-radio-track-name">${track.title || 'Unknown'}</div>
							<div class="car-radio-track-meta">${artistDisplay} • ${track.genre || 'Unknown'}</div>
						</div>
					</div>
				`;
			}).join('');
		}

		// Phone search functionality
		document.getElementById('phone-search-input').addEventListener('input', (e) => {
			const query = e.target.value.toLowerCase();
			if (query === '') {
				displayRadioTracks();
			} else {
				const filtered = radioTracksData.filter(track =>
					(track.title && track.title.toLowerCase().includes(query)) ||
					(track.artistName && track.artistName.toLowerCase().includes(query)) ||
					(track.genre && track.genre.toLowerCase().includes(query))
				);
				displayRadioTracks(filtered);
			}
		});

		// Play track from radio
		window.playRadioTrack = function(index) {
			if (index < 0 || index >= radioTracksData.length) return;
			if (!window.carPositionalAudio) {
				console.error('Car audio system not ready');
				return;
			}

			radioCurrentIndex = index;
			const track = radioTracksData[index];

			// Update now playing display
			document.getElementById('radio-current-title').textContent = track.title || 'Unknown';

			const artistElement = document.getElementById('radio-current-artist');
			if (track.artistUsername) {
				artistElement.innerHTML = `<a href="https://www.sublair.com/u/${track.artistUsername}" target="_blank" class="artist-link">${track.artistName}</a>`;
			} else {
				artistElement.textContent = track.artistName || 'Unknown Artist';
			}

			// Update artwork
			const artElement = document.querySelector('.car-radio-mini-art');
			if (track.artwork_url) {
				artElement.style.backgroundImage = `url('${track.artwork_url}')`;
			} else {
				// Fallback gradient if no artwork
				artElement.style.backgroundImage = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
			}

			// Update play button
			document.getElementById('radio-play-btn').textContent = '⏸';

			// Update track list highlighting
			displayRadioTracks();

			// Stop current track if playing
			if (window.carPositionalAudio.isPlaying) {
				window.carPositionalAudio.stop();
			}

			// Build stream URL
			const streamUrl = `${RADIO_API_BASE_URL}/api/v1/stream/${track.id}`;
			console.log('🎵 Loading track from car radio:', track.title);

			// Load and play track through car's spatial audio
			const audioLoader = new THREE.AudioLoader();
			audioLoader.load(streamUrl, (buffer) => {
				window.carPositionalAudio.setBuffer(buffer);
				window.carPositionalAudio.setLoop(false);

				// Set volume based on current vehicle state
				// If outside car, start at 30%, if inside, start at 100%
				const inVehicle = window.character && window.character.controlledObject && window.character.controlledObject.rayCastVehicle;
				const initialVolume = inVehicle ? 1.0 : 0.3;
				window.carPositionalAudio.setVolume(initialVolume);

				// Connect to car-specific EQ chain (sounds like actual car speakers)
				const source = window.carPositionalAudio.getOutput();
				source.disconnect();

				// Car EQ chain: source → bass boost → low-mid cut → high-mid cut → treble rolloff → outside lowpass → analyser → destination
				source.connect(window.carEQ.bass);
				window.carEQ.bass.connect(window.carEQ.lowMid);
				window.carEQ.lowMid.connect(window.carEQ.highMid);
				window.carEQ.highMid.connect(window.carEQ.treble);
				window.carEQ.treble.connect(window.carEQ.outsideLowpass);
				window.carEQ.outsideLowpass.connect(window.audioAnalyser);
				window.audioAnalyser.connect(window.carPositionalAudio.context.destination);

				window.carPositionalAudio.play();
				window.carAudioSource = window.carPositionalAudio; // Store reference for controls

				// Auto-play next track when current one ends
				window.carPositionalAudio.onEnded = function() {
					console.log('🔄 Track ended, playing next...');
					window.radioSkipNext();
				};

				console.log('🚗 Playing from car:', track.title);
			}, undefined, (error) => {
				console.error('Error loading car radio track:', error);
			});
		};

		// Radio controls
		window.radioTogglePlay = function() {
			if (radioCurrentIndex === -1 && radioTracksData.length > 0) {
				playRadioTrack(0);
			} else {
				const btn = document.getElementById('radio-play-btn');
				if (window.carPositionalAudio) {
					if (btn.textContent === '▶') {
						window.carPositionalAudio.play();
						btn.textContent = '⏸';
					} else {
						window.carPositionalAudio.pause();
						btn.textContent = '▶';
					}
				}
			}
		};

		window.radioSkipNext = function() {
			if (radioTracksData.length === 0) return;
			const nextIndex = (radioCurrentIndex + 1) % radioTracksData.length;
			playRadioTrack(nextIndex);
		};

		window.radioSkipPrev = function() {
			if (radioTracksData.length === 0) return;
			const prevIndex = radioCurrentIndex - 1 < 0 ? radioTracksData.length - 1 : radioCurrentIndex - 1;
			playRadioTrack(prevIndex);
		};

		// ========== WELCOME SLIDESHOW ==========
		let currentSlide = 0;
		const totalSlides = 6;

		function updateSlide() {
			// Update slides
			document.querySelectorAll('.welcome-slide').forEach((slide, index) => {
				slide.classList.toggle('active', index === currentSlide);
			});

			// Update dots
			document.querySelectorAll('.welcome-dot').forEach((dot, index) => {
				dot.classList.toggle('active', index === currentSlide);
			});

			// Update buttons
			const prevBtn = document.getElementById('welcome-prev');
			const nextBtn = document.getElementById('welcome-next');
			const startBtn = document.getElementById('welcome-start');

			prevBtn.disabled = currentSlide === 0;

			if (currentSlide === totalSlides - 1) {
				nextBtn.style.display = 'none';
				startBtn.style.display = 'block';
			} else {
				nextBtn.style.display = 'block';
				startBtn.style.display = 'none';
			}
		}

		window.nextSlide = function() {
			if (currentSlide < totalSlides - 1) {
				currentSlide++;
				updateSlide();
			}
		};

		window.prevSlide = function() {
			if (currentSlide > 0) {
				currentSlide--;
				updateSlide();
			}
		};

		window.goToSlide = function(slideIndex) {
			currentSlide = slideIndex;
			updateSlide();
		};

		window.closeWelcome = function() {
			console.log('🎬 closeWelcome called');
			const welcomeOverlay = document.getElementById('welcome-overlay');
			console.log('welcomeOverlay element:', welcomeOverlay);
			welcomeOverlay.classList.remove('active');

			// Clear inline styles that were set by loading manager
			welcomeOverlay.style.opacity = '';
			welcomeOverlay.style.pointerEvents = '';
			welcomeOverlay.style.zIndex = '';

			console.log('Removed active class and cleared inline styles');

			// Set a flag in localStorage so it doesn't show again
			localStorage.setItem('welcomeShown', 'true');
		};

		// Click outside to close
		document.addEventListener('click', (e) => {
			if (customizationOpen) return; // Don't interfere with customization menu

			console.log('Click detected, target:', e.target);
			const welcomeOverlay = document.getElementById('welcome-overlay');
			const welcomeModal = document.querySelector('.welcome-modal');

			console.log('Welcome active?', welcomeOverlay.classList.contains('active'));
			console.log('Click inside modal?', welcomeModal.contains(e.target));

			if (welcomeOverlay.classList.contains('active') &&
			    !welcomeModal.contains(e.target)) {
				console.log('Calling closeWelcome from click outside');
				closeWelcome();
			}
		}, true);

		// Check if welcome has been shown before - DISABLED FOR NOW TO TEST
		// Uncomment the localStorage check once testing is complete
		/*
		window.addEventListener('load', () => {
			const welcomeShown = localStorage.getItem('welcomeShown');
			const welcomeOverlay = document.getElementById('welcome-overlay');

			if (welcomeShown === 'true') {
				welcomeOverlay.classList.remove('active');
			}
		});
		*/

	</script>
</body>

</html>
