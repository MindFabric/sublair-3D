<!DOCTYPE html>
<html>

<head>
	<title>SUBLAIR 3D</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Primary Meta Tags -->
	<meta name="title" content="SUBLAIR 3D">
	<meta name="description" content="The 3D Sublair experience. Discover music again.">
	<meta name="keywords" content="SUBLAIR, 3D world, music experience, interactive, virtual world">
	<meta name="author" content="SUBLAIR">

	<!-- Favicon -->
	<link rel="icon" type="image/png" href="/public/CIRCLE.png">

	<!-- Open Graph / Facebook -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://3d.sublair.com/">
	<meta property="og:title" content="SUBLAIR 3D">
	<meta property="og:description" content="The 3D Sublair experience. Discover music again.">
	<meta property="og:image" content="https://3d.sublair.com/public/social%20card.png">
	<meta property="og:image:width" content="1200">
	<meta property="og:image:height" content="630">
	<meta property="og:image:alt" content="SUBLAIR 3D - The 3D music experience">

	<!-- Twitter -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:url" content="https://3d.sublair.com/">
	<meta name="twitter:title" content="SUBLAIR 3D">
	<meta name="twitter:description" content="The 3D Sublair experience. Discover music again.">
	<meta name="twitter:image" content="https://3d.sublair.com/public/social%20card.png">

	<!-- Fonts -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Share:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}

		/* Fix z-index hierarchy */
		#canvas {
			position: fixed;
			top: 0;
			left: 0;
			z-index: 1;
		}

		#ui-container {
			z-index: 100 !important;
			pointer-events: none;
		}

		#ui-container * {
			pointer-events: auto;
		}

		/* Dark sleek customize button */
		.customize-button {
			position: fixed !important;
			bottom: 30px !important;
			right: 30px !important;
			background: rgba(0, 0, 0, 0.8) !important;
			color: #fff !important;
			border: 1px solid rgba(255, 255, 255, 0.2) !important;
			padding: 12px 24px !important;
			border-radius: 8px !important;
			font-family: 'Lucida Grande', 'Lucida Sans Unicode', Arial, sans-serif !important;
			font-size: 12px !important;
			font-weight: 600 !important;
			cursor: pointer !important;
			z-index: 10000 !important;
			backdrop-filter: blur(10px) !important;
			transition: all 0.2s ease !important;
			text-transform: uppercase !important;
			letter-spacing: 1px !important;
			pointer-events: auto !important;
		}

		.customize-button:hover {
			background: rgba(255, 255, 255, 0.15) !important;
			border-color: rgba(255, 255, 255, 0.4) !important;
			transform: translateY(-2px);
		}

		.customize-button:active {
			transform: translateY(0px);
		}

		.controls-panel {
			position: fixed !important;
			bottom: 90px !important;
			right: 30px !important;
			background: rgba(0, 0, 0, 0.8) !important;
			color: rgba(255, 255, 255, 0.8) !important;
			border: 1px solid rgba(255, 255, 255, 0.2) !important;
			padding: 16px !important;
			border-radius: 8px !important;
			font-family: 'Lucida Grande', 'Lucida Sans Unicode', Arial, sans-serif !important;
			font-size: 11px !important;
			z-index: 10000 !important;
			backdrop-filter: blur(10px) !important;
			pointer-events: none !important;
			line-height: 1.6 !important;
		}

		/* Floating OM Reward Animation */
		.om-reward {
			position: fixed;
			font-family: 'Share', 'Courier New', monospace;
			font-size: 32px;
			font-weight: bold;
			color: #bee17b;
			text-shadow: 0 0 10px rgba(190, 225, 123, 0.8),
						 0 0 20px rgba(190, 225, 123, 0.5),
						 2px 2px 4px rgba(0, 0, 0, 0.8);
			pointer-events: none;
			z-index: 10001;
			animation: floatUpOm 2s ease-out forwards;
		}

		@keyframes floatUpOm {
			0% {
				transform: translateY(0) scale(1);
				opacity: 1;
			}
			50% {
				transform: translateY(-80px) scale(1.2);
				opacity: 1;
			}
			100% {
				transform: translateY(-150px) scale(0.8);
				opacity: 0;
			}
		}

		/* Custom character menu - Compact LBP Style */
		.character-customization {
			position: fixed;
			top: 20px;
			left: 20px;
			background: rgba(0, 0, 0, 0.95);
			padding: 0;
			border-radius: 12px;
			font-family: 'Share Tech Mono', monospace;
			color: #bee17b;
			z-index: 99999;
			width: 320px;
			overflow: hidden;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.9),
						inset 0 0 0 1px rgba(190, 225, 123, 0.3),
						0 0 20px rgba(190, 225, 123, 0.1);
			opacity: 0;
			transform: translateY(-10px) scale(0.98);
			pointer-events: none;
			transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
		}

		.character-customization.active {
			opacity: 1;
			transform: translateY(0) scale(1);
			pointer-events: auto;
		}

		.character-customization h3 {
			margin: 0;
			padding: 12px 16px;
			font-size: 11px;
			font-weight: 400;
			letter-spacing: 3px;
			color: #bee17b;
			text-transform: uppercase;
			background: rgba(190, 225, 123, 0.1);
			border-bottom: 2px solid rgba(190, 225, 123, 0.3);
			text-align: center;
		}

		.customization-tabs {
			display: flex;
			gap: 0;
			background: rgba(0, 0, 0, 0.3);
			border-bottom: 1px solid rgba(190, 225, 123, 0.2);
		}

		.customization-tab {
			flex: 1;
			padding: 10px;
			background: transparent;
			border: none;
			color: rgba(190, 225, 123, 0.5);
			font-family: 'Share Tech Mono', monospace;
			font-size: 9px;
			letter-spacing: 1px;
			text-transform: uppercase;
			cursor: pointer;
			transition: all 0.2s ease;
			border-bottom: 2px solid transparent;
		}

		.customization-tab:hover {
			background: rgba(190, 225, 123, 0.05);
			color: rgba(190, 225, 123, 0.8);
		}

		.customization-tab.active {
			color: #bee17b;
			border-bottom-color: #bee17b;
			background: rgba(190, 225, 123, 0.1);
		}

		.customization-content {
			padding: 12px;
			max-height: 450px;
			overflow-y: auto;
		}

		.customization-content::-webkit-scrollbar {
			width: 4px;
		}

		.customization-content::-webkit-scrollbar-track {
			background: transparent;
		}

		.customization-content::-webkit-scrollbar-thumb {
			background: rgba(190, 225, 123, 0.3);
			border-radius: 2px;
		}

		.customization-content::-webkit-scrollbar-thumb:hover {
			background: rgba(190, 225, 123, 0.5);
		}

		.customization-section {
			margin-bottom: 12px;
			background: rgba(190, 225, 123, 0.05);
			padding: 10px;
			border-radius: 8px;
			border: 1px solid rgba(190, 225, 123, 0.15);
		}

		.customization-section:last-child {
			margin-bottom: 0;
		}

		.customization-footer {
			padding: 15px;
			border-top: 1px solid rgba(190, 225, 123, 0.2);
			display: flex;
			justify-content: center;
			background: rgba(0, 0, 0, 0.3);
		}

		.reset-defaults-button {
			padding: 10px 20px;
			background: rgba(190, 225, 123, 0.1);
			border: 1px solid rgba(190, 225, 123, 0.3);
			border-radius: 6px;
			color: #bee17b;
			font-family: 'Courier New', monospace;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.reset-defaults-button:hover {
			background: rgba(190, 225, 123, 0.2);
			border-color: #bee17b;
			transform: translateY(-1px);
		}

		.reset-defaults-button:active {
			transform: translateY(0);
		}

		.section-label {
			font-size: 9px;
			font-weight: 400;
			letter-spacing: 2px;
			color: #bee17b;
			margin-bottom: 8px;
			text-transform: uppercase;
			opacity: 0.8;
		}

		/* Collapsible sections */
		.collapsible-section {
			margin-bottom: 12px;
			border: 1px solid rgba(190, 225, 123, 0.2);
			border-radius: 8px;
			overflow: hidden;
			background: rgba(0, 0, 0, 0.3);
		}

		.collapsible-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 10px 12px;
			background: rgba(190, 225, 123, 0.1);
			cursor: pointer;
			user-select: none;
			transition: all 0.2s ease;
		}

		.collapsible-header:hover {
			background: rgba(190, 225, 123, 0.15);
		}

		.collapsible-title {
			font-size: 10px;
			font-weight: 600;
			letter-spacing: 2px;
			color: #bee17b;
			text-transform: uppercase;
		}

		.collapsible-arrow {
			font-size: 12px;
			color: #bee17b;
			transition: transform 0.2s ease;
		}

		.collapsible-section.collapsed .collapsible-arrow {
			transform: rotate(-90deg);
		}

		.collapsible-content {
			padding: 10px;
			max-height: 1000px;
			overflow-y: auto;
			transition: max-height 0.3s ease, padding 0.3s ease;
		}

		.collapsible-content::-webkit-scrollbar {
			width: 4px;
		}

		.collapsible-content::-webkit-scrollbar-track {
			background: transparent;
		}

		.collapsible-content::-webkit-scrollbar-thumb {
			background: rgba(190, 225, 123, 0.3);
			border-radius: 2px;
		}

		.collapsible-content::-webkit-scrollbar-thumb:hover {
			background: rgba(190, 225, 123, 0.5);
		}

		.collapsible-section.collapsed .collapsible-content {
			max-height: 0;
			padding: 0 10px;
		}

		.color-picker-container {
			display: flex;
			align-items: center;
			gap: 8px;
			margin-bottom: 8px;
			padding: 6px;
			background: rgba(0, 0, 0, 0.4);
			border-radius: 6px;
			border: 1px solid rgba(190, 225, 123, 0.2);
		}

		.color-picker-container input[type="color"] {
			width: 32px;
			height: 32px;
			border: 2px solid rgba(190, 225, 123, 0.3);
			border-radius: 6px;
			background: transparent;
			cursor: pointer;
			transition: all 0.15s ease;
		}

		.color-picker-container input[type="color"]:hover {
			border-color: #bee17b;
			transform: scale(1.08);
		}

		.color-picker-container input[type="color"]::-webkit-color-swatch-wrapper {
			padding: 0;
		}

		.color-picker-container input[type="color"]::-webkit-color-swatch {
			border: none;
			border-radius: 4px;
		}

		.color-info {
			flex: 1;
		}

		.color-info-label {
			font-size: 8px;
			text-transform: uppercase;
			letter-spacing: 1px;
			color: rgba(190, 225, 123, 0.6);
			margin-bottom: 2px;
		}

		.color-info-value {
			font-size: 11px;
			font-weight: 400;
			font-family: 'Share Tech Mono', monospace;
			color: #bee17b;
			letter-spacing: 1px;
		}

		.texture-grid {
			display: grid;
			grid-template-columns: repeat(4, 1fr);
			gap: 6px;
			margin-bottom: 8px;
		}

		.texture-option {
			aspect-ratio: 1;
			border-radius: 6px;
			cursor: pointer;
			border: 2px solid rgba(190, 225, 123, 0.25);
			transition: all 0.15s cubic-bezier(0.34, 1.56, 0.64, 1);
			position: relative;
			overflow: hidden;
			background: rgba(0, 0, 0, 0.3);
		}

		.texture-option.selected {
			border-color: #bee17b;
			box-shadow: 0 0 10px rgba(190, 225, 123, 0.4),
						inset 0 0 10px rgba(190, 225, 123, 0.1);
			transform: scale(1.05);
		}

		.texture-option:hover {
			transform: scale(1.08);
			border-color: rgba(190, 225, 123, 0.6);
		}

		.texture-controls {
			display: flex;
			flex-direction: column;
			gap: 6px;
			margin-top: 8px;
		}

		.control-row {
			display: flex;
			align-items: center;
			justify-content: space-between;
			background: rgba(0, 0, 0, 0.3);
			padding: 4px 8px;
			border-radius: 4px;
		}

		.control-row label {
			font-size: 8px;
			text-transform: uppercase;
			letter-spacing: 1px;
			color: rgba(190, 225, 123, 0.7);
			font-weight: 400;
			min-width: 50px;
		}

		.control-row input[type="range"] {
			flex: 1;
			margin: 0 8px;
			height: 2px;
			border-radius: 1px;
			background: rgba(190, 225, 123, 0.2);
			outline: none;
			-webkit-appearance: none;
		}

		.control-row input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 12px;
			height: 12px;
			border-radius: 50%;
			background: #bee17b;
			cursor: pointer;
			border: 2px solid rgba(0, 0, 0, 0.8);
			box-shadow: 0 0 4px rgba(190, 225, 123, 0.5);
		}

		.control-row input[type="range"]::-moz-range-thumb {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			background: #bee17b;
			cursor: pointer;
			border: 2px solid rgba(0, 0, 0, 0.8);
			box-shadow: 0 0 4px rgba(190, 225, 123, 0.5);
		}

		.control-value {
			font-size: 9px;
			color: #bee17b;
			font-weight: 400;
			min-width: 35px;
			text-align: right;
			font-family: 'Share Tech Mono', monospace;
			opacity: 0.8;
		}

		.preset-colors {
			display: grid;
			grid-template-columns: repeat(6, 1fr);
			gap: 10px;
		}

		.preset-color {
			aspect-ratio: 1;
			border-radius: 10px;
			cursor: pointer;
			border: 2.5px solid rgba(255, 255, 255, 0.15);
			transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
			position: relative;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
		}

		.preset-color::after {
			content: '';
			position: absolute;
			inset: 0;
			border-radius: 8px;
			background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 50%);
			opacity: 0;
			transition: opacity 0.25s ease;
		}

		.preset-color:hover::after {
			opacity: 1;
		}

		.preset-color.selected {
			border-color: #fff;
			box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3), 0 4px 16px rgba(0, 0, 0, 0.5);
			transform: scale(1.05);
		}

		.preset-color.selected::before {
			content: '✓';
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: rgba(255, 255, 255, 0.9);
			font-size: 14px;
			font-weight: bold;
			text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
		}

		.preset-color:hover {
			transform: scale(1.08);
			border-color: rgba(255, 255, 255, 0.4);
		}

		.preset-colors-label {
			font-size: 11px;
			text-transform: uppercase;
			letter-spacing: 0.5px;
			color: rgba(255, 255, 255, 0.4);
			margin-bottom: 10px;
		}

		/* OS Container */
		.terminal-login {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%) scale(0.9);
			background: rgba(0, 0, 0, 0.95);
			border: 4px solid #bee17b;
			border-radius: 0;
			padding: 0;
			font-family: 'Share', 'Courier New', monospace;
			color: #bee17b;
			z-index: 10000;
			width: 900px;
			height: 600px;
			opacity: 0;
			pointer-events: none;
			transition: all 0.3s ease;
			box-shadow: 0 0 30px rgba(190, 225, 123, 0.5);
			overflow: hidden;
		}

		/* OS Container Scrollbar (if needed) */
		.terminal-login::-webkit-scrollbar {
			width: 16px;
		}

		.terminal-login::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		.terminal-login::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		.terminal-login::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		/* Car Radio - iPhone Style */
		.car-radio {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%) scale(0.9);
			width: 380px;
			height: 650px;
			background: #000;
			border-radius: 40px;
			padding: 0;
			box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 0 0 1px rgba(255, 255, 255, 0.1);
			font-family: 'Share Tech Mono', monospace;
			color: #fff;
			z-index: 9999;
			opacity: 0;
			pointer-events: none;
			transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}

		.car-radio.active {
			opacity: 1;
			pointer-events: auto;
			transform: translate(-50%, -50%) scale(1);
		}

		/* Crosshair */
		.crosshair {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			width: 4px;
			height: 4px;
			background: white;
			border-radius: 50%;
			pointer-events: none;
			z-index: 1000;
			opacity: 0.8;
			box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
		}

		/* Phone Home Screen */
		.phone-home {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
			display: flex;
			flex-direction: column;
			opacity: 1;
			transition: opacity 0.3s ease;
			z-index: 1;
		}

		.phone-home.hidden {
			opacity: 0;
			pointer-events: none;
		}

		.phone-status-bar {
			padding: 12px 20px 8px 20px;
			display: flex;
			justify-content: space-between;
			font-size: 12px;
			color: rgba(255, 255, 255, 0.8);
			background: rgba(0, 0, 0, 0.3);
		}

		.phone-time {
			font-weight: 600;
		}

		.phone-icons {
			display: flex;
			gap: 6px;
		}

		.phone-app-grid {
			flex: 1;
			padding: 60px 30px 40px 30px;
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 35px;
			align-content: start;
		}

		.phone-app {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 8px;
			cursor: pointer;
			transition: transform 0.2s ease;
		}

		.phone-app:active {
			transform: scale(0.95);
		}

		.phone-app-icon {
			width: 64px;
			height: 64px;
			border-radius: 16px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 32px;
			background: linear-gradient(135deg, #bee17b 0%, #8cc63f 100%);
			box-shadow: 0 4px 12px rgba(190, 225, 123, 0.3);
			position: relative;
			overflow: hidden;
		}

		.phone-app-icon::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			height: 50%;
			background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 100%);
		}

		.phone-app-label {
			font-size: 12px;
			color: rgba(255, 255, 255, 0.9);
			text-align: center;
			font-weight: 500;
		}

		.phone-home-indicator {
			position: absolute;
			bottom: 8px;
			left: 50%;
			transform: translateX(-50%);
			width: 140px;
			height: 4px;
			background: rgba(255, 255, 255, 0.3);
			border-radius: 2px;
		}

		/* Music App Screen */
		.phone-music-app {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: #000;
			display: flex;
			flex-direction: column;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
			z-index: 2;
		}

		.phone-music-app.active {
			opacity: 1;
			pointer-events: auto;
		}

		.car-radio-header {
			padding: 50px 20px 16px 20px;
			background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
			position: relative;
			z-index: 10;
		}

		.phone-back-btn {
			position: absolute;
			top: 50px;
			left: 12px;
			width: 36px;
			height: 36px;
			border: none;
			background: rgba(255, 255, 255, 0.1);
			color: #bee17b;
			font-size: 32px;
			border-radius: 50%;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: background 0.2s ease;
			z-index: 20;
		}

		.phone-back-btn:hover {
			background: rgba(255, 255, 255, 0.2);
		}

		.phone-back-btn:active {
			transform: scale(0.95);
		}

		.car-radio-title {
			font-size: 32px;
			font-weight: 700;
			letter-spacing: -0.6px;
			color: #fff;
		}

		.car-radio-subtitle {
			font-size: 15px;
			color: rgba(255, 255, 255, 0.5);
			margin-top: 4px;
			font-weight: 500;
		}

		.phone-search-bar {
			padding: 12px 20px;
			background: rgba(0, 0, 0, 0.5);
			border-bottom: 1px solid rgba(255, 255, 255, 0.1);
		}

		.phone-search-bar input {
			width: 100%;
			background: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 10px;
			padding: 10px 14px;
			color: #fff;
			font-family: 'Share Tech Mono', monospace;
			font-size: 14px;
			outline: none;
			transition: all 0.2s ease;
		}

		.phone-search-bar input::placeholder {
			color: rgba(255, 255, 255, 0.4);
		}

		.phone-search-bar input:focus {
			background: rgba(255, 255, 255, 0.15);
			border-color: #bee17b;
		}

		.car-radio-content {
			flex: 1;
			overflow-y: auto;
			overflow-x: hidden;
			padding: 12px 20px 140px 20px;
			-webkit-overflow-scrolling: touch;
			overscroll-behavior: contain;
		}

		.car-radio-bottom-bar {
			position: absolute;
			bottom: 0;
			left: 0;
			right: 0;
			background: rgba(20, 20, 20, 0.95);
			backdrop-filter: blur(20px);
			border-top: 1px solid rgba(255, 255, 255, 0.1);
			padding: 12px 20px 32px 20px;
		}

		.car-radio-now-playing-mini {
			display: flex;
			align-items: center;
			gap: 12px;
			margin-bottom: 12px;
		}

		.car-radio-mini-art {
			width: 48px;
			height: 48px;
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			background-size: cover;
			background-position: center;
			border-radius: 8px;
			flex-shrink: 0;
		}

		.car-radio-mini-info {
			flex: 1;
			min-width: 0;
		}

		.car-radio-mini-title {
			font-size: 14px;
			font-weight: 600;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.car-radio-mini-artist {
			font-size: 12px;
			color: rgba(255, 255, 255, 0.5);
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.car-radio-controls {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 40px;
		}

		.car-radio-btn {
			background: none;
			border: none;
			color: #fff;
			font-size: 28px;
			cursor: pointer;
			transition: all 0.2s;
			width: 44px;
			height: 44px;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0.9;
		}

		.car-radio-btn:hover {
			opacity: 1;
			transform: scale(1.05);
		}

		.car-radio-btn.play-pause {
			width: 48px;
			height: 48px;
			background: rgba(255, 255, 255, 0.15);
			border-radius: 24px;
			font-size: 24px;
		}

		.car-radio-btn.play-pause:hover {
			background: rgba(255, 255, 255, 0.25);
		}

		.car-radio-content::-webkit-scrollbar {
			width: 0;
		}

		.car-radio-track-item {
			padding: 12px 0;
			cursor: pointer;
			transition: all 0.2s;
			display: flex;
			align-items: center;
			gap: 12px;
			border-bottom: 1px solid rgba(255, 255, 255, 0.05);
		}

		.car-radio-track-item:hover {
			opacity: 0.7;
		}

		.car-radio-track-item.playing {
			opacity: 1;
		}

		.car-radio-track-item.playing .car-radio-track-number {
			color: #667eea;
		}

		.car-radio-track-number {
			color: rgba(255, 255, 255, 0.4);
			font-size: 15px;
			min-width: 32px;
			font-weight: 500;
		}

		.car-radio-track-details {
			flex: 1;
			min-width: 0;
		}

		.car-radio-track-name {
			font-size: 16px;
			font-weight: 500;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			margin-bottom: 2px;
		}

		.car-radio-track-meta {
			font-size: 14px;
			color: rgba(255, 255, 255, 0.4);
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.car-radio-close {
			position: absolute;
			top: 20px;
			left: 20px;
			background: rgba(60, 60, 67, 0.6);
			backdrop-filter: blur(10px);
			border: none;
			color: #fff;
			width: 32px;
			height: 32px;
			border-radius: 16px;
			cursor: pointer;
			font-size: 20px;
			font-weight: 600;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: all 0.2s;
			z-index: 100;
		}

		.car-radio-close:hover {
			background: rgba(80, 80, 87, 0.8);
			transform: scale(1.05);
		}

		/* Welcome Slideshow */
		.welcome-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.95);
			z-index: 999999;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.4s ease;
		}

		.welcome-overlay.active {
			opacity: 1;
			pointer-events: auto;
		}

		.welcome-modal {
			background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
			border: 2px solid #bee17b;
			border-radius: 16px;
			width: 90%;
			max-width: 700px;
			max-height: 80vh;
			overflow: hidden;
			position: relative;
			box-shadow: 0 20px 60px rgba(190, 225, 123, 0.3);
			animation: slideIn 0.5s ease;
		}

		@keyframes slideIn {
			from {
				transform: translateY(-30px);
				opacity: 0;
			}
			to {
				transform: translateY(0);
				opacity: 1;
			}
		}

		.welcome-header {
			background: #000;
			border-bottom: 2px solid #bee17b;
			padding: 20px 24px;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.welcome-title {
			font-family: 'Share Tech Mono', monospace;
			font-size: 24px;
			font-weight: 700;
			color: #bee17b;
			letter-spacing: 2px;
			text-transform: uppercase;
		}

		.welcome-close {
			background: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.2);
			color: #fff;
			width: 32px;
			height: 32px;
			border-radius: 50%;
			cursor: pointer;
			font-size: 18px;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: all 0.2s ease;
		}

		.welcome-close:hover {
			background: rgba(255, 255, 255, 0.2);
			transform: rotate(90deg);
		}

		.welcome-content {
			padding: 40px;
			min-height: 350px;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			text-align: center;
		}

		.welcome-slide {
			display: none;
			animation: fadeIn 0.5s ease;
		}

		.welcome-slide.active {
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		@keyframes fadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}

		.welcome-icon {
			font-size: 64px;
			margin-bottom: 24px;
			filter: drop-shadow(0 4px 12px rgba(190, 225, 123, 0.4));
		}

		.welcome-slide h2 {
			font-family: 'Share Tech Mono', monospace;
			font-size: 28px;
			font-weight: 700;
			color: #bee17b;
			margin: 0 0 16px 0;
			letter-spacing: 1px;
		}

		.welcome-slide p {
			font-family: 'Share Tech Mono', monospace;
			font-size: 16px;
			line-height: 1.6;
			color: rgba(255, 255, 255, 0.8);
			margin: 0;
			max-width: 500px;
		}

		.welcome-footer {
			background: #000;
			border-top: 2px solid #bee17b;
			padding: 20px 24px;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.welcome-dots {
			display: flex;
			gap: 8px;
		}

		.welcome-dot {
			width: 10px;
			height: 10px;
			border-radius: 50%;
			background: rgba(255, 255, 255, 0.3);
			cursor: pointer;
			transition: all 0.3s ease;
		}

		.welcome-dot.active {
			background: #bee17b;
			transform: scale(1.2);
		}

		.welcome-dot:hover {
			background: rgba(190, 225, 123, 0.6);
		}

		.welcome-nav {
			display: flex;
			gap: 12px;
		}

		.welcome-btn {
			background: rgba(190, 225, 123, 0.15);
			border: 1px solid #bee17b;
			color: #bee17b;
			padding: 10px 20px;
			border-radius: 6px;
			font-family: 'Share Tech Mono', monospace;
			font-size: 14px;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.2s ease;
			text-transform: uppercase;
			letter-spacing: 1px;
		}

		.welcome-btn:hover {
			background: rgba(190, 225, 123, 0.25);
			transform: translateY(-2px);
		}

		.welcome-btn:disabled {
			opacity: 0.4;
			cursor: not-allowed;
			transform: none;
		}

		.welcome-btn.primary {
			background: #bee17b;
			color: #000;
		}

		.welcome-btn.primary:hover {
			background: #d4f098;
			box-shadow: 0 4px 12px rgba(190, 225, 123, 0.4);
		}

		/* OS View Scrollbar */
		.os-view::-webkit-scrollbar {
			width: 16px;
		}

		.os-view::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		.os-view::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		.os-view::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		.terminal-login.active {
			opacity: 1;
			pointer-events: auto;
			transform: translate(-50%, -50%) scale(1);
		}

		.os-container {
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		/* OS Taskbar */
		.os-taskbar {
			background: #000;
			border-bottom: 2px solid #bee17b;
			padding: 8px 16px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 20px;
		}

		.os-logo {
			font-weight: bold;
			font-size: 14px;
			color: #bee17b;
			text-transform: uppercase;
			letter-spacing: 1px;
		}

		.os-taskbar-apps {
			display: flex;
			gap: 0;
			flex: 1;
		}

		.taskbar-app {
			padding: 6px 12px;
			background: #000;
			border: 1px solid #bee17b;
			border-right: none;
			cursor: pointer;
			transition: all 0.1s ease;
			font-size: 12px;
			font-weight: bold;
		}

		.taskbar-app:last-child {
			border-right: 1px solid #bee17b;
		}

		.taskbar-app:hover {
			background: rgba(190, 225, 123, 0.2);
		}

		.taskbar-app.active {
			background: rgba(190, 225, 123, 0.3);
			color: #000;
			background: #bee17b;
		}

		.os-close {
			background: #000;
			color: #bee17b;
			padding: 6px 12px;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			transition: all 0.1s ease;
			font-weight: bold;
			border: 1px solid #bee17b;
		}

		.os-close:hover {
			background: #bee17b;
			color: #000;
		}

		/* OS Views */
		.os-view {
			flex: 1;
			overflow: hidden;
		}

		/* Desktop View */
		.desktop-split {
			position: relative;
			height: 100%;
			padding: 20px;
		}

		.desktop-icons {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
			gap: 20px;
			align-content: start;
			padding-bottom: 180px;
		}

		.desktop-icon {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 8px;
			cursor: pointer;
			padding: 15px;
			border: 2px solid transparent;
			transition: all 0.1s ease;
		}

		.desktop-icon:hover {
			border: 2px solid #bee17b;
			background: rgba(190, 225, 123, 0.1);
		}

		.desktop-icon .icon {
			font-size: 32px;
			font-weight: bold;
			color: #bee17b;
		}

		.desktop-icon .label {
			font-size: 11px;
			text-align: center;
			color: #bee17b;
			font-weight: bold;
		}

		/* Desktop Audio Player */
		.desktop-audio-player {
			position: absolute;
			bottom: 60px;
			left: 20px;
			right: 20px;
			border: 2px solid #bee17b;
			background: #000;
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}

		.audio-player-header {
			font-weight: bold;
			font-size: 12px;
			color: #000;
			background: #bee17b;
			text-transform: uppercase;
			padding: 10px 16px;
			letter-spacing: 1px;
		}

		.audio-player-body {
			display: flex;
			gap: 16px;
			padding: 16px;
			align-items: center;
		}

		.audio-album-art-container {
			flex-shrink: 0;
		}

		#desktop-album-art {
			width: 80px;
			height: 80px;
			background: #000;
			border: 2px solid #bee17b;
			display: flex;
			align-items: center;
			justify-content: center;
			color: #bee17b;
			font-size: 10px;
			background-size: cover;
			background-position: center;
			text-align: center;
		}

		.audio-info-controls {
			flex: 1;
			display: flex;
			flex-direction: column;
			gap: 8px;
			min-width: 0;
			padding: 12px 16px;
			background: #000;
			border: 1px solid #bee17b;
		}

		.track-title-display {
			font-size: 14px;
			color: #bee17b;
			font-family: 'Share', monospace;
			font-weight: bold;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.artist-name-display {
			font-size: 11px;
			color: #bee17b;
			font-family: 'Share', monospace;
			opacity: 0.8;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.artist-name-display a {
			color: #bee17b;
			text-decoration: underline;
			cursor: pointer;
		}

		.artist-name-display a:hover {
			opacity: 1;
			text-shadow: 0 0 10px rgba(190, 225, 123, 0.5);
		}

		.audio-status {
			font-size: 12px;
			color: #bee17b;
			padding: 12px 16px;
			border: 1px solid #bee17b;
			background: #000;
			flex: 1;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.audio-controls {
			display: flex;
			gap: 8px;
			flex-shrink: 0;
		}

		.audio-btn {
			background: #000;
			color: #bee17b;
			border: 1px solid #bee17b;
			padding: 10px 20px;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.1s ease;
			min-width: 100px;
		}

		/* OM Currency Display */
		.om-currency {
			background: #000;
			color: #bee17b;
			border: 1px solid #bee17b;
			border-right: none;
			padding: 6px 12px;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
			font-size: 12px;
			display: flex;
			align-items: center;
			gap: 6px;
		}

		.om-currency-symbol {
			color: #bee17b;
			font-size: 14px;
		}

		/* Profile Button */
		.desktop-profile-btn {
			background: #000;
			color: #bee17b;
			border: 1px solid #bee17b;
			border-right: none;
			padding: 6px 12px;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.1s ease;
		}

		.desktop-profile-btn:hover {
			background: rgba(190, 225, 123, 0.2);
		}

		/* Login Modal */
		.login-modal-overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.8);
			z-index: 10000;
			align-items: center;
			justify-content: center;
		}

		.login-modal-overlay.show {
			display: flex;
		}

		.login-modal-box {
			background: #000;
			border: 2px solid #bee17b;
			width: 400px;
			max-width: 90%;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
		}

		.login-modal-header {
			background: #bee17b;
			color: #000;
			padding: 12px 16px;
			font-weight: bold;
			font-size: 13px;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.login-modal-close {
			background: none;
			border: none;
			color: #000;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
			font-size: 14px;
			cursor: pointer;
			padding: 0;
		}

		.login-modal-body {
			padding: 24px;
		}

		.login-form-group {
			margin-bottom: 16px;
		}

		.login-form-group label {
			display: block;
			color: #bee17b;
			font-size: 11px;
			font-weight: bold;
			margin-bottom: 6px;
			letter-spacing: 1px;
		}

		.login-form-group input {
			width: 100%;
			background: #000;
			border: 1px solid #bee17b;
			color: #bee17b;
			padding: 10px;
			font-family: 'Share', 'Courier New', monospace;
			font-size: 12px;
			box-sizing: border-box;
		}

		.login-form-group input:focus {
			outline: none;
			border-color: #bee17b;
			box-shadow: 0 0 0 2px rgba(190, 225, 123, 0.2);
		}

		.login-submit-btn {
			width: 100%;
			background: #bee17b;
			color: #000;
			border: none;
			padding: 12px;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.1s ease;
			letter-spacing: 1px;
		}

		.login-submit-btn:hover {
			background: #a8cc6b;
		}

		.login-error {
			color: #ff6b6b;
			font-size: 11px;
			margin-top: 12px;
			display: none;
		}

		.login-error.show {
			display: block;
		}

		.audio-btn:hover:not(:disabled) {
			background: #bee17b;
			color: #000;
		}

		.audio-btn:disabled {
			opacity: 0.3;
			cursor: not-allowed;
		}

		/* Delete Message Button */
		.delete-msg-btn:hover {
			background: #f00 !important;
			color: #000 !important;
		}

		/* App Window */
		.app-window {
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		.app-header {
			background: #000;
			border-bottom: 2px solid #bee17b;
			padding: 10px 20px;
			display: flex;
			align-items: center;
			gap: 15px;
		}

		.app-title {
			font-weight: bold;
			font-size: 13px;
			color: #bee17b;
			text-transform: uppercase;
			letter-spacing: 1px;
		}

		.app-content {
			flex: 1;
			overflow-y: auto;
			padding: 20px;
			background: #000;
		}

		/* File Details Panel Scrollbar */
		#file-details-panel {
			scrollbar-width: thin;
			scrollbar-color: #bee17b #111;
		}

		#file-details-panel::-webkit-scrollbar {
			width: 8px;
		}

		#file-details-panel::-webkit-scrollbar-track {
			background: #111;
			border-left: 1px solid #333;
		}

		#file-details-panel::-webkit-scrollbar-thumb {
			background: #bee17b;
			border-radius: 0;
		}

		#file-details-panel::-webkit-scrollbar-thumb:hover {
			background: #d4f19b;
		}

		.file-path {
			font-size: 11px;
			color: #bee17b;
			background: #000;
			padding: 4px 10px;
			border: 1px solid #bee17b;
			font-family: 'Share', 'Courier New', monospace;
			font-weight: bold;
		}

		/* Folder Items */
		.folder-item {
			padding: 10px 15px;
			margin: 4px 0;
			border: 1px solid #bee17b;
			cursor: pointer;
			transition: all 0.1s ease;
			background: #000;
			display: flex;
			align-items: center;
			gap: 10px;
			font-size: 13px;
			font-weight: bold;
		}

		.folder-item:hover {
			background: #bee17b;
			color: #000;
		}

		.folder-icon {
			font-size: 13px;
			font-weight: bold;
		}

		.terminal-header {
			text-align: center;
			margin-bottom: 30px;
			font-size: 24px;
			font-weight: 800;
			color: #bee17b;
			text-transform: uppercase;
			letter-spacing: 2px;
			padding-bottom: 20px;
			border-bottom: 3px solid #bee17b;
		}

		.terminal-input-group {
			margin-bottom: 20px;
		}

		.terminal-input-group label {
			display: block;
			margin-bottom: 8px;
			font-size: 12px;
			font-weight: 700;
			text-transform: uppercase;
			letter-spacing: 1px;
			color: #bee17b;
		}

		.terminal-input-group input {
			width: 100%;
			background: rgba(255, 255, 255, 0.1);
			border: 2px solid rgba(190, 225, 123, 0.3);
			color: #fff;
			padding: 14px 16px;
			font-family: 'Share', 'Courier New', monospace;
			font-size: 15px;
			box-sizing: border-box;
			border-radius: 12px;
			transition: all 0.3s ease;
		}

		.terminal-input-group input:focus {
			outline: none;
			border-color: #bee17b;
			background: rgba(255, 255, 255, 0.15);
			box-shadow: 0 0 20px rgba(190, 225, 123, 0.3);
			transform: translateY(-2px);
		}

		.terminal-input-group input::placeholder {
			color: rgba(255, 255, 255, 0.4);
		}

		.terminal-buttons {
			display: flex;
			gap: 12px;
			margin-top: 30px;
		}

		.terminal-button {
			flex: 1;
			background: rgba(255, 255, 255, 0.1);
			border: 2px solid #bee17b;
			color: #bee17b;
			padding: 14px 24px;
			font-family: 'Share', 'Courier New', monospace;
			cursor: pointer;
			transition: all 0.3s ease;
			text-transform: uppercase;
			font-weight: 700;
			font-size: 13px;
			letter-spacing: 1px;
			border-radius: 12px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
		}

		.terminal-button:hover {
			background: #bee17b;
			color: #000;
			transform: translateY(-2px);
			box-shadow: 0 6px 20px rgba(190, 225, 123, 0.4);
		}

		.terminal-button:active {
			transform: translateY(0px);
		}

		.terminal-error {
			color: #ff6b6b;
			font-size: 13px;
			margin-top: 15px;
			text-align: center;
			display: none;
			font-weight: 600;
			background: rgba(255, 107, 107, 0.1);
			padding: 10px;
			border-radius: 8px;
		}

		.terminal-error.show {
			display: block;
			animation: shake 0.4s ease;
		}

		@keyframes shake {
			0%, 100% { transform: translateX(0); }
			25% { transform: translateX(-10px); }
			75% { transform: translateX(10px); }
		}

		/* Track List Styles */
		#tracks-container {
			max-height: 450px;
			overflow-y: auto;
			margin: 0;
			padding: 0;
		}

		#tracks-container::-webkit-scrollbar {
			width: 16px;
		}

		#tracks-container::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		#tracks-container::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		#tracks-container::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		/* File Explorer Scrollbar */
		#file-explorer::-webkit-scrollbar {
			width: 16px;
		}

		#file-explorer::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		#file-explorer::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		#file-explorer::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		/* App Content Scrollbar */
		.app-content::-webkit-scrollbar {
			width: 16px;
		}

		.app-content::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		.app-content::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		.app-content::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		/* Chat Messages Scrollbar (Multiplayer) */
		#chat-messages::-webkit-scrollbar {
			width: 16px;
		}

		#chat-messages::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		#chat-messages::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		#chat-messages::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		/* OS Chat Messages Scrollbar */
		#os-chat-messages::-webkit-scrollbar {
			width: 16px;
		}

		#os-chat-messages::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		#os-chat-messages::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		#os-chat-messages::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		/* Firefox support */
		#os-chat-messages {
			scrollbar-width: thin;
			scrollbar-color: #bee17b #000;
		}

		/* Online Users Scrollbar */
		#online-users::-webkit-scrollbar {
			width: 16px;
		}

		#online-users::-webkit-scrollbar-track {
			background: #000;
			border-left: 1px solid #bee17b;
		}

		#online-users::-webkit-scrollbar-thumb {
			background: #bee17b;
			border: 2px solid #000;
		}

		#online-users::-webkit-scrollbar-thumb:hover {
			background: #d4f098;
		}

		.track-item {
			padding: 15px;
			margin: 8px 0;
			border: 2px solid rgba(190, 225, 123, 0.3);
			border-radius: 12px;
			cursor: pointer;
			transition: all 0.2s ease;
			background: rgba(255, 255, 255, 0.02);
		}

		.track-item:hover {
			background: rgba(190, 225, 123, 0.15);
			border-color: #bee17b;
			transform: translateX(5px);
		}

		.artist-link {
			color: #bee17b;
			text-decoration: none;
		}

		.artist-link:hover {
			text-decoration: underline;
		}

		.track-title {
			font-weight: bold;
			color: #bee17b;
			font-size: 16px;
			margin-bottom: 5px;
		}

		.track-meta {
			font-size: 12px;
			color: #888;
			text-transform: uppercase;
		}

		#search-input {
			width: 100%;
			background: rgba(255, 255, 255, 0.1);
			border: 2px solid rgba(190, 225, 123, 0.3);
			color: #fff;
			padding: 14px 16px;
			font-family: 'Share', 'Courier New', monospace;
			font-size: 15px;
			box-sizing: border-box;
			border-radius: 12px;
			margin-bottom: 15px;
			transition: all 0.3s ease;
		}

		#search-input:focus {
			outline: none;
			border-color: #bee17b;
			background: rgba(255, 255, 255, 0.15);
			box-shadow: 0 0 20px rgba(190, 225, 123, 0.3);
		}

		#search-input::placeholder {
			color: rgba(190, 225, 123, 0.5);
		}

		/* Audio Loading Indicator */
		#audio-loading {
			position: fixed;
			bottom: 30px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.9);
			border: 2px solid #bee17b;
			color: #bee17b;
			padding: 15px 30px;
			border-radius: 12px;
			font-family: 'Share', 'Courier New', monospace;
			font-size: 14px;
			z-index: 9999;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
			backdrop-filter: blur(10px);
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
		}

		#audio-loading.show {
			opacity: 1;
		}

		/* Interaction Prompt */
		.interaction-prompt {
			position: fixed;
			bottom: 120px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.8);
			color: #fff;
			padding: 12px 24px;
			border-radius: 8px;
			font-family: 'Lucida Grande', 'Lucida Sans Unicode', Arial, sans-serif;
			font-size: 14px;
			z-index: 9999;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
			border: 2px solid rgba(255, 255, 255, 0.3);
		}

		.interaction-prompt.show {
			opacity: 1;
		}

		.interaction-prompt kbd {
			background: #333;
			border: 1px solid #555;
			border-radius: 4px;
			padding: 4px 8px;
			margin: 0 4px;
			font-weight: bold;
		}

		/* CRT Scanline Overlay - DISABLED (spectators are now full characters) */
		#crt-overlay {
			display: none !important;
		}

		/* Grain Overlay - hidden, now in shader */
		#grain-overlay {
			display: none;
		}

		/* CRT Camera UI - DISABLED (spectators are now full characters) */
		#crt-ui {
			display: none !important;
		}

		#crt-ui.visible {
			display: none !important;
		}

		#rec-indicator {
			display: flex;
			align-items: center;
			gap: 8px;
			margin-bottom: 5px;
		}

		#rec-dot {
			width: 12px;
			height: 12px;
			background: #ff0000;
			border-radius: 50%;
			animation: blink 1s infinite;
		}

		@keyframes blink {
			0%, 49% { opacity: 1; }
			50%, 100% { opacity: 0; }
		}

		#timestamp {
			font-size: 16px;
			letter-spacing: 1px;
		}

		/* CRT Engine Credit */
		#crt-engine-credit {
			position: fixed;
			top: 20px;
			right: 20px;
			font-family: 'Share', 'Courier New', monospace;
			color: #bee17b;
			font-size: 11px;
			z-index: 99999;
			pointer-events: auto;
			background: rgba(0, 0, 0, 0.7);
			padding: 4px 8px;
			border: 1px solid #bee17b;
			opacity: 0.7;
		}

		#crt-engine-credit a {
			color: #bee17b;
			text-decoration: none;
		}

		#crt-engine-credit a:hover {
			text-decoration: underline;
		}

		/* EQ Slider Styles - DOS aesthetic */
		#eq-view input[type="range"] {
			-webkit-appearance: none;
			appearance: none;
			width: 100%;
			height: 6px;
			background: #000;
			border: 2px solid #bee17b;
			outline: none;
			cursor: pointer;
		}

		#eq-view input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 20px;
			height: 20px;
			background: #bee17b;
			border: 2px solid #000;
			cursor: pointer;
			box-shadow: 0 0 5px rgba(190, 225, 123, 0.5);
		}

		#eq-view input[type="range"]::-moz-range-thumb {
			width: 20px;
			height: 20px;
			background: #bee17b;
			border: 2px solid #000;
			cursor: pointer;
			box-shadow: 0 0 5px rgba(190, 225, 123, 0.5);
		}

		#eq-view input[type="range"]:hover::-webkit-slider-thumb {
			background: #d4f098;
		}

		#eq-view input[type="range"]:hover::-moz-range-thumb {
			background: #d4f098;
		}

		/* Now Playing Display - Top Middle */
		#now-playing-display {
			position: fixed;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
			z-index: 10000;
			pointer-events: none;
			display: none; /* Hidden by default */
			opacity: 0;
			transition: opacity 0.5s ease;
		}

		#now-playing-display.show {
			display: flex;
			opacity: 1;
		}

		.now-playing-container {
			display: flex;
			align-items: center;
			gap: 16px;
			background: rgba(0, 0, 0, 0.85);
			border: 2px solid #bee17b;
			padding: 12px 20px;
			font-family: 'Share Tech Mono', monospace;
			box-shadow: 0 4px 20px rgba(190, 225, 123, 0.3);
			backdrop-filter: blur(10px);
			max-width: 600px;
		}

		.now-playing-artwork {
			width: 50px;
			height: 50px;
			border: 2px solid #bee17b;
			background: #000;
			flex-shrink: 0;
			overflow: hidden;
		}

		.now-playing-artwork img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.now-playing-info {
			flex: 1;
			min-width: 0; /* Allow text truncation */
		}

		.now-playing-label {
			font-size: 10px;
			color: #bee17b;
			opacity: 0.7;
			text-transform: uppercase;
			letter-spacing: 1px;
			margin-bottom: 4px;
		}

		.now-playing-title {
			font-size: 16px;
			color: #bee17b;
			font-weight: bold;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			margin-bottom: 4px;
		}

		.now-playing-artist {
			font-size: 12px;
			color: #bee17b;
			opacity: 0.8;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.now-playing-title a {
			color: inherit;
			text-decoration: none;
			transition: opacity 0.2s;
		}

		.now-playing-title a:hover {
			opacity: 0.8;
			text-decoration: underline;
		}

		.now-playing-artist a {
			color: #bee17b;
			text-decoration: none;
			transition: opacity 0.2s;
		}

		.now-playing-artist a:hover {
			opacity: 1;
			text-decoration: underline;
		}

		.now-playing-pulse {
			width: 20px;
			height: 20px;
			background: #bee17b;
			border-radius: 50%;
			animation: pulse 1.5s ease-in-out infinite;
			flex-shrink: 0;
		}

		@keyframes pulse {
			0%, 100% {
				opacity: 1;
				transform: scale(1);
			}
			50% {
				opacity: 0.5;
				transform: scale(0.8);
			}
		}

		/* Floating name tags above characters */
		.name-tag {
			position: fixed;
			color: #fff;
			background: rgba(0, 0, 0, 0.5);
			padding: 4px 8px;
			border-radius: 4px;
			font-family: 'Share', Arial, sans-serif;
			font-size: 14px;
			font-weight: 700;
			text-align: center;
			pointer-events: none;
			text-shadow:
				2px 2px 4px rgba(0, 0, 0, 0.8),
				-1px -1px 2px rgba(0, 0, 0, 0.8),
				1px -1px 2px rgba(0, 0, 0, 0.8),
				-1px 1px 2px rgba(0, 0, 0, 0.8);
			z-index: 999999;
			white-space: nowrap;
			user-select: none;
			transform: translate(-50%, -50%);
		}
	</style>
</head>

<body>
	<!-- Welcome Slideshow -->
	<div id="welcome-overlay" class="welcome-overlay active">
		<div class="welcome-modal">
			<div class="welcome-header">
				<div class="welcome-title">Welcome to SUBLAIR 3D</div>
				<button class="welcome-close" onclick="closeWelcome()">✕</button>
			</div>
			<div class="welcome-content">
				<!-- Slide 1 -->
				<div class="welcome-slide active" data-slide="0">
					<img src="public/BRAND.png" alt="SUBLAIR" style="max-width: 200px; margin-bottom: 24px;">
					<h2>>_SUBLAIR-3D</h2>
					<p>Welcome to SUBLAIR 3D - an immersive music experience where you explore, discover, and interact with music in a fully realized 3D world.</p>
				</div>
				<!-- Slide 2 -->
				<div class="welcome-slide" data-slide="1">
					<h2>Explore the World</h2>
					<p>Use <strong>WASD</strong> to move, <strong>SHIFT</strong> to sprint, and <strong>SPACE</strong> to jump. Hold <strong>E</strong> for aim mode with over-the-shoulder view. Press <strong>F</strong> to enter vehicles and interact with objects. Click to lock your cursor and look around.</p>
				</div>
				<!-- Slide 3 -->
				<div class="welcome-slide" data-slide="2">
					<h2>Interactive Computer</h2>
					<p>Walk up to the computer terminal and press <strong>F</strong> to access the SUBLAIR OS. Browse music, adjust the EQ, and control playback with a retro DOS-inspired interface.</p>
				</div>
				<!-- Slide 4 -->
				<div class="welcome-slide" data-slide="3">
					<h2>Car Radio</h2>
					<p>Get into any vehicle and press <strong>R</strong> to open your phone. Access the full music library on-the-go with a sleek mobile interface.</p>
				</div>
				<!-- Slide 5 -->
				<div class="welcome-slide" data-slide="4">
					<h2>Customize Your Character</h2>
					<p>Press <strong>C</strong> anytime to customize your character's appearance. Change colors, patterns, and textures to make your avatar truly unique.</p>
				</div>
				<!-- Slide 6 -->
				<div class="welcome-slide" data-slide="5">
					<h2>Welcome to the Underground</h2>
					<p>This is just the beginning. SUBLAIR 3D is in active development - a disruptive vision of what music discovery can be.</p>
					<p style="margin-top: 16px; font-style: italic; opacity: 0.7;">Think big. Think disruptive. The network beneath.</p>
					<p style="margin-top: 24px; font-size: 14px; opacity: 0.5; text-align: center;">-MF</p>
				</div>
			</div>
			<div class="welcome-footer">
				<div class="welcome-dots">
					<div class="welcome-dot active" onclick="goToSlide(0)"></div>
					<div class="welcome-dot" onclick="goToSlide(1)"></div>
					<div class="welcome-dot" onclick="goToSlide(2)"></div>
					<div class="welcome-dot" onclick="goToSlide(3)"></div>
					<div class="welcome-dot" onclick="goToSlide(4)"></div>
					<div class="welcome-dot" onclick="goToSlide(5)"></div>
				</div>
				<div class="welcome-nav">
					<button class="welcome-btn" id="welcome-prev" onclick="prevSlide()" disabled>Previous</button>
					<button class="welcome-btn" id="welcome-next" onclick="nextSlide()">Next</button>
					<button class="welcome-btn primary" id="welcome-start" onclick="closeWelcome()" style="display: none;">Let's Go!</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Spectator Loading Overlay (only shown when joining via URL) -->
	<div id="spectator-loading" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10000; display: none; align-items: center; justify-content: center; flex-direction: column;">
		<div style="font-family: 'Share', monospace; color: #bee17b; text-align: center;">
			<div style="font-size: 24px; margin-bottom: 20px; letter-spacing: 2px;">
				[CONNECTING TO SESSION]
			</div>
			<div style="font-size: 48px; margin-bottom: 20px; animation: spin 1s linear infinite;">
				⟳
			</div>
			<div id="spectator-loading-status" style="font-size: 14px; opacity: 0.8; color: #bee17b;">
				Establishing connection...
			</div>
		</div>
	</div>

	<!-- Host Disconnected Modal -->
	<div id="host-disconnected-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 10000; display: none; align-items: center; justify-content: center; flex-direction: column;">
		<div style="font-family: 'Share', monospace; color: #bee17b; text-align: center; border: 2px solid #bee17b; padding: 40px; background: #000; max-width: 500px;">
			<div style="font-size: 32px; margin-bottom: 20px; letter-spacing: 2px; color: #ff4444;">
				[SESSION ENDED]
			</div>
			<div style="font-size: 16px; margin-bottom: 30px; line-height: 1.6;">
				The host has disconnected.<br>
				The session has been closed.
			</div>
			<button id="return-home-btn" style="background: #bee17b; color: #000; border: none; padding: 12px 30px; font-family: 'Share', monospace; font-size: 14px; cursor: pointer; letter-spacing: 1px; transition: all 0.2s;">
				[RETURN TO HOME]
			</button>
		</div>
	</div>

	<style>
		@keyframes spin {
			from { transform: rotate(0deg); }
			to { transform: rotate(360deg); }
		}

		#return-home-btn:hover {
			background: #fff;
			transform: scale(1.05);
		}
	</style>

	<!-- CRT Scanline Overlay -->
	<div id="crt-overlay"></div>

	<!-- Grain Overlay -->
	<div id="grain-overlay"></div>

	<!-- Crosshair (hidden by default) -->
	<div class="crosshair" id="crosshair" style="display: none;"></div>

	<!-- Now Playing Display (top middle) -->
	<div id="now-playing-display">
		<div class="now-playing-container">
			<div class="now-playing-artwork">
				<img id="now-playing-artwork-img" src="" alt="Album Art">
			</div>
			<div class="now-playing-info">
				<div class="now-playing-label">NOW PLAYING</div>
				<div class="now-playing-title" id="now-playing-title">Track Title</div>
				<div class="now-playing-artist" id="now-playing-artist">Artist Name</div>
			</div>
			<div class="now-playing-pulse"></div>
		</div>
	</div>

	<!-- Multiplayer Chat (bottom left) -->
	<div id="multiplayer-chat" style="display: none; position: fixed; bottom: 20px; left: 20px; width: 400px; max-height: 300px; z-index: 1000;">
		<!-- Chat messages container (always visible in multiplayer) -->
		<div id="chat-messages" style="background: rgba(0, 0, 0, 0.85); border: 2px solid #bee17b; padding: 15px; font-family: 'Share Tech Mono', monospace; color: #bee17b; font-size: 13px; max-height: 200px; overflow-y: auto; margin-bottom: 10px; display: none;">
			<!-- Messages will be added here -->
		</div>

		<!-- Chat input (shown when T is pressed) -->
		<div id="chat-input-container" style="display: none; background: rgba(0, 0, 0, 0.85); border: 2px solid #bee17b; padding: 10px;">
			<div style="display: flex; gap: 10px; align-items: center;">
				<input type="text" id="chat-input" placeholder="Type message... (ESC to close)" maxlength="200" style="flex: 1; background: #000; border: 1px solid #bee17b; color: #bee17b; font-family: 'Share Tech Mono', monospace; font-size: 13px; padding: 8px; outline: none;" />
			</div>
		</div>
	</div>

	<!-- Multiplayer Player Viewer (Press Y) -->
	<div id="player-viewer" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; z-index: 2000; background: rgba(0, 0, 0, 0.95); border: 2px solid #bee17b; font-family: 'Share Tech Mono', monospace;">
		<!-- Header -->
		<div style="background: #bee17b; color: #000; padding: 15px; text-align: center; font-size: 16px; letter-spacing: 2px; font-weight: bold;">
			[MULTIPLAYER SESSION]
		</div>

		<!-- Player List Table -->
		<div style="padding: 20px;">
			<table style="width: 100%; border-collapse: collapse; color: #bee17b;">
				<thead>
					<tr style="border-bottom: 2px solid #bee17b;">
						<th style="text-align: left; padding: 10px; font-size: 12px; letter-spacing: 1px;">PLAYER</th>
						<th style="text-align: center; padding: 10px; font-size: 12px; letter-spacing: 1px;">ROLE</th>
						<th style="text-align: center; padding: 10px; font-size: 12px; letter-spacing: 1px;">LATENCY</th>
					</tr>
				</thead>
				<tbody id="player-list-body" style="font-size: 13px;">
					<!-- Players will be added here -->
				</tbody>
			</table>
		</div>

		<!-- Footer -->
		<div style="padding: 15px; text-align: center; border-top: 1px solid #bee17b; color: #888; font-size: 11px;">
			Press Y to close • Session Code: <span id="viewer-session-code">------</span>
		</div>
	</div>

	<!-- Car Radio Interface (Phone) -->
	<div id="car-radio" class="car-radio">
		<button class="car-radio-close" onclick="window.toggleCarRadio()">˅</button>

		<!-- Phone Home Screen -->
		<div id="phone-home" class="phone-home">
			<div class="phone-status-bar">
				<div class="phone-time" id="phone-time">9:41</div>
				<div class="phone-icons">
					<span>📶</span>
					<span>📡</span>
					<span>🔋</span>
				</div>
			</div>

			<div class="phone-app-grid">
				<div id="phone-music-icon" class="phone-app" onclick="openPhoneApp('music')">
					<div class="phone-app-icon">
						<img src="public/CIRCLE.png" alt="SUBLAIR" style="width: 100%; height: 100%; object-fit: cover; border-radius: 18px;">
					</div>
					<div class="phone-app-label">SUBLAIR</div>
				</div>
				<div class="phone-app" onclick="openPhoneApp('messenger')">
					<div class="phone-app-icon" style="background: linear-gradient(135deg, #00c6ff 0%, #0072ff 100%); display: flex; align-items: center; justify-content: center;">
						<svg width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M20 2H4C2.9 2 2 2.9 2 4V22L6 18H20C21.1 18 22 17.1 22 16V4C22 2.9 21.1 2 20 2ZM20 16H6L4 18V4H20V16Z" fill="white"/>
							<circle cx="8" cy="10" r="1.5" fill="white"/>
							<circle cx="12" cy="10" r="1.5" fill="white"/>
							<circle cx="16" cy="10" r="1.5" fill="white"/>
						</svg>
					</div>
					<div class="phone-app-label">Messenger</div>
				</div>
				<div class="phone-app" onclick="openPhoneApp('flappy')">
					<div class="phone-app-icon" style="background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); display: flex; align-items: center; justify-content: center;">
						<svg width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<circle cx="12" cy="12" r="8" fill="white"/>
							<circle cx="10" cy="10" r="1.5" fill="#000"/>
							<path d="M14 14 Q12 16 10 14" stroke="#ff8c00" stroke-width="1.5" fill="none" stroke-linecap="round"/>
							<path d="M8 6 L6 4 L7 8 Z" fill="#ff8c00"/>
						</svg>
					</div>
					<div class="phone-app-label">Floaty</div>
				</div>
				<div class="phone-app" onclick="openPhoneApp('settings')">
					<div class="phone-app-icon" style="background: linear-gradient(135deg, #8e8e93 0%, #636366 100%); display: flex; align-items: center; justify-content: center;">
						<svg width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z" stroke="white" stroke-width="2"/>
							<path d="M19.4 15C19.2669 15.3016 19.2272 15.6362 19.286 15.9606C19.3448 16.285 19.4995 16.5843 19.73 16.82L19.79 16.88C19.976 17.0657 20.1235 17.2863 20.2241 17.5291C20.3248 17.7719 20.3766 18.0322 20.3766 18.295C20.3766 18.5578 20.3248 18.8181 20.2241 19.0609C20.1235 19.3037 19.976 19.5243 19.79 19.71C19.6043 19.896 19.3837 20.0435 19.1409 20.1441C18.8981 20.2448 18.6378 20.2966 18.375 20.2966C18.1122 20.2966 17.8519 20.2448 17.6091 20.1441C17.3663 20.0435 17.1457 19.896 16.96 19.71L16.9 19.65C16.6643 19.4195 16.365 19.2648 16.0406 19.206C15.7162 19.1472 15.3816 19.1869 15.08 19.32C14.7842 19.4468 14.532 19.6572 14.3543 19.9255C14.1766 20.1938 14.0813 20.5082 14.08 20.83V21C14.08 21.5304 13.8693 22.0391 13.4942 22.4142C13.1191 22.7893 12.6104 23 12.08 23C11.5496 23 11.0409 22.7893 10.6658 22.4142C10.2907 22.0391 10.08 21.5304 10.08 21V20.91C10.0723 20.579 9.96512 20.258 9.77251 19.9887C9.5799 19.7194 9.31074 19.5143 9 19.4C8.69838 19.2669 8.36381 19.2272 8.03941 19.286C7.71502 19.3448 7.41568 19.4995 7.18 19.73L7.12 19.79C6.93425 19.976 6.71368 20.1235 6.47088 20.2241C6.22808 20.3248 5.96783 20.3766 5.705 20.3766C5.44217 20.3766 5.18192 20.3248 4.93912 20.2241C4.69632 20.1235 4.47575 19.976 4.29 19.79C4.10405 19.6043 3.95653 19.3837 3.85588 19.1409C3.75523 18.8981 3.70343 18.6378 3.70343 18.375C3.70343 18.1122 3.75523 17.8519 3.85588 17.6091C3.95653 17.3663 4.10405 17.1457 4.29 16.96L4.35 16.9C4.58054 16.6643 4.73519 16.365 4.794 16.0406C4.85282 15.7162 4.81312 15.3816 4.68 15.08C4.55324 14.7842 4.34276 14.532 4.07447 14.3543C3.80618 14.1766 3.49179 14.0813 3.17 14.08H3C2.46957 14.08 1.96086 13.8693 1.58579 13.4942C1.21071 13.1191 1 12.6104 1 12.08C1 11.5496 1.21071 11.0409 1.58579 10.6658C1.96086 10.2907 2.46957 10.08 3 10.08H3.09C3.42099 10.0723 3.742 9.96512 4.0113 9.77251C4.28059 9.5799 4.48572 9.31074 4.6 9C4.73312 8.69838 4.77282 8.36381 4.714 8.03941C4.65519 7.71502 4.50054 7.41568 4.27 7.18L4.21 7.12C4.02405 6.93425 3.87653 6.71368 3.77588 6.47088C3.67523 6.22808 3.62343 5.96783 3.62343 5.705C3.62343 5.44217 3.67523 5.18192 3.77588 4.93912C3.87653 4.69632 4.02405 4.47575 4.21 4.29C4.39575 4.10405 4.61632 3.95653 4.85912 3.85588C5.10192 3.75523 5.36217 3.70343 5.625 3.70343C5.88783 3.70343 6.14808 3.75523 6.39088 3.85588C6.63368 3.95653 6.85425 4.10405 7.04 4.29L7.1 4.35C7.33568 4.58054 7.63502 4.73519 7.95941 4.794C8.28381 4.85282 8.61838 4.81312 8.92 4.68H9C9.29577 4.55324 9.54802 4.34276 9.72569 4.07447C9.90337 3.80618 9.99872 3.49179 10 3.17V3C10 2.46957 10.2107 1.96086 10.5858 1.58579C10.9609 1.21071 11.4696 1 12 1C12.5304 1 13.0391 1.21071 13.4142 1.58579C13.7893 1.96086 14 2.46957 14 3V3.09C14.0013 3.41179 14.0966 3.72618 14.2743 3.99447C14.452 4.26276 14.7042 4.47324 15 4.6C15.3016 4.73312 15.6362 4.77282 15.9606 4.714C16.285 4.65519 16.5843 4.50054 16.82 4.27L16.88 4.21C17.0657 4.02405 17.2863 3.87653 17.5291 3.77588C17.7719 3.67523 18.0322 3.62343 18.295 3.62343C18.5578 3.62343 18.8181 3.67523 19.0609 3.77588C19.3037 3.87653 19.5243 4.02405 19.71 4.21C19.896 4.39575 20.0435 4.61632 20.1441 4.85912C20.2448 5.10192 20.2966 5.36217 20.2966 5.625C20.2966 5.88783 20.2448 6.14808 20.1441 6.39088C20.0435 6.63368 19.896 6.85425 19.71 7.04L19.65 7.1C19.4195 7.33568 19.2648 7.63502 19.206 7.95941C19.1472 8.28381 19.1869 8.61838 19.32 8.92V9C19.4468 9.29577 19.6572 9.54802 19.9255 9.72569C20.1938 9.90337 20.5082 9.99872 20.83 10H21C21.5304 10 22.0391 10.2107 22.4142 10.5858C22.7893 10.9609 23 11.4696 23 12C23 12.5304 22.7893 13.0391 22.4142 13.4142C22.0391 13.7893 21.5304 14 21 14H20.91C20.5882 14.0013 20.2738 14.0966 20.0055 14.2743C19.7372 14.452 19.5268 14.7042 19.4 15Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
						</svg>
					</div>
					<div class="phone-app-label">Settings</div>
				</div>
			</div>

			<div class="phone-home-indicator"></div>
		</div>

		<!-- Music App Screen -->
		<div id="phone-music-app" class="phone-music-app">
			<div class="car-radio-header">
				<button class="phone-back-btn" onclick="closePhoneApp()">‹</button>
				<div class="car-radio-title">SUBLAIR</div>
			</div>
			<div class="phone-search-bar">
				<input type="text" id="phone-search-input" placeholder="Search tracks, artists..." />
			</div>
			<div class="car-radio-content" id="radio-tracklist">
				<!-- Tracks will be loaded here -->
			</div>
			<div class="car-radio-bottom-bar">
				<div class="car-radio-now-playing-mini">
					<div class="car-radio-mini-art"></div>
					<div class="car-radio-mini-info">
						<div class="car-radio-mini-title" id="radio-current-title">Not Playing</div>
						<div class="car-radio-mini-artist" id="radio-current-artist">Select a track</div>
					</div>
				</div>
				<div class="car-radio-controls">
					<button class="car-radio-btn" onclick="radioSkipPrev()">⏮</button>
					<button class="car-radio-btn play-pause" id="radio-play-btn" onclick="radioTogglePlay()">▶</button>
					<button class="car-radio-btn" onclick="radioSkipNext()">⏭</button>
				</div>
			</div>
		</div>

		<!-- Messenger App Screen -->
		<div id="phone-messenger-app" class="phone-music-app">
			<!-- Conversations List View -->
			<div id="messenger-conversations-view">
				<div class="car-radio-header">
					<button class="phone-back-btn" onclick="closePhoneApp()">‹</button>
					<div class="car-radio-title">Messenger</div>
				</div>
				<div class="car-radio-content" style="padding: 0;">
					<!-- Conversation Item: Global Chat -->
					<div class="messenger-conversation-item" onclick="openMessengerChat()">
						<div style="display: flex; align-items: center; gap: 12px; padding: 16px 20px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
							<div style="width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, #00c6ff 0%, #0072ff 100%); display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 600; color: #fff; flex-shrink: 0;">
								GC
							</div>
							<div style="flex: 1; min-width: 0;">
								<div style="display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 4px;">
									<div style="font-family: 'Share', monospace; font-size: 16px; font-weight: 600; color: #fff;">Global Chat</div>
									<div style="font-family: 'Share', monospace; font-size: 12px; color: rgba(255, 255, 255, 0.5);">now</div>
								</div>
								<div style="font-family: 'Share', monospace; font-size: 14px; color: rgba(255, 255, 255, 0.6); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">Tap to join the conversation</div>
							</div>
						</div>
					</div>
				</div>
			</div>

			<!-- Chat View -->
			<div id="messenger-chat-view" style="display: none; height: 100%; width: 100%; position: absolute; top: 0; left: 0; flex-direction: column;">
				<div class="car-radio-header">
					<button class="phone-back-btn" onclick="closeMessengerChat()">‹</button>
					<div class="car-radio-title">Global Chat</div>
				</div>
				<div class="car-radio-content" id="phone-chat-messages" style="padding: 16px 20px 80px 20px; flex: 1;">
					<!-- Chat messages will be loaded here -->
				</div>
				<div class="car-radio-bottom-bar" style="padding: 16px 20px 32px 20px; background: rgba(0, 0, 0, 0.95);">
					<div style="display: flex; gap: 8px; align-items: center;">
						<input type="text" id="phone-chat-input" placeholder="Type a message..." style="flex: 1; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px; padding: 10px 16px; color: #fff; font-family: 'Share', monospace; font-size: 14px; outline: none;" />
						<button id="phone-chat-send" style="background: #00c6ff; border: none; border-radius: 50%; width: 40px; height: 40px; color: #fff; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;">➤</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Settings App Screen -->
		<div id="phone-settings-app" class="phone-music-app">
			<div class="car-radio-header">
				<button class="phone-back-btn" onclick="closePhoneApp()">‹</button>
				<div class="car-radio-title">Settings</div>
			</div>
			<div class="car-radio-content" style="padding: 20px;">
				<!-- Bluetooth Section -->
				<div style="margin-bottom: 24px;">
					<div style="font-family: 'Share', monospace; font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 12px;">Bluetooth</div>
					<div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; margin-bottom: 8px;">
						<div style="font-family: 'Share', monospace; color: #fff; font-size: 14px;">Bluetooth</div>
						<div id="bluetooth-toggle" onclick="toggleBluetooth()" style="width: 50px; height: 30px; background: rgba(255, 255, 255, 0.3); border-radius: 15px; position: relative; cursor: pointer; transition: background 0.3s;">
							<div style="width: 26px; height: 26px; background: #fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s;"></div>
						</div>
					</div>
				</div>

				<!-- Audio Output Section -->
				<div id="audio-output-section" style="margin-bottom: 24px; opacity: 0.5; pointer-events: none; position: relative;">
					<div style="font-family: 'Share', monospace; font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 12px;">Audio Output</div>

					<!-- The Stack -->
					<div onclick="selectAudioOutput('stack')" style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.15)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
						<div>
							<div style="font-family: 'Share', monospace; color: #fff; font-size: 16px;">The Stack</div>
							<div style="font-family: 'Share', monospace; color: rgba(255, 255, 255, 0.6); font-size: 12px;">Desktop speakers</div>
						</div>
						<div id="stack-check" style="width: 20px; height: 20px; border-radius: 50%; border: 2px solid #0a84ff; display: flex; align-items: center; justify-content: center;">
							<div style="width: 12px; height: 12px; border-radius: 50%; background: #0a84ff;"></div>
						</div>
					</div>

					<!-- The Car -->
					<div onclick="selectAudioOutput('car')" style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.15)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
						<div>
							<div style="font-family: 'Share', monospace; color: #fff; font-size: 16px;">The Car</div>
							<div style="font-family: 'Share', monospace; color: rgba(255, 255, 255, 0.6); font-size: 12px;">Car audio system</div>
						</div>
						<div id="car-check" style="width: 20px; height: 20px; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.3);"></div>
					</div>
				</div>
			</div>
		</div>

		<!-- Flappy Bird Game Screen -->
		<div id="phone-flappy-app" class="phone-music-app">
			<div class="car-radio-header">
				<button class="phone-back-btn" onclick="closePhoneApp()">‹</button>
				<div class="car-radio-title">Floaty</div>
			</div>
			<div class="car-radio-content" style="padding: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: linear-gradient(180deg, #4ec0ca 0%, #87ceeb 100%); position: relative;">
				<canvas id="flappy-canvas" width="320" height="480" style="max-width: 100%; max-height: 100%; border: none; cursor: pointer;"></canvas>
				<div id="flappy-score" style="position: absolute; top: 80px; left: 50%; transform: translateX(-50%); font-family: 'Share', monospace; font-size: 48px; font-weight: bold; color: #fff; text-shadow: 3px 3px 0 #000; pointer-events: none;">0</div>

				<!-- Start Screen -->
				<div id="flappy-start" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #fff; font-family: 'Share', monospace; pointer-events: none;">
					<div style="font-size: 32px; font-weight: bold; margin-bottom: 16px; text-shadow: 2px 2px 0 #000;">FLOATY</div>
					<div style="font-size: 18px; text-shadow: 2px 2px 0 #000;">TAP TO START</div>
					<button onclick="showFloatyHighScores(event)" style="margin-top: 20px; padding: 8px 16px; background: rgba(255, 255, 255, 0.2); border: 2px solid #fff; border-radius: 8px; color: #fff; font-family: 'Share', monospace; font-size: 14px; cursor: pointer; pointer-events: all; text-shadow: 2px 2px 0 #000;">HIGH SCORES</button>
				</div>

				<!-- Game Over Screen -->
				<div id="flappy-gameover" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #fff; font-family: 'Share', monospace; pointer-events: none;">
					<div style="font-size: 32px; font-weight: bold; margin-bottom: 16px; text-shadow: 2px 2px 0 #000;">GAME OVER</div>
					<div id="flappy-final-score" style="font-size: 24px; margin-bottom: 8px; text-shadow: 2px 2px 0 #000;">Score: 0</div>
					<div id="flappy-high-score-msg" style="font-size: 16px; margin-bottom: 16px; text-shadow: 2px 2px 0 #000; color: #ffd700;"></div>
					<div style="font-size: 18px; text-shadow: 2px 2px 0 #000;">TAP TO RESTART</div>
					<button onclick="showFloatyHighScores(event)" style="margin-top: 20px; padding: 8px 16px; background: rgba(255, 255, 255, 0.2); border: 2px solid #fff; border-radius: 8px; color: #fff; font-family: 'Share', monospace; font-size: 14px; cursor: pointer; pointer-events: all; text-shadow: 2px 2px 0 #000;">HIGH SCORES</button>
				</div>

				<!-- High Scores Screen -->
				<div id="flappy-highscores" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.9); padding: 20px; overflow-y: auto; pointer-events: all;">
					<div style="text-align: center; color: #fff; font-family: 'Share', monospace;">
						<div style="font-size: 24px; font-weight: bold; margin-bottom: 20px;">HIGH SCORES</div>
						<div id="flappy-highscores-list" style="margin-bottom: 20px;"></div>
						<button onclick="closeFloatyHighScores()" style="padding: 10px 20px; background: #ffd700; border: none; border-radius: 8px; color: #000; font-family: 'Share', monospace; font-size: 16px; cursor: pointer; font-weight: bold;">BACK</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Custom Phone Alert Overlay -->
		<div id="phone-alert-overlay" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px); z-index: 1000; align-items: center; justify-content: center;">
			<div style="background: rgba(30, 30, 30, 0.95); border-radius: 16px; padding: 24px; width: 280px; text-align: center; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);">
				<div id="phone-alert-title" style="font-family: 'Share', monospace; font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 12px;"></div>
				<div id="phone-alert-message" style="font-family: 'Share', monospace; font-size: 14px; color: rgba(255, 255, 255, 0.8); margin-bottom: 24px; line-height: 1.5;"></div>
				<button onclick="closePhoneAlert()" style="width: 100%; padding: 12px; background: #0a84ff; border: none; border-radius: 8px; color: #fff; font-family: 'Share', monospace; font-size: 16px; cursor: pointer; font-weight: bold; transition: background 0.2s;" onmouseover="this.style.background='#0066cc'" onmouseout="this.style.background='#0a84ff'">OK</button>
			</div>
		</div>
	</div>

	<!-- CRT Camera UI -->
	<div id="crt-ui">
		<div id="rec-indicator">
			<div id="rec-dot"></div>
			<span>REC</span>
		</div>
		<div id="timestamp"></div>
	</div>

	<!-- Engine Credit (always visible on main game) -->
	<div id="crt-engine-credit" class="visible">
		Engine: <a href="https://github.com/swift502/Sketchbook" target="_blank">Sketchbook 0.4</a>
	</div>

	<script src="./build/sketchbook.min.js"></script>

	<script>
		// Update CRT timestamp
		function updateTimestamp() {
			const now = new Date();
			const year = now.getFullYear();
			const month = String(now.getMonth() + 1).padStart(2, '0');
			const day = String(now.getDate()).padStart(2, '0');
			const hours = String(now.getHours()).padStart(2, '0');
			const minutes = String(now.getMinutes()).padStart(2, '0');
			const seconds = String(now.getSeconds()).padStart(2, '0');

			document.getElementById('timestamp').textContent =
				`${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
		}

		// Update timestamp every second
		updateTimestamp();
		setInterval(updateTimestamp, 1000);


		// CRT shader and BokehPass preloading removed - spectators are now full characters

		// Create a simple flat world with a car
		window.world = new Sketchbook.World();
		const world = window.world; // Keep local reference for compatibility

		// Check for spectator mode globally (used throughout the app)
		const urlParams = new URLSearchParams(window.location.search);
		const spectatorSessionCode = urlParams.get('session');
		const isSpectatorMode = spectatorSessionCode && spectatorSessionCode.length === 6;

		// Hide music app icon for spectators
		if (isSpectatorMode) {
			const musicIcon = document.getElementById('phone-music-icon');
			if (musicIcon) {
				musicIcon.style.display = 'none';
				console.log('🎵 Music app hidden for spectator');
			}
		}

		// If spectator mode, immediately position camera at portal facing speakers
		if (isSpectatorMode && world.camera) {
			world.camera.position.set(50, 15, 5); // At portal location
			// Face camera towards positive X direction (away from speakers)
			const target = new THREE.Vector3(100, 15, 5);
			world.camera.lookAt(target);
			console.log('👻 Initial spectator camera positioned at portal (50, 15, 5) facing positive X');
		}

		// CRT shader removed - spectators are now full characters, not cameras

		// Load asset colors from localStorage IMMEDIATELY (before assets load)
		(function() {
			let savedCustomization = localStorage.getItem('characterCustomization');
			if (savedCustomization) {
				let customizationData = JSON.parse(savedCustomization);
				window.floorGlowColor = customizationData.floorGlowColor || '#bee17b';
				window.floorPanelColor = customizationData.floorPanelColor || '#282828';
				window.speakerCabColor = customizationData.speakerCabColor || '#282828';
				window.speakerTrimColor = customizationData.speakerTrimColor || '#282828';
				window.speakerFaceColor = customizationData.speakerFaceColor || '#282828';
				window.speakerFrameColor = customizationData.speakerFrameColor || '#282828';
				window.computerChassisColor = customizationData.computerChassisColor || '#282828';
				window.computerKeyboardColor = customizationData.computerKeyboardColor || '#191919';
				window.computerFeaturesColor = customizationData.computerFeaturesColor || '#bee17b';
				window.skyTopColor = customizationData.skyTopColor || '#000000';
				window.skyBottomColor = customizationData.skyBottomColor || '#000000';
				window.skyTopPosition = customizationData.skyTopPosition !== undefined ? customizationData.skyTopPosition : 0;
				window.skyBottomPosition = customizationData.skyBottomPosition !== undefined ? customizationData.skyBottomPosition : 100;
				window.carDoorColor = customizationData.carDoorColor || '#282828';
				window.carFrameColor = customizationData.carFrameColor || '#282828';
				window.carHeadlightsColor = customizationData.carHeadlightsColor || '#282828';
				window.carHoodColor = customizationData.carHoodColor || '#282828';
				window.carInteriorColor = customizationData.carInteriorColor || '#282828';
				window.carRimColor = customizationData.carRimColor || '#282828';
				window.carSteeringColor = customizationData.carSteeringColor || '#282828';
				window.carTaillightsColor = customizationData.carTaillightsColor || '#282828';
				window.carTireColor = customizationData.carTireColor || '#282828';
				window.carTrimColor = customizationData.carTrimColor || '#282828';
				console.log('✅ Loaded colors from localStorage');
			} else {
				// Set defaults if no saved data
				window.floorGlowColor = '#bee17b';
				window.floorPanelColor = '#282828';
				window.speakerCabColor = '#282828';
				window.speakerTrimColor = '#282828';
				window.speakerFaceColor = '#282828';
				window.speakerFrameColor = '#282828';
				window.computerChassisColor = '#282828';
				window.computerKeyboardColor = '#191919';
				window.computerFeaturesColor = '#bee17b';
				window.skyTopColor = '#000000';
				window.skyBottomColor = '#000000';
				window.skyTopPosition = 0;
				window.skyBottomPosition = 100;
				window.carDoorColor = '#282828';
				window.carFrameColor = '#282828';
				window.carHeadlightsColor = '#282828';
				window.carHoodColor = '#282828';
				window.carInteriorColor = '#282828';
				window.carRimColor = '#282828';
				window.carSteeringColor = '#282828';
				window.carTaillightsColor = '#282828';
				window.carTireColor = '#282828';
				window.carTrimColor = '#282828';
			}
		})();

		// CRT retry logic removed - no longer needed

		// We need to wait a moment for the world to initialize
		setTimeout(() => {
			// Create a gray grid texture
			const canvas = document.createElement('canvas');
			canvas.width = 512;
			canvas.height = 512;
			const ctx = canvas.getContext('2d');

			// Function to generate grid texture with custom colors
			window.generateGridTexture = function(lineColor = '#bee17b', bgColor = '#2a2a2a') {
				ctx.fillStyle = bgColor;
				ctx.fillRect(0, 0, 512, 512);

				// Draw grid lines
				ctx.strokeStyle = lineColor;
				ctx.lineWidth = 2;

				const gridSize = 64;
				// Vertical lines
				for (let i = 0; i <= 512; i += gridSize) {
					ctx.beginPath();
					ctx.moveTo(i, 0);
					ctx.lineTo(i, 512);
					ctx.stroke();
				}
				// Horizontal lines
				for (let i = 0; i <= 512; i += gridSize) {
					ctx.beginPath();
					ctx.moveTo(0, i);
					ctx.lineTo(512, i);
					ctx.stroke();
				}

				// Update texture
				if (window.gridTexture) {
					window.gridTexture.needsUpdate = true;
				}
			};

			// Initial generation with saved colors
			window.generateGridTexture(window.floorGlowColor || '#bee17b', window.floorPanelColor || '#282828');

			// Create texture from canvas
			const gridTexture = new THREE.CanvasTexture(canvas);
			gridTexture.wrapS = THREE.RepeatWrapping;
			gridTexture.wrapT = THREE.RepeatWrapping;
			gridTexture.repeat.set(50, 50);
			window.gridTexture = gridTexture;

			// Add a large ground plane (visual)
			const groundGeometry = new THREE.PlaneGeometry(200, 200, 1, 1);
			const groundMaterial = new THREE.MeshStandardMaterial({
				color: new THREE.Color(window.floorPanelColor || '#282828'), // Use saved panel color
				map: gridTexture,
				emissive: new THREE.Color(window.floorGlowColor || '#bee17b'), // Use saved glow color
				emissiveMap: gridTexture,
				emissiveIntensity: 0.3, // Subtle glow
				roughness: 0.8,
				metalness: 0.2
			});
			const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
			groundMesh.rotation.x = -Math.PI / 2;
			groundMesh.receiveShadow = true;
			world.graphicsWorld.add(groundMesh);
			window.groundMesh = groundMesh; // Make accessible for customization

			// Apply host customization to floor if spectator
			if (isSpectatorMode && window.hostCustomization) {
				const c = window.hostCustomization;
				if (c.floorGlowColor && c.floorPanelColor && window.generateGridTexture) {
					window.generateGridTexture(c.floorGlowColor, c.floorPanelColor);
					window.groundMesh.material.emissive.set(c.floorGlowColor);
					window.groundMesh.material.color.set(c.floorPanelColor);
					window.groundMesh.material.needsUpdate = true;
					console.log('🎨 Applied host floor customization on load');
				}
			}

			// Note: Sky gradient will be initialized after loading completes

			// Setup ground material for shadows
			world.sky.csm.setupMaterial(groundMaterial);

			// Add physics ground (collision) - this is the important part for the car to drive on
			const groundShape = new CANNON.Box(new CANNON.Vec3(100, 0.5, 100));
			const groundBody = new CANNON.Body({
				mass: 0,
				shape: groundShape,
				position: new CANNON.Vec3(0, -0.5, 0)
			});
			world.physicsWorld.addBody(groundBody);


			// Load the car and character
			const loadingManager = new Sketchbook.LoadingManager(world);

			loadingManager.onFinishedCallback = () => {
				world.update(1, 1);
				world.setTimeScale(1);

				Sketchbook.UIManager.setUserInterfaceVisible(false);
				Sketchbook.UIManager.setLoadingScreenVisible(false);

				// Apply sky gradient after world is fully loaded
				const finalSkyTop = window.skyTopColor || '#000000';
				const finalSkyBottom = window.skyBottomColor || '#000000';
				const finalSkyTopPos = window.skyTopPosition !== undefined ? window.skyTopPosition : 0;
				const finalSkyBottomPos = window.skyBottomPosition !== undefined ? window.skyBottomPosition : 100;

				// Apply gradient to sky sphere immediately (inline version before updateSkyGradient is defined)
				if (world && world.sky) {
					const topColorObj = new THREE.Color(finalSkyTop);
					const bottomColorObj = new THREE.Color(finalSkyBottom);

					world.sky.traverse((child) => {
						if (child.isMesh && child.geometry && child.geometry.type === 'SphereBufferGeometry') {
							// Create gradient material
							const gradientMaterial = new THREE.ShaderMaterial({
								uniforms: {
									topColor: { value: topColorObj },
									bottomColor: { value: bottomColorObj },
									topPosition: { value: finalSkyTopPos / 100 },
									bottomPosition: { value: finalSkyBottomPos / 100 }
								},
								vertexShader: `
									varying vec3 vWorldPosition;
									void main() {
										vec4 worldPosition = modelMatrix * vec4(position, 1.0);
										vWorldPosition = worldPosition.xyz;
										gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
									}
								`,
								fragmentShader: `
									uniform vec3 topColor;
									uniform vec3 bottomColor;
									uniform float topPosition;
									uniform float bottomPosition;
									varying vec3 vWorldPosition;

									void main() {
										// Normalize Y position to 0-1 range
										float h = normalize(vWorldPosition).y;
										float gradientPos = (h + 1.0) / 2.0;

										vec3 finalColor;
										if (gradientPos < topPosition) {
											finalColor = topColor;
										} else if (gradientPos > bottomPosition) {
											finalColor = bottomColor;
										} else {
											float t = (gradientPos - topPosition) / (bottomPosition - topPosition);
											finalColor = mix(topColor, bottomColor, t);
										}

										gl_FragColor = vec4(finalColor, 1.0);
									}
								`,
								side: THREE.BackSide,
								toneMapped: false
							});

							gradientMaterial.userData.isCustomSky = true;
							child.material = gradientMaterial;
							console.log('🌌 Sky gradient initialized after loading:', finalSkyTop, '@', finalSkyTopPos + '%', '->', finalSkyBottom, '@', finalSkyBottomPos + '%');
						}
					});
				}

				// CRT overlay removed - spectators are now full characters, not cameras

				// Check if spectator mode (set by URL param check)
				if (isSpectatorMode) {
					// Skip welcome screen for spectators
					console.log('👻 Spectator mode detected, skipping welcome screen');
				} else {
					// Ensure welcome screen stays visible above everything for normal players
					const welcomeOverlay = document.getElementById('welcome-overlay');
					if (welcomeOverlay && welcomeOverlay.classList.contains('active')) {
						// Keep it visible and above everything
						welcomeOverlay.style.zIndex = '999999';
						welcomeOverlay.style.opacity = '1';
						welcomeOverlay.style.pointerEvents = 'auto';
					}
				}
			};

			window.car = null; // Store car reference globally
			let car = window.car;
			loadingManager.loadGLTF('build/assets/car.glb', (carModel) => {
				console.log('🚗 Car GLB loaded, structure:', carModel.scene);

				// Debug: Log all objects in the scene
				carModel.scene.traverse((child) => {
					if (child.isMesh) {
						console.log('  Mesh:', child.name, 'Material:', child.material?.name);
					}
					if (child.userData?.data) {
						console.log('  UserData:', child.name, 'Data:', child.userData.data);
					}
				});

				console.log('🚗 Car GLB loaded, inspecting structure...');

				// Apply saved car colors BEFORE creating Car object (so materials don't get lost)
				console.log('🎨 Applying car colors to carModel.scene...');
				console.log('   window.carTireColor:', window.carTireColor);
				console.log('   window.carRimColor:', window.carRimColor);

				carModel.scene.traverse((child) => {
					if (child.isMesh && child.material) {
						const matName = child.material.name;

						if (matName === 'DOOR' || matName.toLowerCase().includes('door')) {
							if (window.carDoorColor) {
								child.material.color.set(window.carDoorColor);
								console.log('   ✅ Applied DOOR color to', child.name, ':', window.carDoorColor);
							}
						} else if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
							if (window.carFrameColor) {
								child.material.color.set(window.carFrameColor);
								console.log('   ✅ Applied FRAME color to', child.name, ':', window.carFrameColor);
							}
						} else if (matName === 'HEADLIGHTS' || matName.toLowerCase().includes('headlight')) {
							if (window.carHeadlightsColor) {
								child.material.color.set(window.carHeadlightsColor);
								console.log('   ✅ Applied HEADLIGHTS color to', child.name, ':', window.carHeadlightsColor);
							}
						} else if (matName === 'HOOD' || matName.toLowerCase().includes('hood')) {
							if (window.carHoodColor) {
								child.material.color.set(window.carHoodColor);
								console.log('   ✅ Applied HOOD color to', child.name, ':', window.carHoodColor);
							}
						} else if (matName === 'INTERIOR' || matName.toLowerCase().includes('interior')) {
							if (window.carInteriorColor) {
								child.material.color.set(window.carInteriorColor);
								console.log('   ✅ Applied INTERIOR color to', child.name, ':', window.carInteriorColor);
							}
						} else if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
							if (window.carRimColor) {
								child.material.color.set(window.carRimColor);
								console.log('   ✅ Applied RIMS color to', child.name, ':', window.carRimColor);
							}
						} else if (matName === 'STEERING' || matName.toLowerCase().includes('steering')) {
							if (window.carSteeringColor) {
								child.material.color.set(window.carSteeringColor);
								console.log('   ✅ Applied STEERING color to', child.name, ':', window.carSteeringColor);
							}
						} else if (matName === 'TAILLIGHTS' || matName.toLowerCase().includes('taillight')) {
							if (window.carTaillightsColor) {
								child.material.color.set(window.carTaillightsColor);
								console.log('   ✅ Applied TAILLIGHTS color to', child.name, ':', window.carTaillightsColor);
							}
						} else if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
							if (window.carTireColor) {
								child.material.color.set(window.carTireColor);
								console.log('   ✅ Applied TIRES color to', child.name, ':', window.carTireColor);
							}
						} else if (matName === 'TRIM' || matName.toLowerCase().includes('trim')) {
							if (window.carTrimColor) {
								child.material.color.set(window.carTrimColor);
								console.log('   ✅ Applied TRIM color to', child.name, ':', window.carTrimColor);
							}
						}
					}
				});

				window.car = car = new Sketchbook.Car(carModel);
				car.setPosition(0, 2, 0);

				// Create spawn point for the car (required by physics system)
				car.spawnPoint = new THREE.Object3D();
				car.spawnPoint.position.set(0, 2, 0);
				world.graphicsWorld.add(car.spawnPoint);

				world.add(car);

				// Apply host customization to car if spectator and customization already received
				if (isSpectatorMode && window.hostCustomization) {
					const c = window.hostCustomization;
					car.traverse((child) => {
						if (child.isMesh && child.material) {
							const matName = child.material.name;
							if (matName === 'DOOR' || matName.toLowerCase().includes('door')) {
								child.material.color.set(c.carDoorColor);
							} else if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
								child.material.color.set(c.carFrameColor);
							} else if (matName === 'HEADLIGHTS' || matName.toLowerCase().includes('headlight')) {
								child.material.color.set(c.carHeadlightsColor);
							} else if (matName === 'HOOD' || matName.toLowerCase().includes('hood')) {
								child.material.color.set(c.carHoodColor);
							} else if (matName === 'INTERIOR' || matName.toLowerCase().includes('interior')) {
								child.material.color.set(c.carInteriorColor);
							} else if (matName === 'RIM' || matName.toLowerCase().includes('rim')) {
								child.material.color.set(c.carRimColor);
							} else if (matName === 'STEERING' || matName.toLowerCase().includes('steering')) {
								child.material.color.set(c.carSteeringColor);
							} else if (matName === 'TAILLIGHTS' || matName.toLowerCase().includes('taillight')) {
								child.material.color.set(c.carTaillightsColor);
							} else if (matName === 'TIRE' || matName.toLowerCase().includes('tire')) {
								child.material.color.set(c.carTireColor);
							} else if (matName === 'TRIM' || (matName.toLowerCase().includes('trim') && !matName.toLowerCase().includes('speaker'))) {
								child.material.color.set(c.carTrimColor);
							}
							child.material.needsUpdate = true;
						}
					});
					console.log('🎨 Applied host car customization on load');
				}

				// Create spatial audio for the car
				const listener = new THREE.AudioListener();
				world.camera.add(listener);

				window.carPositionalAudio = new THREE.PositionalAudio(listener);
				window.carPositionalAudio.setRefDistance(2); // Audible from 2 units away
				window.carPositionalAudio.setMaxDistance(8); // Max audible distance
				window.carPositionalAudio.setRolloffFactor(2); // Faster falloff
				window.carPositionalAudio.setDistanceModel('exponential'); // More realistic distance model

				// Create car-specific EQ (like actual car speakers)
				const audioContext = window.carPositionalAudio.context;

				// Bass boost (typical car subwoofer)
				window.carEQ = {
					bass: audioContext.createBiquadFilter(),
					lowMid: audioContext.createBiquadFilter(),
					highMid: audioContext.createBiquadFilter(),
					treble: audioContext.createBiquadFilter(),
					outsideLowpass: audioContext.createBiquadFilter() // Muffle when outside car
				};

				// Bass boost at 80Hz (car subwoofer range)
				window.carEQ.bass.type = 'lowshelf';
				window.carEQ.bass.frequency.value = 80;
				window.carEQ.bass.gain.value = 6; // +6dB bass boost

				// Cut low-mids at 250Hz (reduce muddiness)
				window.carEQ.lowMid.type = 'peaking';
				window.carEQ.lowMid.frequency.value = 250;
				window.carEQ.lowMid.Q.value = 1;
				window.carEQ.lowMid.gain.value = -3; // -3dB cut

				// Cut high-mids at 2kHz (reduce harshness)
				window.carEQ.highMid.type = 'peaking';
				window.carEQ.highMid.frequency.value = 2000;
				window.carEQ.highMid.Q.value = 1;
				window.carEQ.highMid.gain.value = -2; // -2dB cut

				// Roll off highs at 8kHz (car speakers don't have great treble)
				window.carEQ.treble.type = 'highshelf';
				window.carEQ.treble.frequency.value = 8000;
				window.carEQ.treble.gain.value = -4; // -4dB rolloff

				// Lowpass for when outside car (starts muffled)
				window.carEQ.outsideLowpass.type = 'lowpass';
				window.carEQ.outsideLowpass.frequency.value = 800; // Muffled when outside
				window.carEQ.outsideLowpass.Q.value = 1;

				// Add the positional audio to the car
				car.add(window.carPositionalAudio);

				// Store car audio position globally
				window.carAudioPosition = new THREE.Vector3();
				window.carPositionalAudio.getWorldPosition(window.carAudioPosition);

				// Create debug visualization for car audio position
				const carMarkerGeometry = new THREE.SphereGeometry(0.3, 16, 16);
				const carMarkerMaterial = new THREE.MeshBasicMaterial({
					color: 0xff00ff, // Magenta for car
					transparent: true,
					opacity: 0.8
				});
				window.debugCarMarker = new THREE.Mesh(carMarkerGeometry, carMarkerMaterial);
				window.debugCarMarker.position.copy(car.position);
				window.debugCarMarker.visible = false;
				world.graphicsWorld.add(window.debugCarMarker);

				// Create arrow showing car audio direction
				const carInitialDir = new THREE.Vector3();
				window.carPositionalAudio.getWorldDirection(carInitialDir);
				const carArrowHelper = new THREE.ArrowHelper(
					carInitialDir,
					car.position,
					3, // length
					0xff00ff, // magenta
					0.5, // headLength
					0.3 // headWidth
				);
				window.debugCarArrow = carArrowHelper;
				window.debugCarArrow.visible = false;
				world.graphicsWorld.add(window.debugCarArrow);

				// Create cone visualization for car (just front green cone)
				// Front cone (145°)
				const carFrontConeAngle = 145 * Math.PI / 180;
				const carFrontConeRadius = Math.tan(carFrontConeAngle / 2) * 10;
				const carFrontConeGeometry = new THREE.ConeGeometry(carFrontConeRadius, 10, 32, 1, false);
				const carFrontConeMaterial = new THREE.MeshBasicMaterial({
					color: 0x00ff00,
					transparent: true,
					opacity: 0.2,
					side: THREE.DoubleSide
				});
				window.debugCarFrontCone = new THREE.Mesh(carFrontConeGeometry, carFrontConeMaterial);

				// Position and rotate cone - car faces forward (positive Z)
				const carFrontConeRotation = new THREE.Euler(-Math.PI / 2, 0, 0, 'XYZ');
				window.debugCarFrontCone.rotation.copy(carFrontConeRotation);

				// Position cone at car position
				const carFrontOffset = new THREE.Vector3(0, 0, 5);
				window.debugCarFrontCone.position.copy(car.position).add(carFrontOffset);

				// Add to scene but hide by default
				window.debugCarFrontCone.visible = false;
				world.graphicsWorld.add(window.debugCarFrontCone);

				console.log('🚗 Car spatial audio system created with car EQ + debug visualizations');
			});

			window.character = null; // Store character reference globally
			let character = window.character; // Local reference for compatibility
			window.customizationOpen = false; // Global scope for all menus to access
			let customizationOpen = window.customizationOpen;
			window.terminalOpen = false; // Global scope for C key check
			let terminalOpen = window.terminalOpen;

			// Create a dummy input receiver that does nothing - global scope
			window.dummyInputReceiver = {
				handleKeyboardEvent: () => {},
				handleMouseButton: () => {},
				handleMouseMove: () => {},
				handleMouseWheel: () => {},
				inputReceiverInit: () => {},
				inputReceiverUpdate: () => {}
			};

			// Load character for BOTH host and spectators (spectators get full boxman now!)
			loadingManager.loadGLTF('build/assets/boxman.glb', (charModel) => {
				if (isSpectatorMode) {
					console.log('👻 Spectator mode - loading full boxman character with physics!');
				} else {
					console.log('👤 Host mode - loading character');
				}
					// Apply saved customization colors IMMEDIATELY to the model before creating Character
					let savedCustomization = localStorage.getItem('characterCustomization');
					if (savedCustomization) {
						let customizationData = JSON.parse(savedCustomization);
						let skinColor = customizationData.skinColor || '#bee17b';
						let shirtColor = customizationData.shirtColor || '#282828';
						let pantsColor = customizationData.pantsColor || '#282828';
						let hatColor = customizationData.hatColor || '#282828';

						console.log('🎨 Applying saved colors to character BEFORE first render...');
						charModel.scene.traverse((child) => {
							if (child.isMesh && child.material) {
								const materialName = child.material.name.toLowerCase();

								// Skip TAPE and character FACE materials entirely - NEVER TOUCH THEM!
								if (materialName.includes('tape')) {
									console.log('  ⏭️ Skipping TAPE material - NEVER MODIFIED');
									return; // ABSOLUTELY DO NOT TOUCH TAPE
								}
								if (materialName.includes('face') && !materialName.includes('speaker')) {
									console.log('  ⏭️ Skipping protected FACE material:', child.material.name);
									return; // Don't modify character face material
								}

								if (materialName.includes('skin')) {
									child.material.color.set(skinColor);
									console.log('  ✓ Skin:', skinColor);
								} else if (materialName.includes('shirt')) {
									child.material.color.set(shirtColor);
									console.log('  ✓ Shirt:', shirtColor);
								} else if (materialName.includes('pants')) {
									child.material.color.set(pantsColor);
									console.log('  ✓ Pants:', pantsColor);
								} else if (materialName.includes('hat')) {
									child.material.color.set(hatColor);
									console.log('  ✓ Hat:', hatColor);
								}
								child.material.needsUpdate = true;
							}
						});
					}

					// Create Sketchbook.Character instance with full physics and animations
					window.character = character = new Sketchbook.Character(charModel);

					if (isSpectatorMode) {
						// Spectator spawns at portal location
						character.setPosition(50, 15, 5);
						// Face towards the speaker/computer area (negative X direction)
						character.setOrientation(new THREE.Vector3(-1, 0, 0), true);
						console.log('👻 Spectator character spawned at portal (50, 15, 5) facing speakers');
					} else {
						// Host spawns at default location
						character.setPosition(5, 2, 0);
						console.log('👤 Host character spawned at (5, 2, 0)');
					}

					world.add(character);
					character.takeControl(); // Give character control (works for both host and spectators)

					// Mark character as ready for spectator
					if (isSpectatorMode) {
						window.spectatorCharacterReady = true;
						console.log('🎮 Spectator character loaded and ready');
					}

					// Create THREE.js sprite name tag for local character
					const username = window.authState?.user?.username || window.authState?.user?.displayName || window.authState?.email?.split('@')[0] || 'USER';
					const nameTagSprite = window.createNameTagSprite(username);
					nameTagSprite.position.set(0, 0.75, 0); // Position just above character head
					nameTagSprite.visible = false; // Hide own name tag (others will still see it in multiplayer)
					character.add(nameTagSprite); // Attach to character so it moves with them
					window.localNameTag = nameTagSprite;
					console.log('🏷️ Created name tag sprite for local character (hidden):', username);

				// Add audio listener to the camera for spatial audio
				world.camera.add(audioListener);

				// Set initial camera angle
				setTimeout(() => {
					if (isSpectatorMode) {
						world.cameraOperator.theta = 90; // 90 degrees - behind character (positive X, character faces negative X)
						world.cameraOperator.phi = 0; // Level with character

						// Mark camera as ready for spectator
						window.spectatorCameraReady = true;
						console.log('📷 Spectator camera positioned and ready');
					} else {
						world.cameraOperator.theta = 180; // Front facing for host
					}
				}, 100);

				// Only create customization UI for host (not spectators)
				if (!isSpectatorMode) {
					// Create dark sleek floating button in bottom-right
					setTimeout(() => {
					const customizeButton = document.createElement('button');
					customizeButton.className = 'customize-button';
					customizeButton.innerHTML = 'Customize';
					document.body.appendChild(customizeButton);
					console.log('✅ Dark sleek button created!');

					// Create controls panel
					const controlsPanel = document.createElement('div');
					controlsPanel.className = 'controls-panel';
					controlsPanel.innerHTML = `
						<div style="font-weight: bold; margin-bottom: 8px; color: #bee17b;">CONTROLS</div>
						<div>WASD - Move</div>
						<div>Mouse - Look</div>
						<div>Shift - Sprint</div>
						<div>Space - Jump</div>
						<div>E - Aim Mode (hold)</div>
						<div>F - Interact</div>
						<div>C - Customize</div>
					`;
					document.body.appendChild(controlsPanel);

				// Create custom character customization UI
				const customizationDiv = document.createElement('div');
				customizationDiv.className = 'character-customization';

				const textures = [
					{ name: 'solid', display: 'Solid' },
					{ name: 'stripes', display: 'Stripes' },
					{ name: 'dots', display: 'Dots' },
					{ name: 'checker', display: 'Checker' },
					{ name: 'grid', display: 'Grid' },
					{ name: 'diagonal', display: 'Diagonal' },
					{ name: 'waves', display: 'Waves' },
					{ name: 'stars', display: 'Stars' }
				];

				customizationDiv.innerHTML = `
					<h3>Customization</h3>
					<div class="customization-tabs">
						<button class="customization-tab active" data-tab="character">Character</button>
						<button class="customization-tab" data-tab="environment">Environment</button>
					</div>
					<div class="customization-content" id="character-tab">
						<div class="customization-section">
							<div class="section-label">Skin</div>
							<div class="color-picker-container">
								<input type="color" id="skin-color-picker" value="#bee17b">
								<div class="color-info">
									<div class="color-info-label">Current Color</div>
									<div class="color-info-value" id="skin-color-value">#BEE17B</div>
								</div>
							</div>
						</div>

						<div class="customization-section">
							<div class="section-label">Shirt</div>
							<div class="color-picker-container">
								<input type="color" id="shirt-color-picker" value="#ff1400">
								<div class="color-info">
									<div class="color-info-label">Current Color</div>
									<div class="color-info-value" id="shirt-color-value">#FF1400</div>
								</div>
							</div>
						</div>

						<div class="customization-section">
							<div class="section-label">Pants</div>
							<div class="color-picker-container">
								<input type="color" id="pants-color-picker" value="#0f00ff">
								<div class="color-info">
									<div class="color-info-label">Current Color</div>
									<div class="color-info-value" id="pants-color-value">#0F00FF</div>
								</div>
							</div>
						</div>

						<div class="customization-section">
							<div class="section-label">Hat</div>
							<div class="color-picker-container">
								<input type="color" id="hat-color-picker" value="#191919">
								<div class="color-info">
									<div class="color-info-label">Current Color</div>
									<div class="color-info-value" id="hat-color-value">#191919</div>
								</div>
							</div>
						</div>
					</div>
					<div class="customization-content" id="environment-tab" style="display: none;">
						<!-- Floor Section -->
						<div class="collapsible-section collapsed">
							<div class="collapsible-header">
								<div class="collapsible-title">Floor</div>
								<div class="collapsible-arrow">▼</div>
							</div>
							<div class="collapsible-content">
								<div class="customization-section">
									<div class="section-label">Grid Glow</div>
									<div class="color-picker-container">
										<input type="color" id="floor-glow-picker" value="#bee17b">
										<div class="color-info">
											<div class="color-info-label">Emissive Color</div>
											<div class="color-info-value" id="floor-glow-value">#BEE17B</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Panel Color</div>
									<div class="color-picker-container">
										<input type="color" id="floor-panel-picker" value="#000000">
										<div class="color-info">
											<div class="color-info-label">Base Color</div>
											<div class="color-info-value" id="floor-panel-value">#000000</div>
										</div>
									</div>
								</div>
							</div>
						</div>

						<!-- Speakers Section -->
						<div class="collapsible-section collapsed">
							<div class="collapsible-header">
								<div class="collapsible-title">Speakers</div>
								<div class="collapsible-arrow">▼</div>
							</div>
							<div class="collapsible-content">
								<div class="customization-section">
									<div class="section-label">Cabinet Color</div>
									<div class="color-picker-container">
										<input type="color" id="speaker-cab-picker" value="#191919">
										<div class="color-info">
											<div class="color-info-label">CAB Material</div>
											<div class="color-info-value" id="speaker-cab-value">#191919</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Trim Color</div>
									<div class="color-picker-container">
										<input type="color" id="speaker-trim-picker" value="#ffffff">
										<div class="color-info">
											<div class="color-info-label">TRIM Material</div>
											<div class="color-info-value" id="speaker-trim-value">#FFFFFF</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Face Color</div>
									<div class="color-picker-container">
										<input type="color" id="speaker-face-picker" value="#000000">
										<div class="color-info">
											<div class="color-info-label">FACE Material</div>
											<div class="color-info-value" id="speaker-face-value">#000000</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Frame Color</div>
									<div class="color-picker-container">
										<input type="color" id="speaker-frame-picker" value="#333333">
										<div class="color-info">
											<div class="color-info-label">FRAME Material</div>
											<div class="color-info-value" id="speaker-frame-value">#333333</div>
										</div>
									</div>
								</div>
							</div>
						</div>

						<!-- Computer Section -->
						<div class="collapsible-section collapsed">
							<div class="collapsible-header">
								<div class="collapsible-title">Computer</div>
								<div class="collapsible-arrow">▼</div>
							</div>
							<div class="collapsible-content">
								<div class="customization-section">
									<div class="section-label">Chassis Color</div>
									<div class="color-picker-container">
										<input type="color" id="computer-chassis-picker" value="#ffffff">
										<div class="color-info">
											<div class="color-info-label">CHASIS Material</div>
											<div class="color-info-value" id="computer-chassis-value">#FFFFFF</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Keyboard Color</div>
									<div class="color-picker-container">
										<input type="color" id="computer-keyboard-picker" value="#191919">
										<div class="color-info">
											<div class="color-info-label">KEYBOARD Material</div>
											<div class="color-info-value" id="computer-keyboard-value">#191919</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Features Color</div>
									<div class="color-picker-container">
										<input type="color" id="computer-features-picker" value="#bee17b">
										<div class="color-info">
											<div class="color-info-label">FEATURES Material</div>
											<div class="color-info-value" id="computer-features-value">#BEE17B</div>
										</div>
									</div>
								</div>
							</div>
						</div>

						<!-- Sky Section -->
						<div class="collapsible-section collapsed">
							<div class="collapsible-header">
								<div class="collapsible-title">Sky</div>
								<div class="collapsible-arrow">▼</div>
							</div>
							<div class="collapsible-content">
								<div class="customization-section">
									<div class="section-label">Top Color</div>
									<div class="color-picker-container">
										<input type="color" id="sky-top-picker" value="#000000">
										<div class="color-info">
											<div class="color-info-label">Gradient Top</div>
											<div class="color-info-value" id="sky-top-value">#0A0A0A</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Top Position</div>
									<div class="slider-container">
										<input type="range" id="sky-top-position" min="0" max="100" value="0" step="1">
										<div class="slider-value" id="sky-top-position-value">0%</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Bottom Color</div>
									<div class="color-picker-container">
										<input type="color" id="sky-bottom-picker" value="#000000">
										<div class="color-info">
											<div class="color-info-label">Gradient Bottom</div>
											<div class="color-info-value" id="sky-bottom-value">#1A1A1A</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Bottom Position</div>
									<div class="slider-container">
										<input type="range" id="sky-bottom-position" min="0" max="100" value="100" step="1">
										<div class="slider-value" id="sky-bottom-position-value">100%</div>
									</div>
								</div>
							</div>
						</div>

						<!-- Car Section -->
						<div class="collapsible-section collapsed">
							<div class="collapsible-header">
								<div class="collapsible-title">Car</div>
								<div class="collapsible-arrow">▼</div>
							</div>
							<div class="collapsible-content">
								<div class="customization-section">
									<div class="section-label">Door Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-door-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">DOOR Material</div>
											<div class="color-info-value" id="car-door-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Frame Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-frame-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">FRAME Material</div>
											<div class="color-info-value" id="car-frame-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Headlights Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-headlights-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">HEADLIGHTS Material</div>
											<div class="color-info-value" id="car-headlights-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Hood Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-hood-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">HOOD Material</div>
											<div class="color-info-value" id="car-hood-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Interior Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-interior-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">INTERIOR Material</div>
											<div class="color-info-value" id="car-interior-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Rims Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-rim-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">RIMS Material</div>
											<div class="color-info-value" id="car-rim-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Steering Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-steering-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">STEERING Material</div>
											<div class="color-info-value" id="car-steering-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Taillights Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-taillights-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">TAILLIGHTS Material</div>
											<div class="color-info-value" id="car-taillights-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Tires Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-tire-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">TIRES Material</div>
											<div class="color-info-value" id="car-tire-value">#282828</div>
										</div>
									</div>
								</div>
								<div class="customization-section">
									<div class="section-label">Trim Color</div>
									<div class="color-picker-container">
										<input type="color" id="car-trim-picker" value="#282828">
										<div class="color-info">
											<div class="color-info-label">TRIM Material</div>
											<div class="color-info-value" id="car-trim-value">#282828</div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
					<div class="customization-footer">
						<button class="reset-defaults-button" id="reset-defaults-btn">Reset to Defaults</button>
					</div>
				`;

				document.body.appendChild(customizationDiv);

				// Tab switching logic
				const tabs = customizationDiv.querySelectorAll('.customization-tab');
				tabs.forEach(tab => {
					tab.addEventListener('click', () => {
						tabs.forEach(t => t.classList.remove('active'));
						tab.classList.add('active');

						const tabName = tab.getAttribute('data-tab');
						document.getElementById('character-tab').style.display = tabName === 'character' ? 'block' : 'none';
						document.getElementById('environment-tab').style.display = tabName === 'environment' ? 'block' : 'none';
					});
				});

				// Collapsible section logic
				const collapsibleHeaders = customizationDiv.querySelectorAll('.collapsible-header');
				collapsibleHeaders.forEach(header => {
					header.addEventListener('click', () => {
						const section = header.parentElement;
						section.classList.toggle('collapsed');
					});
				});

				// Texture generation functions
				function generateTexture(type, color = '#ffffff', density = 1) {
					const canvas = document.createElement('canvas');
					canvas.width = 256;
					canvas.height = 256;
					const ctx = canvas.getContext('2d');

					ctx.fillStyle = color;
					ctx.fillRect(0, 0, 256, 256);

					ctx.strokeStyle = '#000000';
					ctx.fillStyle = '#000000';
					ctx.lineWidth = 4;

					const spacing = 32 / density;

					switch(type) {
						case 'stripes':
							for (let i = 0; i < 256; i += spacing) {
								ctx.fillRect(i, 0, spacing / 2, 256);
							}
							break;
						case 'dots':
							const dotSize = 8 / density;
							for (let y = spacing / 2; y < 256; y += spacing) {
								for (let x = spacing / 2; x < 256; x += spacing) {
									ctx.beginPath();
									ctx.arc(x, y, dotSize, 0, Math.PI * 2);
									ctx.fill();
								}
							}
							break;
						case 'checker':
							for (let y = 0; y < 256; y += spacing) {
								for (let x = 0; x < 256; x += spacing) {
									if ((Math.floor(x / spacing) + Math.floor(y / spacing)) % 2 === 0) {
										ctx.fillRect(x, y, spacing, spacing);
									}
								}
							}
							break;
						case 'grid':
							for (let i = 0; i <= 256; i += spacing) {
								ctx.beginPath();
								ctx.moveTo(i, 0);
								ctx.lineTo(i, 256);
								ctx.stroke();
								ctx.beginPath();
								ctx.moveTo(0, i);
								ctx.lineTo(256, i);
								ctx.stroke();
							}
							break;
						case 'diagonal':
							for (let i = -256; i < 512; i += spacing) {
								ctx.beginPath();
								ctx.moveTo(i, 0);
								ctx.lineTo(i + 256, 256);
								ctx.stroke();
							}
							break;
						case 'waves':
							const waveFreq = 0.05 * density;
							ctx.beginPath();
							for (let x = 0; x <= 256; x += 4) {
								const y = 128 + Math.sin(x * waveFreq) * 40;
								if (x === 0) ctx.moveTo(x, y);
								else ctx.lineTo(x, y);
							}
							ctx.stroke();
							ctx.beginPath();
							for (let x = 0; x <= 256; x += 4) {
								const y = 128 + Math.sin(x * waveFreq + Math.PI) * 40;
								if (x === 0) ctx.moveTo(x, y);
								else ctx.lineTo(x, y);
							}
							ctx.stroke();
							break;
						case 'stars':
							const starCount = Math.floor(20 * density);
							for (let i = 0; i < starCount; i++) {
								const x = Math.random() * 256;
								const y = Math.random() * 256;
								const size = 8 / Math.sqrt(density);
								ctx.beginPath();
								for (let j = 0; j < 5; j++) {
									const angle = (j * 4 * Math.PI) / 5 - Math.PI / 2;
									const radius = j % 2 === 0 ? size : size / 2;
									const px = x + Math.cos(angle) * radius;
									const py = y + Math.sin(angle) * radius;
									if (j === 0) ctx.moveTo(px, py);
									else ctx.lineTo(px, py);
								}
								ctx.closePath();
								ctx.fill();
							}
							break;
					}

					return new THREE.CanvasTexture(canvas);
				}

				// Draw texture previews
				textures.forEach(tex => {
					const previewCanvas = document.getElementById(`texture-preview-${tex.name}`);
					if (previewCanvas) {
						previewCanvas.width = 64;
						previewCanvas.height = 64;
						const ctx = previewCanvas.getContext('2d');

						// Generate a small preview
						const tempCanvas = document.createElement('canvas');
						tempCanvas.width = 64;
						tempCanvas.height = 64;
						const tempCtx = tempCanvas.getContext('2d');

						tempCtx.fillStyle = '#667eea';
						tempCtx.fillRect(0, 0, 64, 64);
						tempCtx.strokeStyle = '#ffffff';
						tempCtx.fillStyle = '#ffffff';
						tempCtx.lineWidth = 2;

						switch(tex.name) {
							case 'stripes':
								for (let i = 0; i < 64; i += 8) {
									tempCtx.fillRect(i, 0, 4, 64);
								}
								break;
							case 'dots':
								for (let y = 8; y < 64; y += 16) {
									for (let x = 8; x < 64; x += 16) {
										tempCtx.beginPath();
										tempCtx.arc(x, y, 3, 0, Math.PI * 2);
										tempCtx.fill();
									}
								}
								break;
							case 'checker':
								for (let y = 0; y < 64; y += 16) {
									for (let x = 0; x < 64; x += 16) {
										if ((x + y) / 16 % 2 === 0) {
											tempCtx.fillRect(x, y, 16, 16);
										}
									}
								}
								break;
							case 'grid':
								for (let i = 0; i <= 64; i += 16) {
									tempCtx.beginPath();
									tempCtx.moveTo(i, 0);
									tempCtx.lineTo(i, 64);
									tempCtx.stroke();
									tempCtx.beginPath();
									tempCtx.moveTo(0, i);
									tempCtx.lineTo(64, i);
									tempCtx.stroke();
								}
								break;
							case 'diagonal':
								for (let i = -64; i < 128; i += 16) {
									tempCtx.beginPath();
									tempCtx.moveTo(i, 0);
									tempCtx.lineTo(i + 64, 64);
									tempCtx.stroke();
								}
								break;
							case 'waves':
								tempCtx.beginPath();
								for (let x = 0; x <= 64; x += 2) {
									const y = 32 + Math.sin(x * 0.2) * 10;
									if (x === 0) tempCtx.moveTo(x, y);
									else tempCtx.lineTo(x, y);
								}
								tempCtx.stroke();
								break;
							case 'stars':
								for (let i = 0; i < 5; i++) {
									const x = 16 + (i % 3) * 16;
									const y = 16 + Math.floor(i / 3) * 16;
									tempCtx.font = '12px Arial';
									tempCtx.fillText('★', x, y);
								}
								break;
						}

						ctx.drawImage(tempCanvas, 0, 0);
					}
				});

				// Load saved customization from localStorage or use defaults
				let savedCustomization = localStorage.getItem('characterCustomization');
				let customizationData = savedCustomization ? JSON.parse(savedCustomization) : {
					skinColor: '#bee17b',
					shirtColor: '#282828',
					pantsColor: '#282828',
					hatColor: '#282828',
					floorGlowColor: '#bee17b',
					floorPanelColor: '#282828',
					speakerCabColor: '#282828',
					speakerTrimColor: '#282828',
					speakerFaceColor: '#282828',
					speakerFrameColor: '#282828',
					computerChassisColor: '#282828',
					computerKeyboardColor: '#191919',
					computerFeaturesColor: '#bee17b',
					carDoorColor: '#282828',
					carFrameColor: '#282828',
					carHeadlightsColor: '#282828',
					carHoodColor: '#282828',
					carInteriorColor: '#282828',
					carRimColor: '#282828',
					carSteeringColor: '#282828',
					carTaillightsColor: '#282828',
					carTireColor: '#282828',
					carTrimColor: '#282828',
					textureType: 'solid',
					textureScale: 1.0,
					textureRotation: 0,
					textureDensity: 1.0
				};

				// Store colors for each part
				let skinColor = customizationData.skinColor;
				let shirtColor = customizationData.shirtColor;
				let pantsColor = customizationData.pantsColor;
				let hatColor = customizationData.hatColor;
				let floorGlowColor = customizationData.floorGlowColor || '#bee17b';
				let floorPanelColor = customizationData.floorPanelColor || '#282828';
				let speakerCabColor = customizationData.speakerCabColor || '#282828';
				let speakerTrimColor = customizationData.speakerTrimColor || '#282828';
				let speakerFaceColor = customizationData.speakerFaceColor || '#282828';
				let speakerFrameColor = customizationData.speakerFrameColor || '#282828';
				let computerChassisColor = customizationData.computerChassisColor || '#282828';
				let computerKeyboardColor = customizationData.computerKeyboardColor || '#191919';
				let computerFeaturesColor = customizationData.computerFeaturesColor || '#bee17b';
				let skyTopColor = customizationData.skyTopColor || '#000000';
				let skyBottomColor = customizationData.skyBottomColor || '#000000';
				let skyTopPosition = customizationData.skyTopPosition !== undefined ? customizationData.skyTopPosition : 0;
				let skyBottomPosition = customizationData.skyBottomPosition !== undefined ? customizationData.skyBottomPosition : 100;
				let carDoorColor = customizationData.carDoorColor || '#282828';
				let carFrameColor = customizationData.carFrameColor || '#282828';
				let carHeadlightsColor = customizationData.carHeadlightsColor || '#282828';
				let carHoodColor = customizationData.carHoodColor || '#282828';
				let carInteriorColor = customizationData.carInteriorColor || '#282828';
				let carRimColor = customizationData.carRimColor || '#282828';
				let carSteeringColor = customizationData.carSteeringColor || '#282828';
				let carTaillightsColor = customizationData.carTaillightsColor || '#282828';
				let carTireColor = customizationData.carTireColor || '#282828';
				let carTrimColor = customizationData.carTrimColor || '#282828';
				let savedCameraTheta, savedCameraPhi, savedCameraRadius;

				// Set colors globally IMMEDIATELY so they're available when assets load
				window.hatColor = hatColor;
				window.speakerCabColor = speakerCabColor;
				window.speakerTrimColor = speakerTrimColor;
				window.speakerFaceColor = speakerFaceColor;
				window.speakerFrameColor = speakerFrameColor;
				window.computerChassisColor = computerChassisColor;
				window.computerKeyboardColor = computerKeyboardColor;
				window.computerFeaturesColor = computerFeaturesColor;
				window.skyTopColor = skyTopColor;
				window.skyBottomColor = skyBottomColor;
				window.carDoorColor = carDoorColor;
				window.carFrameColor = carFrameColor;
				window.carHeadlightsColor = carHeadlightsColor;
				window.carHoodColor = carHoodColor;
				window.carInteriorColor = carInteriorColor;
				window.carRimColor = carRimColor;
				window.carSteeringColor = carSteeringColor;
				window.carTaillightsColor = carTaillightsColor;
				window.carTireColor = carTireColor;
				window.carTrimColor = carTrimColor;

				// Function to save customization to localStorage
				function saveCustomization() {
					const data = {
						skinColor,
						shirtColor,
						pantsColor,
						hatColor,
						floorGlowColor,
						floorPanelColor,
						speakerCabColor,
						speakerTrimColor,
						speakerFaceColor,
						speakerFrameColor,
						computerChassisColor,
						computerKeyboardColor,
						computerFeaturesColor,
						skyTopColor,
						skyBottomColor,
						skyTopPosition,
						skyBottomPosition,
						carDoorColor,
						carFrameColor,
						carHeadlightsColor,
						carHoodColor,
						carInteriorColor,
						carRimColor,
						carSteeringColor,
						carTaillightsColor,
						carTireColor,
						carTrimColor,
						textureType: document.getElementById('texture-type')?.value || 'solid',
						textureScale: parseFloat(document.getElementById('texture-scale')?.value || 1.0),
						textureRotation: parseFloat(document.getElementById('texture-rotation')?.value || 0),
						textureDensity: parseFloat(document.getElementById('texture-density')?.value || 1.0),
						username: window.authState?.user?.username || window.authState?.user?.displayName || window.authState?.email?.split('@')[0] || 'USER',
						photoURL: window.authState?.user?.photoURL || null
					};
					localStorage.setItem('characterCustomization', JSON.stringify(data));
					console.log('💾 Customization saved:', data);

					// Broadcast customization changes LIVE to all spectators
					if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
						multiplayerWs.send(JSON.stringify({
							type: 'customization_update',
							customization: data
						}));
						console.log('📡 Broadcasting customization to spectators');
					}
				}

				function updateCharacter() {
					character.traverse((child) => {
						if (child.isMesh && child.material) {
							const materialName = child.material.name.toLowerCase();

							// Skip TAPE and character FACE materials entirely - NEVER TOUCH THEM!
							if (materialName.includes('tape')) {
								return; // ABSOLUTELY DO NOT TOUCH TAPE
							}
							if (materialName.includes('face') && !materialName.includes('speaker')) {
								return; // Don't modify character face material
							}

							// Apply color based on material name
							if (materialName.includes('skin')) {
								child.material.color.set(skinColor);
							} else if (materialName.includes('shirt')) {
								child.material.color.set(shirtColor);
							} else if (materialName.includes('pants')) {
								child.material.color.set(pantsColor);
							} else if (materialName.includes('hat')) {
								// If hat has username texture, regenerate it with new color
								if (child.material.map && window.authState?.isLoggedIn) {
									child.material.color.set(hatColor);
									// Username now displayed as floating name tag instead of hat texture
								} else {
									child.material.color.set(hatColor);
								}
							}

							// Remove any texture EXCEPT on hat (tape and face already skipped above)
							if (!materialName.includes('hat')) {
								child.material.map = null;
							}
							child.material.needsUpdate = true;
						}
					});
				}

						let isOpeningCustomization = false;

						function openCustomization() {
							if (customizationOpen || isOpeningCustomization) return; // Already open or opening
							isOpeningCustomization = true;

							// Set movement target to zero to slow down naturally (while controls still active)
							character.velocitySimulator.target.set(0, 0, 0);

							// Check velocity every frame until character stops
							let checkStopInterval = setInterval(() => {
								const speed = character.velocity.length();

								// If character is nearly stopped (velocity < 0.1)
								if (speed < 0.1) {
									clearInterval(checkStopInterval);
									window.customizationOpen = customizationOpen = true;
									isOpeningCustomization = false;

									// Disable character controls NOW
									world.inputManager.inputReceiver = window.dummyInputReceiver;

									// Fully stop the character
									character.velocity.set(0, 0, 0);
									character.velocitySimulator.position.set(0, 0, 0);
									character.velocitySimulator.velocity.set(0, 0, 0);
									character.velocitySimulator.target.set(0, 0, 0);
									character.angularVelocity = 0;

									// Save camera position
									savedCameraTheta = world.cameraOperator.theta;
									savedCameraPhi = world.cameraOperator.phi;
									savedCameraRadius = world.cameraOperator.radius;

									// Move camera to front of character
									// Character rotation.y is in radians, theta is also in radians
									// Add PI to face the front (opposite direction of character's facing)
									const characterRotation = character.rotation.y;
									world.cameraOperator.theta = characterRotation + Math.PI;
									world.cameraOperator.phi = 0;
									world.cameraOperator.radius = 2.5;

									// Enable mouse cursor - exit pointer lock
									if (document.pointerLockElement) {
										document.exitPointerLock();
									}

									// Show menu
									customizationDiv.classList.add('active');
									customizeButton.innerHTML = 'Close';
								}
							}, 16); // Check every frame (~60fps)
						}

						function closeCustomization() {
							if (!customizationOpen) return; // Already closed
							window.customizationOpen = customizationOpen = false;

							// Hide menu
							customizationDiv.classList.remove('active');
							customizeButton.innerHTML = 'Customize';

							// Restore camera position
							world.cameraOperator.theta = savedCameraTheta;
							world.cameraOperator.phi = savedCameraPhi;
							world.cameraOperator.radius = savedCameraRadius;

							// Re-enable character controls
							character.takeControl();

							// Re-lock pointer for game controls
							setTimeout(() => {
								world.renderer.domElement.requestPointerLock();
							}, 100);
						}

						function toggleCustomization() {
							if (customizationOpen) {
								closeCustomization();
							} else {
								openCustomization();
							}
						}

						customizeButton.addEventListener('click', toggleCustomization);

						// C key to toggle customization
						document.addEventListener('keydown', (e) => {
							if (e.key === 'c' || e.key === 'C') {
								// Don't toggle if user is typing in an input field
								if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
									return;
								}
								if (!terminalOpen) {
									e.preventDefault();
									e.stopPropagation();
									e.stopImmediatePropagation();
									toggleCustomization();
									return false;
								}
							}
						}, true);

						// ESC key to close customization
						document.addEventListener('keydown', (e) => {
							if (e.key === 'Escape' && customizationOpen) {
								e.preventDefault();
								e.stopPropagation();
								e.stopImmediatePropagation();
								closeCustomization();
								return false;
							}
						}, true);

						// Click outside to lock camera and enable free look (like normal gameplay)
						let cameraLocked = false;
						document.addEventListener('click', (e) => {
							if (customizationOpen) {
								// Check if click is outside the customization menu and customize button
								if (!customizationDiv.contains(e.target) && !customizeButton.contains(e.target)) {
									if (!cameraLocked) {
										// Lock pointer and enable camera control
										cameraLocked = true;
										world.inputManager.inputReceiver = world.cameraOperator;
										world.renderer.domElement.requestPointerLock();
									} else {
										// Unlock pointer - toggle off
										cameraLocked = false;
										world.inputManager.inputReceiver = window.dummyInputReceiver;
										if (document.pointerLockElement) {
											document.exitPointerLock();
										}
									}
								}
							}
						});

						// When pointer lock is released (ESC), restore menu control
						document.addEventListener('pointerlockchange', () => {
							if (customizationOpen && !document.pointerLockElement && cameraLocked) {
								cameraLocked = false;
								world.inputManager.inputReceiver = window.dummyInputReceiver;
							}
						});

					// Color picker input handlers
					const skinColorPicker = document.getElementById('skin-color-picker');
					const shirtColorPicker = document.getElementById('shirt-color-picker');
					const pantsColorPicker = document.getElementById('pants-color-picker');
					const hatColorPicker = document.getElementById('hat-color-picker');
					const floorGlowPicker = document.getElementById('floor-glow-picker');
					const floorPanelPicker = document.getElementById('floor-panel-picker');
					const speakerCabPicker = document.getElementById('speaker-cab-picker');
					const speakerTrimPicker = document.getElementById('speaker-trim-picker');
					const speakerFacePicker = document.getElementById('speaker-face-picker');
					const speakerFramePicker = document.getElementById('speaker-frame-picker');
					const computerChassisPicker = document.getElementById('computer-chassis-picker');
					const computerKeyboardPicker = document.getElementById('computer-keyboard-picker');
					const computerFeaturesPicker = document.getElementById('computer-features-picker');
					const skyTopPicker = document.getElementById('sky-top-picker');
					const skyBottomPicker = document.getElementById('sky-bottom-picker');
					const skyTopPositionSlider = document.getElementById('sky-top-position');
					const skyBottomPositionSlider = document.getElementById('sky-bottom-position');
					const carDoorPicker = document.getElementById('car-door-picker');
					const carFramePicker = document.getElementById('car-frame-picker');
					const carHeadlightsPicker = document.getElementById('car-headlights-picker');
					const carHoodPicker = document.getElementById('car-hood-picker');
					const carInteriorPicker = document.getElementById('car-interior-picker');
					const carRimPicker = document.getElementById('car-rim-picker');
					const carSteeringPicker = document.getElementById('car-steering-picker');
					const carTaillightsPicker = document.getElementById('car-taillights-picker');
					const carTirePicker = document.getElementById('car-tire-picker');
					const carTrimPicker = document.getElementById('car-trim-picker');

					const skinColorValue = document.getElementById('skin-color-value');
					const shirtColorValue = document.getElementById('shirt-color-value');
					const pantsColorValue = document.getElementById('pants-color-value');
					const hatColorValue = document.getElementById('hat-color-value');
					const floorGlowValue = document.getElementById('floor-glow-value');
					const floorPanelValue = document.getElementById('floor-panel-value');
					const speakerCabValue = document.getElementById('speaker-cab-value');
					const speakerTrimValue = document.getElementById('speaker-trim-value');
					const speakerFaceValue = document.getElementById('speaker-face-value');
					const speakerFrameValue = document.getElementById('speaker-frame-value');
					const computerChassisValue = document.getElementById('computer-chassis-value');
					const computerKeyboardValue = document.getElementById('computer-keyboard-value');
					const computerFeaturesValue = document.getElementById('computer-features-value');
					const skyTopValue = document.getElementById('sky-top-value');
					const skyBottomValue = document.getElementById('sky-bottom-value');
					const skyTopPositionValue = document.getElementById('sky-top-position-value');
					const skyBottomPositionValue = document.getElementById('sky-bottom-position-value');
					const carDoorValue = document.getElementById('car-door-value');
					const carFrameValue = document.getElementById('car-frame-value');
					const carHeadlightsValue = document.getElementById('car-headlights-value');
					const carHoodValue = document.getElementById('car-hood-value');
					const carInteriorValue = document.getElementById('car-interior-value');
					const carRimValue = document.getElementById('car-rim-value');
					const carSteeringValue = document.getElementById('car-steering-value');
					const carTaillightsValue = document.getElementById('car-taillights-value');
					const carTireValue = document.getElementById('car-tire-value');
					const carTrimValue = document.getElementById('car-trim-value');

					// Initialize UI with saved values
					skinColorPicker.value = skinColor;
					skinColorValue.textContent = skinColor.toUpperCase();
					shirtColorPicker.value = shirtColor;
					shirtColorValue.textContent = shirtColor.toUpperCase();
					pantsColorPicker.value = pantsColor;
					pantsColorValue.textContent = pantsColor.toUpperCase();
					hatColorPicker.value = hatColor;
					hatColorValue.textContent = hatColor.toUpperCase();
					floorGlowPicker.value = floorGlowColor;
					floorGlowValue.textContent = floorGlowColor.toUpperCase();
					floorPanelPicker.value = floorPanelColor;
					floorPanelValue.textContent = floorPanelColor.toUpperCase();
					speakerCabPicker.value = speakerCabColor;
					speakerCabValue.textContent = speakerCabColor.toUpperCase();
					speakerTrimPicker.value = speakerTrimColor;
					speakerTrimValue.textContent = speakerTrimColor.toUpperCase();
					speakerFacePicker.value = speakerFaceColor;
					speakerFaceValue.textContent = speakerFaceColor.toUpperCase();
					speakerFramePicker.value = speakerFrameColor;
					speakerFrameValue.textContent = speakerFrameColor.toUpperCase();
					computerChassisPicker.value = computerChassisColor;
					computerChassisValue.textContent = computerChassisColor.toUpperCase();
					computerKeyboardPicker.value = computerKeyboardColor;
					computerKeyboardValue.textContent = computerKeyboardColor.toUpperCase();
					computerFeaturesPicker.value = computerFeaturesColor;
					computerFeaturesValue.textContent = computerFeaturesColor.toUpperCase();
					skyTopPicker.value = skyTopColor;
					skyTopValue.textContent = skyTopColor.toUpperCase();
					skyBottomPicker.value = skyBottomColor;
					skyBottomValue.textContent = skyBottomColor.toUpperCase();
					skyTopPositionSlider.value = skyTopPosition;
					skyTopPositionValue.textContent = skyTopPosition + '%';
					skyBottomPositionSlider.value = skyBottomPosition;
					skyBottomPositionValue.textContent = skyBottomPosition + '%';
					carDoorPicker.value = carDoorColor;
					carDoorValue.textContent = carDoorColor.toUpperCase();
					carFramePicker.value = carFrameColor;
					carFrameValue.textContent = carFrameColor.toUpperCase();
					carHeadlightsPicker.value = carHeadlightsColor;
					carHeadlightsValue.textContent = carHeadlightsColor.toUpperCase();
					carHoodPicker.value = carHoodColor;
					carHoodValue.textContent = carHoodColor.toUpperCase();
					carInteriorPicker.value = carInteriorColor;
					carInteriorValue.textContent = carInteriorColor.toUpperCase();
					carRimPicker.value = carRimColor;
					carRimValue.textContent = carRimColor.toUpperCase();
					carSteeringPicker.value = carSteeringColor;
					carSteeringValue.textContent = carSteeringColor.toUpperCase();
					carTaillightsPicker.value = carTaillightsColor;
					carTaillightsValue.textContent = carTaillightsColor.toUpperCase();
					carTirePicker.value = carTireColor;
					carTireValue.textContent = carTireColor.toUpperCase();
					carTrimPicker.value = carTrimColor;
					carTrimValue.textContent = carTrimColor.toUpperCase();

					// Make colors globally accessible for applying to objects loaded later
					window.speakerCabColor = speakerCabColor;
					window.speakerTrimColor = speakerTrimColor;
					window.speakerFaceColor = speakerFaceColor;
					window.speakerFrameColor = speakerFrameColor;
					window.computerChassisColor = computerChassisColor;
					window.computerKeyboardColor = computerKeyboardColor;
					window.computerFeaturesColor = computerFeaturesColor;
					window.skyTopColor = skyTopColor;
					window.skyBottomColor = skyBottomColor;
					window.carDoorColor = carDoorColor;
					window.carFrameColor = carFrameColor;
					window.carHeadlightsColor = carHeadlightsColor;
					window.carHoodColor = carHoodColor;
					window.carInteriorColor = carInteriorColor;
					window.carRimColor = carRimColor;
					window.carSteeringColor = carSteeringColor;
					window.carTaillightsColor = carTaillightsColor;
					window.carTireColor = carTireColor;
					window.carTrimColor = carTrimColor;

					// Apply floor colors immediately
					if (window.groundMesh && window.generateGridTexture) {
						window.generateGridTexture(floorGlowColor, floorPanelColor);
						window.groundMesh.material.emissive.set(floorGlowColor);
						window.groundMesh.material.color.set(floorPanelColor);
					}

					// Apply saved customization immediately
					updateCharacter();

					// Skin color picker
					skinColorPicker.addEventListener('input', (e) => {
						skinColor = e.target.value;
						skinColorValue.textContent = skinColor.toUpperCase();
						updateCharacter();
						saveCustomization();
					});

					// Shirt color picker
					shirtColorPicker.addEventListener('input', (e) => {
						shirtColor = e.target.value;
						shirtColorValue.textContent = shirtColor.toUpperCase();
						updateCharacter();
						saveCustomization();
					});

					// Pants color picker
					pantsColorPicker.addEventListener('input', (e) => {
						pantsColor = e.target.value;
						pantsColorValue.textContent = pantsColor.toUpperCase();
						updateCharacter();
						saveCustomization();
					});

					// Hat color picker
					hatColorPicker.addEventListener('input', (e) => {
						hatColor = e.target.value;
						window.hatColor = hatColor; // Set global so updateHatWithUsername can access it
						hatColorValue.textContent = hatColor.toUpperCase();
						updateCharacter();
						saveCustomization();
					});

					// Floor glow color picker
					floorGlowPicker.addEventListener('input', (e) => {
						floorGlowColor = e.target.value;
						floorGlowValue.textContent = floorGlowColor.toUpperCase();
						if (window.groundMesh && window.generateGridTexture) {
							window.generateGridTexture(floorGlowColor, floorPanelColor);
							window.groundMesh.material.emissive.set(floorGlowColor);
						}
						saveCustomization();
					});

					// Floor panel color picker
					floorPanelPicker.addEventListener('input', (e) => {
						floorPanelColor = e.target.value;
						floorPanelValue.textContent = floorPanelColor.toUpperCase();
						if (window.groundMesh && window.generateGridTexture) {
							window.generateGridTexture(floorGlowColor, floorPanelColor);
							window.groundMesh.material.color.set(floorPanelColor);
						}
						saveCustomization();
					});

					// Speaker cabinet color picker
					speakerCabPicker.addEventListener('input', (e) => {
						speakerCabColor = e.target.value;
						window.speakerCabColor = speakerCabColor; // Update global
						speakerCabValue.textContent = speakerCabColor.toUpperCase();
						if (window.speakers) {
							window.speakers.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'CAB' || matName.toLowerCase().includes('cab')) {
										child.material.color.set(speakerCabColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Speaker trim color picker
					speakerTrimPicker.addEventListener('input', (e) => {
						speakerTrimColor = e.target.value;
						window.speakerTrimColor = speakerTrimColor; // Update global
						speakerTrimValue.textContent = speakerTrimColor.toUpperCase();
						if (window.speakers) {
							window.speakers.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'TRIM' || matName === 'SPEAKER_TRIM' || (matName.toLowerCase().includes('trim') && matName.toLowerCase().includes('speaker'))) {
										child.material.color.set(speakerTrimColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Speaker face color picker
					speakerFacePicker.addEventListener('input', (e) => {
						speakerFaceColor = e.target.value;
						window.speakerFaceColor = speakerFaceColor; // Update global
						speakerFaceValue.textContent = speakerFaceColor.toUpperCase();
						if (window.speakers) {
							window.speakers.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'FACE' || matName.toLowerCase().includes('face')) {
										child.material.color.set(speakerFaceColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Speaker frame color picker
					speakerFramePicker.addEventListener('input', (e) => {
						speakerFrameColor = e.target.value;
						window.speakerFrameColor = speakerFrameColor; // Update global
						speakerFrameValue.textContent = speakerFrameColor.toUpperCase();
						if (window.speakers) {
							window.speakers.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'FRAME' || matName === 'SPEAKER_FRAME' || (matName.toLowerCase().includes('frame') && matName.toLowerCase().includes('speaker'))) {
										child.material.color.set(speakerFrameColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Computer chassis color picker
					computerChassisPicker.addEventListener('input', (e) => {
						computerChassisColor = e.target.value;
						window.computerChassisColor = computerChassisColor; // Update global
						computerChassisValue.textContent = computerChassisColor.toUpperCase();
						if (window.computer) {
							window.computer.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'CHASIS' || matName.toLowerCase().includes('chasis')) {
										child.material.color.set(computerChassisColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Computer keyboard color picker
					computerKeyboardPicker.addEventListener('input', (e) => {
						computerKeyboardColor = e.target.value;
						window.computerKeyboardColor = computerKeyboardColor; // Update global
						computerKeyboardValue.textContent = computerKeyboardColor.toUpperCase();
						if (window.computer) {
							window.computer.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'KEYBOARD' || matName.toLowerCase().includes('keyboard')) {
										child.material.color.set(computerKeyboardColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Computer features color picker
					computerFeaturesPicker.addEventListener('input', (e) => {
						computerFeaturesColor = e.target.value;
						window.computerFeaturesColor = computerFeaturesColor; // Update global
						computerFeaturesValue.textContent = computerFeaturesColor.toUpperCase();
						if (window.computer) {
							window.computer.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'FEATURES' || matName.toLowerCase().includes('features')) {
										child.material.color.set(computerFeaturesColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Function to update sky gradient
					window.updateSkyGradient = function(topColor, bottomColor, topPos, bottomPos) {
						if (!world || !world.graphicsWorld || !world.sky) return;

						// Default positions if not provided
						topPos = topPos !== undefined ? topPos : 0;
						bottomPos = bottomPos !== undefined ? bottomPos : 100;

						// Convert hex colors to THREE.Color
						const topColorObj = new THREE.Color(topColor);
						const bottomColorObj = new THREE.Color(bottomColor);

						// Find the sky sphere mesh and replace its material
						world.sky.traverse((child) => {
							if (child.isMesh && child.geometry && child.geometry.type === 'SphereBufferGeometry') {

								// Check if we already have a custom gradient material
								if (child.material.userData.isCustomSky) {
									// Update existing uniforms
									child.material.uniforms.topColor.value = topColorObj;
									child.material.uniforms.bottomColor.value = bottomColorObj;
									child.material.uniforms.topPosition.value = topPos / 100;
									child.material.uniforms.bottomPosition.value = bottomPos / 100;
									console.log('🌌 Sky gradient updated:', topColor, '@', topPos + '%', '->', bottomColor, '@', bottomPos + '%');
								} else {
									// Create new gradient material
									const gradientMaterial = new THREE.ShaderMaterial({
										uniforms: {
											topColor: { value: topColorObj },
											bottomColor: { value: bottomColorObj },
											topPosition: { value: topPos / 100 },
											bottomPosition: { value: bottomPos / 100 }
										},
										vertexShader: `
											varying vec3 vWorldPosition;
											void main() {
												vec4 worldPosition = modelMatrix * vec4(position, 1.0);
												vWorldPosition = worldPosition.xyz;
												gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
											}
										`,
										fragmentShader: `
											uniform vec3 topColor;
											uniform vec3 bottomColor;
											uniform float topPosition;
											uniform float bottomPosition;
											varying vec3 vWorldPosition;

											void main() {
												// Normalize Y position to 0-1 range
												float h = normalize(vWorldPosition).y;
												float gradientPos = (h + 1.0) / 2.0;

												vec3 finalColor;
												if (gradientPos < topPosition) {
													finalColor = topColor;
												} else if (gradientPos > bottomPosition) {
													finalColor = bottomColor;
												} else {
													float t = (gradientPos - topPosition) / (bottomPosition - topPosition);
													finalColor = mix(topColor, bottomColor, t);
												}

												gl_FragColor = vec4(finalColor, 1.0);
											}
										`,
										side: THREE.BackSide,
										toneMapped: false
									});

									gradientMaterial.userData.isCustomSky = true;
									child.material = gradientMaterial;
									console.log('🌌 Sky gradient material created:', topColor, '@', topPos + '%', '->', bottomColor, '@', bottomPos + '%');
								}
							}
						});
					};

					// Sky top color picker
					skyTopPicker.addEventListener('input', (e) => {
						skyTopColor = e.target.value;
						window.skyTopColor = skyTopColor;
						skyTopValue.textContent = skyTopColor.toUpperCase();
						window.updateSkyGradient(skyTopColor, skyBottomColor, skyTopPosition, skyBottomPosition);
						saveCustomization();
					});

					// Sky bottom color picker
					skyBottomPicker.addEventListener('input', (e) => {
						skyBottomColor = e.target.value;
						window.skyBottomColor = skyBottomColor;
						skyBottomValue.textContent = skyBottomColor.toUpperCase();
						window.updateSkyGradient(skyTopColor, skyBottomColor, skyTopPosition, skyBottomPosition);
						saveCustomization();
					});

					// Sky top position slider
					skyTopPositionSlider.addEventListener('input', (e) => {
						skyTopPosition = parseInt(e.target.value);
						window.skyTopPosition = skyTopPosition;
						skyTopPositionValue.textContent = skyTopPosition + '%';
						window.updateSkyGradient(skyTopColor, skyBottomColor, skyTopPosition, skyBottomPosition);
						saveCustomization();
					});

					// Sky bottom position slider
					skyBottomPositionSlider.addEventListener('input', (e) => {
						skyBottomPosition = parseInt(e.target.value);
						window.skyBottomPosition = skyBottomPosition;
						skyBottomPositionValue.textContent = skyBottomPosition + '%';
						window.updateSkyGradient(skyTopColor, skyBottomColor, skyTopPosition, skyBottomPosition);
						saveCustomization();
					});

					// Car door color picker
					carDoorPicker.addEventListener('input', (e) => {
						carDoorColor = e.target.value;
						window.carDoorColor = carDoorColor;
						carDoorValue.textContent = carDoorColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'DOOR' || matName.toLowerCase().includes('door')) {
										child.material.color.set(carDoorColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car frame color picker
					carFramePicker.addEventListener('input', (e) => {
						carFrameColor = e.target.value;
						window.carFrameColor = carFrameColor;
						carFrameValue.textContent = carFrameColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
										child.material.color.set(carFrameColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car headlights color picker
					carHeadlightsPicker.addEventListener('input', (e) => {
						carHeadlightsColor = e.target.value;
						window.carHeadlightsColor = carHeadlightsColor;
						carHeadlightsValue.textContent = carHeadlightsColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'HEADLIGHTS' || matName.toLowerCase().includes('headlight')) {
										child.material.color.set(carHeadlightsColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car hood color picker
					carHoodPicker.addEventListener('input', (e) => {
						carHoodColor = e.target.value;
						window.carHoodColor = carHoodColor;
						carHoodValue.textContent = carHoodColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'HOOD' || matName.toLowerCase().includes('hood')) {
										child.material.color.set(carHoodColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car interior color picker
					carInteriorPicker.addEventListener('input', (e) => {
						carInteriorColor = e.target.value;
						window.carInteriorColor = carInteriorColor;
						carInteriorValue.textContent = carInteriorColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'INTERIOR' || matName.toLowerCase().includes('interior')) {
										child.material.color.set(carInteriorColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car rims color picker
					carRimPicker.addEventListener('input', (e) => {
						carRimColor = e.target.value;
						window.carRimColor = carRimColor;
						carRimValue.textContent = carRimColor.toUpperCase();
						if (window.car) {
							// Traverse car body
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
										child.material.color.set(carRimColor);
									}
								}
							});
							// Also traverse wheel objects (they're separate)
							if (window.car.wheels) {
								window.car.wheels.forEach((wheel) => {
									wheel.wheelObject.traverse((child) => {
										if (child.isMesh && child.material) {
											const matName = child.material.name;
											if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
												child.material.color.set(carRimColor);
											}
										}
									});
								});
							}
						}
						saveCustomization();
					});

					// Car steering color picker
					carSteeringPicker.addEventListener('input', (e) => {
						carSteeringColor = e.target.value;
						window.carSteeringColor = carSteeringColor;
						carSteeringValue.textContent = carSteeringColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'STEERING' || matName.toLowerCase().includes('steering')) {
										child.material.color.set(carSteeringColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car taillights color picker
					carTaillightsPicker.addEventListener('input', (e) => {
						carTaillightsColor = e.target.value;
						window.carTaillightsColor = carTaillightsColor;
						carTaillightsValue.textContent = carTaillightsColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'TAILLIGHTS' || matName.toLowerCase().includes('taillight')) {
										child.material.color.set(carTaillightsColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Car tires color picker
					carTirePicker.addEventListener('input', (e) => {
						carTireColor = e.target.value;
						window.carTireColor = carTireColor;
						carTireValue.textContent = carTireColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
										child.material.color.set(carTireColor);
									}
								}
							});
							if (window.car.wheels) {
								window.car.wheels.forEach((wheel) => {
									wheel.wheelObject.traverse((child) => {
										if (child.isMesh && child.material) {
											const matName = child.material.name;
											if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
												child.material.color.set(carTireColor);
											}
										}
									});
								});
							}
						}
						saveCustomization();
					});

					// Car trim color picker
					carTrimPicker.addEventListener('input', (e) => {
						carTrimColor = e.target.value;
						window.carTrimColor = carTrimColor;
						carTrimValue.textContent = carTrimColor.toUpperCase();
						if (window.car) {
							window.car.traverse((child) => {
								if (child.isMesh && child.material) {
									const matName = child.material.name;
									if (matName === 'TRIM' || matName.toLowerCase().includes('trim')) {
										child.material.color.set(carTrimColor);
									}
								}
							});
						}
						saveCustomization();
					});

					// Reset to Defaults button
					const resetButton = document.getElementById('reset-defaults-btn');
					resetButton.addEventListener('click', () => {
						if (confirm('Reset all colors to defaults? This will clear your saved customization.')) {
							// Clear localStorage
							localStorage.removeItem('characterCustomization');

							// Define default colors
							const defaults = {
								skinColor: '#bee17b',
								shirtColor: '#282828',
								pantsColor: '#282828',
								hatColor: '#282828',
								floorGlowColor: '#bee17b',
								floorPanelColor: '#282828',
								speakerCabColor: '#282828',
								speakerTrimColor: '#282828',
								speakerFaceColor: '#282828',
								speakerFrameColor: '#282828',
								computerChassisColor: '#282828',
								computerKeyboardColor: '#191919',
								computerFeaturesColor: '#bee17b',
								skyTopColor: '#000000',
								skyBottomColor: '#000000',
								skyTopPosition: 0,
								skyBottomPosition: 100,
								carDoorColor: '#282828',
								carFrameColor: '#282828',
								carHeadlightsColor: '#282828',
								carHoodColor: '#282828',
								carInteriorColor: '#282828',
								carRimColor: '#282828',
								carSteeringColor: '#282828',
								carTaillightsColor: '#282828',
								carTireColor: '#282828',
								carTrimColor: '#282828'
							};

							// Update all pickers and values
							skinColorPicker.value = defaults.skinColor;
							skinColorValue.textContent = defaults.skinColor.toUpperCase();
							skinColor = defaults.skinColor;

							shirtColorPicker.value = defaults.shirtColor;
							shirtColorValue.textContent = defaults.shirtColor.toUpperCase();
							shirtColor = defaults.shirtColor;

							pantsColorPicker.value = defaults.pantsColor;
							pantsColorValue.textContent = defaults.pantsColor.toUpperCase();
							pantsColor = defaults.pantsColor;

							hatColorPicker.value = defaults.hatColor;
							hatColorValue.textContent = defaults.hatColor.toUpperCase();
							hatColor = defaults.hatColor;

							floorGlowPicker.value = defaults.floorGlowColor;
							floorGlowValue.textContent = defaults.floorGlowColor.toUpperCase();
							floorGlowColor = defaults.floorGlowColor;

							floorPanelPicker.value = defaults.floorPanelColor;
							floorPanelValue.textContent = defaults.floorPanelColor.toUpperCase();
							floorPanelColor = defaults.floorPanelColor;

							speakerCabPicker.value = defaults.speakerCabColor;
							speakerCabValue.textContent = defaults.speakerCabColor.toUpperCase();
							speakerCabColor = defaults.speakerCabColor;

							speakerTrimPicker.value = defaults.speakerTrimColor;
							speakerTrimValue.textContent = defaults.speakerTrimColor.toUpperCase();
							speakerTrimColor = defaults.speakerTrimColor;

							speakerFacePicker.value = defaults.speakerFaceColor;
							speakerFaceValue.textContent = defaults.speakerFaceColor.toUpperCase();
							speakerFaceColor = defaults.speakerFaceColor;

							speakerFramePicker.value = defaults.speakerFrameColor;
							speakerFrameValue.textContent = defaults.speakerFrameColor.toUpperCase();
							speakerFrameColor = defaults.speakerFrameColor;

							computerChassisPicker.value = defaults.computerChassisColor;
							computerChassisValue.textContent = defaults.computerChassisColor.toUpperCase();
							computerChassisColor = defaults.computerChassisColor;

							computerKeyboardPicker.value = defaults.computerKeyboardColor;
							computerKeyboardValue.textContent = defaults.computerKeyboardColor.toUpperCase();
							computerKeyboardColor = defaults.computerKeyboardColor;

							computerFeaturesPicker.value = defaults.computerFeaturesColor;
							computerFeaturesValue.textContent = defaults.computerFeaturesColor.toUpperCase();
							computerFeaturesColor = defaults.computerFeaturesColor;

							skyTopPicker.value = defaults.skyTopColor;
							skyTopValue.textContent = defaults.skyTopColor.toUpperCase();
							skyTopColor = defaults.skyTopColor;

							skyBottomPicker.value = defaults.skyBottomColor;
							skyBottomValue.textContent = defaults.skyBottomColor.toUpperCase();
							skyBottomColor = defaults.skyBottomColor;

							skyTopPositionSlider.value = defaults.skyTopPosition;
							skyTopPositionValue.textContent = defaults.skyTopPosition + '%';
							skyTopPosition = defaults.skyTopPosition;

							skyBottomPositionSlider.value = defaults.skyBottomPosition;
							skyBottomPositionValue.textContent = defaults.skyBottomPosition + '%';
							skyBottomPosition = defaults.skyBottomPosition;

							carDoorPicker.value = defaults.carDoorColor;
							carDoorValue.textContent = defaults.carDoorColor.toUpperCase();
							carDoorColor = defaults.carDoorColor;

							carFramePicker.value = defaults.carFrameColor;
							carFrameValue.textContent = defaults.carFrameColor.toUpperCase();
							carFrameColor = defaults.carFrameColor;

							carHeadlightsPicker.value = defaults.carHeadlightsColor;
							carHeadlightsValue.textContent = defaults.carHeadlightsColor.toUpperCase();
							carHeadlightsColor = defaults.carHeadlightsColor;

							carHoodPicker.value = defaults.carHoodColor;
							carHoodValue.textContent = defaults.carHoodColor.toUpperCase();
							carHoodColor = defaults.carHoodColor;

							carInteriorPicker.value = defaults.carInteriorColor;
							carInteriorValue.textContent = defaults.carInteriorColor.toUpperCase();
							carInteriorColor = defaults.carInteriorColor;

							carRimPicker.value = defaults.carRimColor;
							carRimValue.textContent = defaults.carRimColor.toUpperCase();
							carRimColor = defaults.carRimColor;

							carSteeringPicker.value = defaults.carSteeringColor;
							carSteeringValue.textContent = defaults.carSteeringColor.toUpperCase();
							carSteeringColor = defaults.carSteeringColor;

							carTaillightsPicker.value = defaults.carTaillightsColor;
							carTaillightsValue.textContent = defaults.carTaillightsColor.toUpperCase();
							carTaillightsColor = defaults.carTaillightsColor;

							carTirePicker.value = defaults.carTireColor;
							carTireValue.textContent = defaults.carTireColor.toUpperCase();
							carTireColor = defaults.carTireColor;

							carTrimPicker.value = defaults.carTrimColor;
							carTrimValue.textContent = defaults.carTrimColor.toUpperCase();
							carTrimColor = defaults.carTrimColor;

							// Update globals
							window.speakerCabColor = defaults.speakerCabColor;
							window.speakerTrimColor = defaults.speakerTrimColor;
							window.speakerFaceColor = defaults.speakerFaceColor;
							window.speakerFrameColor = defaults.speakerFrameColor;
							window.computerChassisColor = defaults.computerChassisColor;
							window.computerKeyboardColor = defaults.computerKeyboardColor;
							window.computerFeaturesColor = defaults.computerFeaturesColor;
							window.skyTopColor = defaults.skyTopColor;
							window.skyBottomColor = defaults.skyBottomColor;
							window.skyTopPosition = defaults.skyTopPosition;
							window.skyBottomPosition = defaults.skyBottomPosition;
							window.carDoorColor = defaults.carDoorColor;
							window.carFrameColor = defaults.carFrameColor;
							window.carHeadlightsColor = defaults.carHeadlightsColor;
							window.carHoodColor = defaults.carHoodColor;
							window.carInteriorColor = defaults.carInteriorColor;
							window.carRimColor = defaults.carRimColor;
							window.carSteeringColor = defaults.carSteeringColor;
							window.carTaillightsColor = defaults.carTaillightsColor;
							window.carTireColor = defaults.carTireColor;
							window.carTrimColor = defaults.carTrimColor;

							// Apply to character
							updateCharacter();

							// Apply to floor
							if (window.groundMesh && window.generateGridTexture) {
								window.generateGridTexture(defaults.floorGlowColor, defaults.floorPanelColor);
								window.groundMesh.material.emissive.set(defaults.floorGlowColor);
								window.groundMesh.material.color.set(defaults.floorPanelColor);
								window.groundMesh.material.needsUpdate = true;
							}

							// Apply to speakers
							if (window.speakers) {
								window.speakers.traverse((child) => {
									if (child.isMesh && child.material) {
										const matName = child.material.name;
										if (matName === 'CAB' || matName.toLowerCase().includes('cab')) {
											child.material.color.set(defaults.speakerCabColor);
										} else if (matName === 'TRIM' || matName === 'SPEAKER_TRIM' || (matName.toLowerCase().includes('trim') && matName.toLowerCase().includes('speaker'))) {
											child.material.color.set(defaults.speakerTrimColor);
										} else if (matName === 'FACE' || matName.toLowerCase().includes('face')) {
											child.material.color.set(defaults.speakerFaceColor);
										} else if (matName === 'FRAME' || matName === 'SPEAKER_FRAME' || (matName.toLowerCase().includes('frame') && matName.toLowerCase().includes('speaker'))) {
											child.material.color.set(defaults.speakerFrameColor);
										}
										child.material.needsUpdate = true;
									}
								});
							}

							// Apply to computer
							if (window.computer) {
								window.computer.traverse((child) => {
									if (child.isMesh && child.material) {
										const matName = child.material.name;
										if (matName === 'CHASIS' || matName.toLowerCase().includes('chasis')) {
											child.material.color.set(defaults.computerChassisColor);
										} else if (matName === 'KEYBOARD' || matName.toLowerCase().includes('keyboard')) {
											child.material.color.set(defaults.computerKeyboardColor);
										} else if (matName === 'FEATURES' || matName.toLowerCase().includes('features')) {
											child.material.color.set(defaults.computerFeaturesColor);
										}
										child.material.needsUpdate = true;
									}
								});
							}

							// Apply to sky
							if (window.updateSkyGradient) {
								window.updateSkyGradient(defaults.skyTopColor, defaults.skyBottomColor, defaults.skyTopPosition, defaults.skyBottomPosition);
							}

							// Apply to car
							if (window.car) {
								window.car.traverse((child) => {
									if (child.isMesh && child.material) {
										const matName = child.material.name;
										if (matName === 'DOOR' || matName.toLowerCase().includes('door')) {
											child.material.color.set(defaults.carDoorColor);
										} else if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
											child.material.color.set(defaults.carFrameColor);
										} else if (matName === 'HEADLIGHTS' || matName.toLowerCase().includes('headlight')) {
											child.material.color.set(defaults.carHeadlightsColor);
										} else if (matName === 'HOOD' || matName.toLowerCase().includes('hood')) {
											child.material.color.set(defaults.carHoodColor);
										} else if (matName === 'INTERIOR' || matName.toLowerCase().includes('interior')) {
											child.material.color.set(defaults.carInteriorColor);
										} else if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
											child.material.color.set(defaults.carRimColor);
										} else if (matName === 'STEERING' || matName.toLowerCase().includes('steering')) {
											child.material.color.set(defaults.carSteeringColor);
										} else if (matName === 'TAILLIGHTS' || matName.toLowerCase().includes('taillight')) {
											child.material.color.set(defaults.carTaillightsColor);
										} else if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
											child.material.color.set(defaults.carTireColor);
										} else if (matName === 'TRIM' || matName.toLowerCase().includes('trim')) {
											child.material.color.set(defaults.carTrimColor);
										}
										child.material.needsUpdate = true;
									}
								});
								if (window.car.wheels) {
									window.car.wheels.forEach((wheel) => {
										wheel.wheelObject.traverse((child) => {
											if (child.isMesh && child.material) {
												const matName = child.material.name;
												if (matName === 'RIMS' || matName.toLowerCase().includes('rim')) {
													child.material.color.set(defaults.carRimColor);
												} else if (matName === 'TIRES' || matName.toLowerCase().includes('tire')) {
													child.material.color.set(defaults.carTireColor);
												}
												child.material.needsUpdate = true;
											}
										});
									});
								}
							}

							saveCustomization();
							console.log('✅ Reset to defaults complete!');
						}
					});
				}, 1000);
				} // End of if (!isSpectatorMode) - customization UI only for host
			}); // End of loadingManager.loadGLTF for character (runs for BOTH host and spectators)

			// Create OS system
			const osDiv = document.createElement('div');
			osDiv.className = 'terminal-login';
			osDiv.innerHTML = `
				<div class="os-container">
					<!-- OS Taskbar -->
					<div class="os-taskbar">
						<div class="os-logo">SUBLAIR OS v1.0</div>
						<div class="os-taskbar-apps">
							<div class="taskbar-app active" data-app="desktop">
								[DESKTOP]
							</div>
							<div class="taskbar-app" data-app="music">
								[MUSIC]
							</div>
							<div class="taskbar-app" data-app="files">
								[FILES]
							</div>
							<div class="taskbar-app" data-app="chat">
								[CHAT]
							</div>
							<div class="taskbar-app" data-app="multiplayer">
								[MULTIPLAYER]
							</div>
						</div>
						<div class="om-currency">
							<span class="om-currency-symbol">Ω</span>
							<span id="om-count">0</span>
						</div>
						<button class="desktop-profile-btn" id="profile-btn">
							<span id="profile-status">GUEST</span>
						</button>
						<div class="os-close" id="os-close">[X]</div>
					</div>

					<!-- Desktop View -->
					<div class="os-view" id="desktop-view">
						<div class="desktop-split">

							<div class="desktop-icons">
								<div class="desktop-icon" data-app="music">
									<div class="icon">[S]</div>
									<div class="label">SUBLAIR.EXE</div>
								</div>
								<div class="desktop-icon" data-app="files">
									<div class="icon">[D]</div>
									<div class="label">DEEPWAVES.EXE</div>
								</div>
								<div class="desktop-icon" data-app="chat">
									<div class="icon">[C]</div>
									<div class="label">CHAT.EXE</div>
								</div>
								<div class="desktop-icon" data-app="multiplayer">
									<div class="icon">[M]</div>
									<div class="label">MULTIPLAYER.EXE</div>
								</div>
							</div>
							<div class="desktop-audio-player">
								<div class="audio-player-header" style="display: flex; align-items: center;">
									<span>♪ MEDIA PLAYER</span>
									<button class="taskbar-app" data-app="eq" style="margin-left: auto; padding: 6px 12px; background: #000; color: #bee17b; border: 1px solid #bee17b; font-family: 'Share', monospace; cursor: pointer; font-size: 12px; transition: all 0.2s;">[EQ]</button>
								</div>
								<div class="audio-player-body">
									<div class="audio-album-art-container">
										<div id="desktop-album-art">NO ARTWORK</div>
									</div>
									<div class="audio-info-controls">
										<div id="desktop-track-title" class="track-title-display">NO TRACK LOADED</div>
										<div id="desktop-artist-name" class="artist-name-display"></div>
										<div id="desktop-audio-controls" class="audio-controls">
											<button id="audio-play-pause" class="audio-btn" disabled>▶ PLAY</button>
											<button id="audio-stop" class="audio-btn" disabled>■ STOP</button>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>

					<!-- Music Player App -->
					<div class="os-view" id="music-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">MUSIC PLAYER v1.0</div>
								<input type="text" id="search-input" placeholder="Search tracks..." />
								<button class="taskbar-app" data-app="eq" style="margin-left: 10px; padding: 8px 16px; background: #000; color: #bee17b; border: 1px solid #bee17b; font-family: 'Share', monospace; cursor: pointer; transition: all 0.2s;">[EQ]</button>
							</div>
							<div class="app-content">
								<div id="tracks-container">
									<div style="text-align: center; color: #bee17b; padding: 20px;">Loading tracks...</div>
								</div>
							</div>
						</div>
					</div>

					<!-- EQ App -->
					<div class="os-view" id="eq-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">EQUALIZER v1.0</div>
							</div>
							<div class="app-content">
								<!-- Visualizer -->
								<div style="background: #000; border: 2px solid #bee17b; padding: 15px; margin-bottom: 10px;">
									<div style="color: #bee17b; font-weight: bold; margin-bottom: 10px; font-size: 14px;">[FREQUENCY ANALYZER]</div>
									<canvas id="eq-visualizer" width="800" height="120" style="width: 100%; height: 120px; background: #000; border: 1px solid #bee17b;"></canvas>

									<!-- dB Meter -->
									<div style="margin-top: 15px;">
										<div style="color: #bee17b; font-weight: bold; margin-bottom: 8px; font-size: 12px; display: flex; justify-content: space-between; align-items: center;">
											<span>[dB METER]</span>
											<span id="clip-indicator" style="color: #ff0000; font-weight: bold; opacity: 0; transition: opacity 0.1s;">CLIP</span>
										</div>
										<canvas id="db-meter" width="800" height="40" style="width: 100%; height: 40px; background: #000; border: 1px solid #bee17b;"></canvas>
									</div>

									<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px; font-size: 12px;">
										<div style="color: #bee17b;">PEAK: <span id="peak-db">-∞ dB</span></div>
										<div style="color: #bee17b;">RMS: <span id="rms-db">-∞ dB</span></div>
										<div style="color: #bee17b;">LUFS: <span id="lufs-value">-∞ LUFS</span></div>
										<div style="color: #bee17b;">PEAK LUFS: <span id="peak-lufs">-∞ LUFS</span></div>
									</div>
									<button id="reset-peak-lufs" class="audio-btn" style="margin-top: 10px; width: 100%;">[RESET PEAK]</button>
								</div>

								<!-- 3-Band EQ -->
								<div style="background: #000; border: 2px solid #bee17b; padding: 15px; margin-bottom: 10px;">
									<div style="color: #bee17b; font-weight: bold; margin-bottom: 10px; font-size: 14px;">[3-BAND EQUALIZER]</div>
									<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">LOW</label>
											<input type="range" id="eq-low" min="-12" max="12" value="0" step="0.5" style="width: 100%;" />
											<div id="eq-low-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">0 dB</div>
										</div>
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">MID</label>
											<input type="range" id="eq-mid" min="-12" max="12" value="0" step="0.5" style="width: 100%;" />
											<div id="eq-mid-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">0 dB</div>
										</div>
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">HIGH</label>
											<input type="range" id="eq-high" min="-12" max="12" value="0" step="0.5" style="width: 100%;" />
											<div id="eq-high-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">0 dB</div>
										</div>
									</div>
								</div>

								<!-- Filters -->
								<div style="background: #000; border: 2px solid #bee17b; padding: 15px; margin-bottom: 10px;">
									<div style="color: #bee17b; font-weight: bold; margin-bottom: 10px; font-size: 14px;">[FILTERS]</div>
									<div style="margin-bottom: 15px;">
										<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">MASTER VOLUME</label>
										<input type="range" id="master-volume" min="0" max="100" value="100" step="1" style="width: 100%;" />
										<div id="master-volume-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">100%</div>
									</div>
									<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">LOW PASS</label>
											<input type="range" id="filter-lowpass" min="20" max="20000" value="20000" step="10" style="width: 100%;" />
											<div id="filter-lowpass-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">20000 Hz</div>
										</div>
										<div>
											<label style="color: #bee17b; font-size: 12px; display: block; margin-bottom: 5px;">HIGH PASS</label>
											<input type="range" id="filter-highpass" min="20" max="20000" value="20" step="10" style="width: 100%;" />
											<div id="filter-highpass-value" style="color: #bee17b; font-size: 11px; text-align: center; margin-top: 3px;">20 Hz</div>
										</div>
									</div>
								</div>

								<button id="eq-reset" class="audio-btn" style="width: 100%;">[RESET ALL]</button>
							</div>
						</div>
					</div>

					<!-- Text Reader App -->
					<div class="os-view" id="text-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">TEXT READER v1.0</div>
								<div class="file-path" id="text-file-name">UNTITLED.TXT</div>
								<button id="text-close" class="audio-btn" style="margin-left: auto; width: auto;">[CLOSE]</button>
							</div>
							<div class="app-content">
								<div id="text-content" style="font-family: 'Share', 'Courier New', monospace; color: #bee17b; line-height: 1.6; white-space: pre-wrap; padding: 20px; background: #000;"></div>
							</div>
						</div>
					</div>

					<!-- Chat View -->
					<div class="os-view" id="chat-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">CHAT.EXE v1.0</div>
								<div class="file-path">SUBLAIR GLOBAL CHAT</div>
							</div>
							<div class="app-content" style="display: flex; flex-direction: row; height: 100%;">
								<!-- Messages Area -->
								<div style="flex: 1; display: flex; flex-direction: column;">
									<div id="os-chat-messages" style="flex: 1; overflow-y: auto; padding: 20px; background: #000; font-family: 'Share', monospace; color: #bee17b; font-size: 14px;">
										<div style="color: #666; text-align: center; padding: 20px;">
											[CONNECTING TO CHAT SERVER...]
										</div>
									</div>
									<div style="padding: 15px; background: #111; border-top: 1px solid #bee17b; display: flex; gap: 10px;">
										<input type="text" id="os-chat-input" placeholder="Type message..." style="flex: 1; padding: 10px; background: #000; border: 1px solid #bee17b; color: #bee17b; font-family: 'Share', monospace; font-size: 14px;" />
										<button id="os-chat-send" class="audio-btn" style="width: auto; padding: 10px 20px;">[SEND]</button>
									</div>
								</div>
								<!-- Online Users Sidebar -->
								<div style="width: 250px; border-left: 1px solid #bee17b; background: #000; display: flex; flex-direction: column;">
									<div style="padding: 15px; border-bottom: 1px solid #bee17b; font-family: 'Share', monospace; color: #bee17b; font-weight: bold; font-size: 14px;">
										ONLINE USERS (<span id="online-count">0</span>)
									</div>
									<div id="online-users" style="flex: 1; overflow-y: auto; padding: 10px; font-family: 'Share', monospace; font-size: 13px;">
										<div style="color: #666; text-align: center; padding: 20px;">
											[LOADING...]
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>

					<!-- DEEPWAVES File Browser -->
					<div class="os-view" id="files-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">DEEPWAVES.EXE v1.0</div>
								<div class="file-path" id="current-path">C:\DEEPWAVES\</div>
								<button id="files-refresh" class="audio-btn" style="width: auto; margin-left: auto;">[REFRESH]</button>
							</div>
							<div class="app-content">
								<!-- Toolbar -->
								<div style="background: #111; border-bottom: 2px solid #bee17b; padding: 12px; display: flex; gap: 10px; align-items: center;">
									<button id="files-back" class="audio-btn" style="width: auto; padding: 8px 16px;" disabled>[← BACK]</button>
									<input type="text" id="files-search" placeholder="Search files..." style="flex: 1; padding: 8px 12px; background: #000; border: 1px solid #bee17b; color: #bee17b; font-family: 'Share', monospace; font-size: 13px;" />
									<div style="color: #bee17b; font-size: 12px; white-space: nowrap;">
										<span id="file-count">0</span> FILES | <span id="folder-count">0</span> FOLDERS
									</div>
								</div>

								<!-- File Browser Container -->
								<div style="display: flex; height: calc(100% - 60px);">
									<!-- Main File List -->
									<div style="flex: 1; overflow-y: auto; background: #000;">
										<div id="files-container" style="padding: 15px;">
											<div style="text-align: center; color: #bee17b; padding: 40px 20px;">
												[LOADING FILES...]
											</div>
										</div>
									</div>

									<!-- File Details Sidebar -->
									<div id="file-details-panel" style="width: 280px; border-left: 2px solid #bee17b; background: #000; overflow-y: auto; display: none;">
										<div style="padding: 15px; border-bottom: 1px solid #bee17b; font-family: 'Share', monospace; color: #bee17b; font-weight: bold; font-size: 14px;">
											[FILE DETAILS]
										</div>
										<div id="file-details-content" style="padding: 15px; font-family: 'Share', monospace; font-size: 12px; color: #bee17b;">
											<!-- Details will be populated here -->
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>

					<!-- Multiplayer View -->
					<div class="os-view" id="multiplayer-view" style="display: none;">
						<div class="app-window">
							<div class="app-header">
								<div class="app-title">MULTIPLAYER.EXE v1.0</div>
							</div>
							<div class="app-content" style="padding: 30px; display: flex; gap: 20px; height: 100%;">
								<!-- Host Section -->
								<div style="flex: 1; background: #000; border: 2px solid #bee17b; padding: 30px; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
									<div style="font-size: 18px; font-weight: bold; color: #bee17b; margin-bottom: 30px; text-align: center;">[HOST SESSION]</div>
									<button id="host-session-btn" class="audio-btn" style="width: 100%; max-width: 300px; padding: 20px; font-size: 16px;">[START HOSTING]</button>
									<div id="session-code-display" style="display: none; margin-top: 30px; text-align: center; width: 100%;">
										<div style="color: #bee17b; font-size: 13px; margin-bottom: 10px;">SESSION CODE:</div>
										<div id="generated-code" style="color: #bee17b; font-size: 32px; font-weight: bold; letter-spacing: 4px; padding: 20px; background: #111; border: 2px solid #bee17b; border-radius: 4px; cursor: pointer; margin: 0 auto; max-width: 300px;" title="Click to copy">------</div>
										<div style="color: #bee17b; font-size: 11px; margin-top: 10px; opacity: 0.7;">CLICK CODE TO COPY</div>
										<div style="margin-top: 15px; max-width: 400px; margin-left: auto; margin-right: auto;">
											<div style="color: #bee17b; font-size: 13px; margin-bottom: 8px;">SHARE URL:</div>
											<div style="display: flex; gap: 8px; align-items: stretch;">
												<input type="text" id="share-url" readonly style="flex: 1; padding: 12px; background: #111; border: 2px solid #bee17b; color: #bee17b; font-family: 'Share', monospace; font-size: 12px; cursor: pointer;" title="Click to copy" />
												<button id="copy-url-btn" class="audio-btn" style="padding: 12px 20px; font-size: 13px; white-space: nowrap;">[COPY]</button>
											</div>
										</div>
										<button id="disconnect-btn" class="audio-btn" style="width: 100%; max-width: 300px; padding: 12px; font-size: 14px; margin-top: 20px; background: #200; border-color: #f44;">[DISCONNECT]</button>
									</div>
								</div>

								<!-- Join Section -->
								<div style="flex: 1; background: #000; border: 2px solid #bee17b; padding: 30px; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
									<div style="font-size: 18px; font-weight: bold; color: #bee17b; margin-bottom: 30px; text-align: center;">[JOIN SESSION]</div>
									<div style="display: flex; flex-direction: column; align-items: center; width: 100%;">
										<input type="text" id="session-code" placeholder="ENTER CODE" style="width: 100%; max-width: 300px; padding: 20px; background: #000; border: 2px solid #bee17b; color: #bee17b; font-family: 'Share', monospace; font-size: 24px; text-align: center; letter-spacing: 4px; text-transform: uppercase; margin-bottom: 20px; box-sizing: border-box;" maxlength="6" />
										<button id="join-session-btn" class="audio-btn" style="width: 100%; max-width: 300px; padding: 20px; font-size: 16px;">[JOIN SESSION]</button>
									</div>
								</div>
							</div>
						</div>
					</div>

					<!-- Login Modal -->
					<div class="login-modal-overlay" id="login-modal">
						<div class="login-modal-box">
							<div class="login-modal-header">
								<span>SUBLAIR LOGIN</span>
								<button class="login-modal-close" id="login-modal-close">[X]</button>
							</div>
							<div class="login-modal-body">
								<form id="login-form">
									<div class="login-form-group">
										<label>EMAIL</label>
										<input type="email" id="login-email" placeholder="user@sublair.com" required />
									</div>
									<div class="login-form-group">
										<label>PASSWORD</label>
										<input type="password" id="login-password" placeholder="••••••••" required />
									</div>
									<div class="login-error" id="login-error">Invalid credentials</div>
									<button type="submit" class="login-submit-btn">LOGIN</button>
								</form>
							</div>
						</div>
					</div>
				</div>
			`;
			document.body.appendChild(osDiv);

			// ========================================
			// AUDIO VISUALIZER SETUP (after OS is added to DOM)
			// ========================================

			// Initialize visualizer after a short delay to ensure elements exist
			setTimeout(() => {
				const canvas = document.getElementById('eq-visualizer');
				if (!canvas) return;

				const canvasCtx = canvas.getContext('2d');
				const bufferLength = window.audioAnalyser.frequencyBinCount;
				const dataArray = new Uint8Array(bufferLength);
				const timeDataArray = new Uint8Array(bufferLength);

				// dB Meter setup
				const dbMeterCanvas = document.getElementById('db-meter');
				const dbMeterCtx = dbMeterCanvas ? dbMeterCanvas.getContext('2d') : null;
				const clipIndicator = document.getElementById('clip-indicator');
				let peakHold = -Infinity;
				let peakHoldTime = 0;
				let clipDetected = false;
				let clipHoldTime = 0;

				// Track peak LUFS
				let peakLUFS = -Infinity;

				function calculateLUFS(rmsValue) {
					// Simplified LUFS calculation (ITU-R BS.1770)
					const dbFS = 20 * Math.log10(rmsValue);
					return dbFS + 0.691; // Rough conversion to LUFS
				}

				// Reset peak LUFS button
				const resetPeakBtn = document.getElementById('reset-peak-lufs');
				if (resetPeakBtn) {
					resetPeakBtn.addEventListener('click', () => {
						peakLUFS = -Infinity;
						const peakLufsEl = document.getElementById('peak-lufs');
						if (peakLufsEl) peakLufsEl.textContent = '-∞ LUFS';
					});
				}

				function drawVisualizer() {
					requestAnimationFrame(drawVisualizer);

					if (!positionalAudio.isPlaying) {
						// Clear when not playing
						canvasCtx.fillStyle = '#000';
						canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
						return;
					}

					window.audioAnalyser.getByteTimeDomainData(timeDataArray);
					window.audioAnalyser.getByteFrequencyData(dataArray);

					// Calculate Peak and RMS properly
					let peak = 0;
					let sumSquares = 0;

					// Use byte time domain data and convert properly
					// Byte range is 0-255, center is at 128
					// Convert to -1 to +1 range
					for (let i = 0; i < bufferLength; i++) {
						const normalized = (timeDataArray[i] - 128) / 128.0;
						const abs = Math.abs(normalized);
						if (abs > peak) peak = abs;
						sumSquares += normalized * normalized;
					}

					const rms = Math.sqrt(sumSquares / bufferLength);

					// Calculate true dBFS
					const peakDB = peak > 0.0000001 ? 20 * Math.log10(peak) : -Infinity;
					const rmsDB = rms > 0.0000001 ? 20 * Math.log10(rms) : -Infinity;
					const lufs = calculateLUFS(rms);

					// Track peak LUFS
					if (isFinite(lufs) && lufs > peakLUFS) {
						peakLUFS = lufs;
					}

					// Update meters
					const peakEl = document.getElementById('peak-db');
					const rmsEl = document.getElementById('rms-db');
					const lufsEl = document.getElementById('lufs-value');
					const peakLufsEl = document.getElementById('peak-lufs');

					if (peakEl) peakEl.textContent = isFinite(peakDB) ? peakDB.toFixed(1) + ' dB' : '-∞ dB';
					if (rmsEl) rmsEl.textContent = isFinite(rmsDB) ? rmsDB.toFixed(1) + ' dB' : '-∞ dB';
					if (lufsEl) lufsEl.textContent = isFinite(lufs) ? lufs.toFixed(1) + ' LUFS' : '-∞ LUFS';
					if (peakLufsEl) peakLufsEl.textContent = isFinite(peakLUFS) ? peakLUFS.toFixed(1) + ' LUFS' : '-∞ LUFS';

					// Draw frequency spectrum (20Hz - 20kHz)
					canvasCtx.fillStyle = '#000';
					canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

					// Draw frequency bars
					const barWidth = (canvas.width / bufferLength) * 2.5;
					let x = 0;

					for (let i = 0; i < bufferLength; i++) {
						const barHeight = (dataArray[i] / 255) * canvas.height;

						// Color gradient based on frequency
						const hue = (i / bufferLength) * 60; // 0-60 = green range
						canvasCtx.fillStyle = `hsl(${80 + hue}, 70%, 50%)`;

						// Use green for consistency
						canvasCtx.fillStyle = '#bee17b';

						canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
						x += barWidth + 1;
					}

					// Draw frequency labels
					canvasCtx.fillStyle = '#bee17b';
					canvasCtx.font = '10px Share';
					canvasCtx.fillText('20Hz', 5, 15);
					canvasCtx.fillText('1kHz', canvas.width / 2 - 15, 15);
					canvasCtx.fillText('20kHz', canvas.width - 40, 15);

					// Draw grid lines
					canvasCtx.strokeStyle = '#bee17b22';
					canvasCtx.lineWidth = 1;
					for (let i = 0; i < 4; i++) {
						const y = (canvas.height / 4) * i;
						canvasCtx.beginPath();
						canvasCtx.moveTo(0, y);
						canvasCtx.lineTo(canvas.width, y);
						canvasCtx.stroke();
					}

					// ========================================
					// DRAW dB METER
					// ========================================
					if (dbMeterCtx) {
						// Clear meter
						dbMeterCtx.fillStyle = '#000';
						dbMeterCtx.fillRect(0, 0, dbMeterCanvas.width, dbMeterCanvas.height);

						if (positionalAudio.isPlaying) {
							// Map peakDB from -48dB to +6dB for better resolution
							const dbMin = -48;
							const dbMax = 6; // Allow +6dB headroom to show clipping
							let normalizedPeak = (peakDB - dbMin) / (dbMax - dbMin);
							normalizedPeak = Math.max(0, Math.min(1, normalizedPeak));

							// Update peak hold
							const currentTime = Date.now();
							if (peakDB > peakHold) {
								peakHold = peakDB;
								peakHoldTime = currentTime;
							} else if (currentTime - peakHoldTime > 1500) {
								// Decay peak hold after 1.5 seconds
								peakHold = Math.max(peakDB, peakHold - 0.5);
							}

							// Check for clipping (above -1dB or peak >= 0.95 is clipping)
							// In digital audio, 0 dBFS is the absolute maximum
							if (peakDB > -1.0) {
								clipDetected = true;
								clipHoldTime = currentTime;
							}

							// Hide clip indicator after 2 seconds
							if (currentTime - clipHoldTime > 2000) {
								clipDetected = false;
							}

							// Update clip indicator
							if (clipIndicator) {
								clipIndicator.style.opacity = clipDetected ? '1' : '0';
							}

							// Draw segmented meter bars (classic VU meter style)
							const padding = 4;
							const meterHeight = dbMeterCanvas.height - (padding * 2);
							const meterWidth = dbMeterCanvas.width - (padding * 2);
							const segmentCount = 60;
							const segmentWidth = (meterWidth / segmentCount) - 2;

							for (let i = 0; i < segmentCount; i++) {
								const segmentLevel = i / segmentCount;
								const segmentDB = dbMin + (segmentLevel * (dbMax - dbMin));
								const x = padding + (i * (segmentWidth + 2));

								// Determine segment color based on actual dB level
								let color;
								if (segmentDB < -12) {
									// Green zone (-48dB to -12dB)
									color = '#00ff00';
								} else if (segmentDB < -3) {
									// Yellow zone (-12dB to -3dB)
									color = '#ffff00';
								} else if (segmentDB < 0) {
									// Orange zone (-3dB to 0dB)
									color = '#ff9900';
								} else {
									// Red zone (0dB to +6dB) - CLIPPING!
									color = '#ff0000';
								}

								// Draw segment if below peak level
								if (segmentLevel <= normalizedPeak) {
									dbMeterCtx.fillStyle = color;
									dbMeterCtx.fillRect(x, padding, segmentWidth, meterHeight);
								} else {
									// Draw dim background segments
									dbMeterCtx.fillStyle = '#1a1a1a';
									dbMeterCtx.fillRect(x, padding, segmentWidth, meterHeight);
								}
							}

							// Draw peak hold indicator
							if (isFinite(peakHold) && peakHold > dbMin) {
								const peakNormalized = Math.max(0, Math.min(1, (peakHold - dbMin) / (dbMax - dbMin)));
								const peakX = padding + (peakNormalized * meterWidth);
								dbMeterCtx.fillStyle = '#ffffff';
								dbMeterCtx.fillRect(peakX - 1, padding, 2, meterHeight);
							}

							// Draw dB scale labels with better positioning
							dbMeterCtx.fillStyle = '#bee17b';
							dbMeterCtx.font = '9px Share';

							// Calculate positions based on actual dB values
							const labelPositions = [
								{ db: -48, label: '-48' },
								{ db: -24, label: '-24' },
								{ db: -12, label: '-12' },
								{ db: -6, label: '-6' },
								{ db: -3, label: '-3' },
								{ db: 0, label: '0' },
								{ db: 3, label: '+3' },
								{ db: 6, label: '+6' }
							];

							labelPositions.forEach(pos => {
								const normPos = (pos.db - dbMin) / (dbMax - dbMin);
								const xPos = padding + (normPos * meterWidth);
								dbMeterCtx.fillText(pos.label, xPos - 8, 12);
							});
						}
					}
				}

				// Start visualizer
				drawVisualizer();
			}, 100);

			// ========================================
			// SOUND ENGINE CLASS (will be initialized later)
			// ========================================

			class SoundEngine {
				constructor(listener) {
					this.listener = listener;
					this.sounds = {};
					this.audioLoader = new THREE.AudioLoader();
				}

				// Load a sound file
				loadSound(name, path, options = {}) {
					return new Promise((resolve, reject) => {
						this.audioLoader.load(path,
							(buffer) => {
								const sound = new THREE.Audio(this.listener);
								sound.setBuffer(buffer);
								sound.setVolume(options.volume || 1.0);
								sound.setLoop(options.loop || false);

								this.sounds[name] = {
									audio: sound,
									buffer: buffer,
									options: options
								};

								console.log(`Sound loaded: ${name}`);
								resolve(sound);
							},
							undefined,
							(error) => {
								console.error(`Error loading sound ${name}:`, error);
								reject(error);
							}
						);
					});
				}

				// Load multiple sounds
				async loadSounds(soundList) {
					const promises = soundList.map(({name, path, options}) =>
						this.loadSound(name, path, options)
					);
					return Promise.all(promises);
				}

				// Play a sound
				play(name, options = {}) {
					const sound = this.sounds[name];
					if (!sound) {
						console.warn(`Sound not found: ${name}`);
						return null;
					}

					// Debug: Log footstep plays
					const isFootstep = name.startsWith('footstep');
					if (isFootstep) {
						// Playing sound (logging disabled)
					}

					// If already playing and not allowing overlaps, stop first
					if (sound.audio.isPlaying && !options.allowOverlap) {
						sound.audio.stop();
					}

					// Create new instance for overlap
					if (options.allowOverlap && sound.audio.isPlaying) {
						const newSound = new THREE.Audio(this.listener);
						newSound.setBuffer(sound.buffer);
						newSound.setVolume(options.volume || sound.options.volume || 1.0);
						newSound.setLoop(false);

						// Set playback rate (pitch) if specified
						if (options.pitch !== undefined) {
							newSound.setPlaybackRate(options.pitch);
						}

						newSound.play();
						return newSound;
					}

					// Set volume if specified
					if (options.volume !== undefined) {
						sound.audio.setVolume(options.volume);
					}

					// Set playback rate (pitch) if specified
					if (options.pitch !== undefined) {
						sound.audio.setPlaybackRate(options.pitch);
					}

					try {
						sound.audio.play();
						if (isFootstep) {
							// Sound play() called (logging disabled)
						}
					} catch (err) {
						console.error(`❌ Error playing ${name}:`, err);
					}
					return sound.audio;
				}

				// Stop a sound
				stop(name) {
					const sound = this.sounds[name];
					if (sound && sound.audio.isPlaying) {
						sound.audio.stop();
					}
				}

				// Play random sound from array
				playRandom(names, options = {}) {
					const randomName = names[Math.floor(Math.random() * names.length)];
					return this.play(randomName, options);
				}

				// Check if sound is playing
				isPlaying(name) {
					const sound = this.sounds[name];
					return sound ? sound.audio.isPlaying : false;
				}
			}

			// Sound engines will be initialized after audioListener is created
			window.soundEngine = null;
			window.uiSoundEngine = null;
			let soundEngine = window.soundEngine;
			let uiSoundEngine = window.uiSoundEngine;
			let lastFootstepTime = 0;
			let lastFootstepSound = -1; // Track last played sound to avoid immediate repeats
			const footstepSounds = ['footstep1', 'footstep2', 'footstep3', 'footstep4', 'footstep5', 'footstep6', 'footstep7'];

			// Get random footstep sound (avoid playing same one twice in a row)
			function getRandomFootstep() {
				let randomIndex;
				do {
					randomIndex = Math.floor(Math.random() * footstepSounds.length);
				} while (randomIndex === lastFootstepSound && footstepSounds.length > 1);

				lastFootstepSound = randomIndex;
				return footstepSounds[randomIndex];
			}

			// Check if character is in a walking/running state
			function isMovingState(character) {
				if (!character || !character.charState) return false;
				const stateName = character.charState.constructor.name;
				return stateName === 'Walk' || stateName === 'Sprint' ||
				       stateName === 'JumpRunning' || stateName === 'DropRunning';
			}

			// Get footstep interval based on character state
			function getFootstepInterval(character) {
				if (!character || !character.charState) return 500;

				const stateName = character.charState.constructor.name;
				const animationLength = character.charState.animationLength || 1.0;

				// 2 footsteps per animation cycle (left foot, right foot)
				let baseInterval = (animationLength / 2) * 1000; // Convert to milliseconds

				// Adjust based on state
				if (stateName === 'Sprint') {
					baseInterval *= 0.85; // Sprint is faster
				} else if (stateName === 'Walk') {
					baseInterval *= 1.0; // Normal walk
				} else if (stateName === 'JumpRunning' || stateName === 'DropRunning') {
					baseInterval *= 0.9; // Slightly faster
				}

				// Clamp to reasonable values
				return Math.max(200, Math.min(600, baseInterval));
			}

			// OS Navigation System
			function switchToApp(appName) {
				// Check if trying to access protected apps without being logged in
				const protectedApps = ['chat', 'files'];
				if (protectedApps.includes(appName) && !window.authState?.isLoggedIn) {
					console.log(`🔒 ${appName.toUpperCase()} requires login, showing login modal`);
					// Show login modal
					const loginModal = document.getElementById('login-modal');
					if (loginModal) {
						loginModal.classList.add('show');
					}
					return; // Don't switch to the app
				}

				// Check if leaving chat view
				const chatView = document.getElementById('chat-view');
				if (chatView.style.display === 'block' && appName !== 'chat') {
					// Leaving chat, stop polling and set offline
					stopChatPolling();
					setPresenceOffline();
				}

				// Hide all views
				document.querySelectorAll('.os-view').forEach(view => {
					view.style.display = 'none';
				});

				// Show selected view
				document.getElementById(`${appName}-view`).style.display = 'block';

				// Update taskbar active states
				document.querySelectorAll('.taskbar-app').forEach(app => {
					app.classList.remove('active');
				});
				document.querySelector(`.taskbar-app[data-app="${appName}"]`).classList.add('active');

				// If switching to chat, start polling
				if (appName === 'chat' && window.authState?.isLoggedIn) {
					startChatPolling();
				}
			}

			// Taskbar app click handlers
			document.querySelectorAll('.taskbar-app').forEach(app => {
				app.addEventListener('click', function() {
					const appName = this.getAttribute('data-app');
					switchToApp(appName);
				});
			});

			// Desktop icon click handlers
			document.querySelectorAll('.desktop-icon').forEach(icon => {
				icon.addEventListener('click', function() {
					const appName = this.getAttribute('data-app');
					switchToApp(appName);
				});
			});

			// Function to close OS
			function closeOS() {
				// Stop chat polling and set offline when closing OS
				stopChatPolling();
				setPresenceOffline();

				osDiv.classList.remove('active');
				window.terminalOpen = terminalOpen = false;
				character.takeControl();
				setTimeout(() => {
					world.renderer.domElement.requestPointerLock();

					// Resume AudioContext on first user interaction (fixes browser autoplay policy)
					if (audioListener && audioListener.context.state === 'suspended') {
						audioListener.context.resume().then(() => {
							console.log('🔊 AudioContext resumed for footsteps');
						});
					}
				}, 100);
			}

			// OS close button
			document.getElementById('os-close').addEventListener('click', closeOS);

			// Close OS when clicking outside the OS container
			const osContainer = document.querySelector('.os-container');
			document.addEventListener('click', (e) => {
				if (terminalOpen && !customizationOpen) {
					// Check if click is outside the OS container
					if (!osContainer.contains(e.target)) {
						closeOS();
					}
				}
			}, true);

			// Text Reader functionality
			function openTextReader(fileName, content) {
				document.getElementById('text-file-name').textContent = fileName;
				document.getElementById('text-content').textContent = content;
				switchToApp('text');
			}

			// ========================================
			// MULTIPLAYER WEBSOCKET SYSTEM
			// ========================================
			let multiplayerWs = null;
			let isHosting = false;
			let currentSessionCode = null;

			// Auto-detect WebSocket URL based on environment
			const WS_URL = window.location.hostname === 'localhost'
				? 'ws://localhost:3000'
				: `wss://${window.location.host}`; // Use same host for Railway deployment

			// Check URL for session code on load
			if (isSpectatorMode) {
				console.log(`🔗 Auto-joining session from URL: ${spectatorSessionCode}`);

				// Skip welcome screen and firebase auth for spectators
				const welcomeOverlay = document.getElementById('welcome-overlay');
				if (welcomeOverlay) {
					welcomeOverlay.classList.remove('active');
					welcomeOverlay.style.display = 'none';
				}

				// Show spectator loading screen
				const spectatorLoading = document.getElementById('spectator-loading');
				const loadingStatus = document.getElementById('spectator-loading-status');
				spectatorLoading.style.display = 'flex';

				// Update status messages
				loadingStatus.textContent = 'Establishing connection...';

				setTimeout(() => {
					loadingStatus.textContent = 'Verifying session code...';
				}, 500);

				setTimeout(() => {
					loadingStatus.textContent = 'Joining session...';
					document.getElementById('session-code').value = spectatorSessionCode.toUpperCase();
					document.getElementById('join-session-btn').click();
				}, 1500);
			}

			function connectMultiplayer() {
				if (multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					console.log('⚠️ Already connected to multiplayer');
					return;
				}

				multiplayerWs = new WebSocket(WS_URL);

				multiplayerWs.onopen = () => {
					console.log('🌐 Connected to multiplayer server');
				};

				multiplayerWs.onmessage = (event) => {
					const data = JSON.parse(event.data);

					switch (data.type) {
						case 'session_created':
							currentSessionCode = data.sessionCode;
							isHosting = true;
							document.getElementById('generated-code').textContent = data.sessionCode;

							// Generate share URL
							const shareUrl = `${window.location.origin}${window.location.pathname}?session=${data.sessionCode}`;
							document.getElementById('share-url').value = shareUrl;

							document.getElementById('session-code-display').style.display = 'block';
							document.getElementById('host-session-btn').style.display = 'none';
							console.log(`✅ Session created: ${data.sessionCode}`);
							console.log(`🔗 Share URL: ${shareUrl}`);

							// Show portal when hosting
							if (window.portal) {
								window.portal.visible = true;
								console.log('🌀 Portal activated for multiplayer session');
							}

							// Show multiplayer chat
							showMpChat();
							break;

						case 'joined':
							currentSessionCode = data.sessionCode;
							isHosting = false;
							window.mySpectatorId = data.spectatorId;
							window.hostCustomization = data.customization || {}; // Store host's customization
							console.log(`✅ Joined session: ${data.sessionCode} - My ID: ${data.spectatorId}`);
							console.log(`🎨 Received host customization:`, window.hostCustomization);

							// Set global color variables from host's customization (so they're available when assets load)
							const c = window.hostCustomization;
							window.floorGlowColor = c.floorGlowColor || '#bee17b';
							window.floorPanelColor = c.floorPanelColor || '#282828';
							window.speakerCabColor = c.speakerCabColor || '#282828';
							window.speakerTrimColor = c.speakerTrimColor || '#282828';
							window.speakerFaceColor = c.speakerFaceColor || '#282828';
							window.speakerFrameColor = c.speakerFrameColor || '#282828';
							window.computerChassisColor = c.computerChassisColor || '#282828';
							window.computerKeyboardColor = c.computerKeyboardColor || '#191919';
							window.computerFeaturesColor = c.computerFeaturesColor || '#bee17b';
							window.skyTopColor = c.skyTopColor || '#000000';
							window.skyBottomColor = c.skyBottomColor || '#000000';
							window.skyTopPosition = c.skyTopPosition !== undefined ? c.skyTopPosition : 0;
							window.skyBottomPosition = c.skyBottomPosition !== undefined ? c.skyBottomPosition : 100;
							window.carDoorColor = c.carDoorColor || '#282828';
							window.carFrameColor = c.carFrameColor || '#282828';
							window.carHeadlightsColor = c.carHeadlightsColor || '#282828';
							window.carHoodColor = c.carHoodColor || '#282828';
							window.carInteriorColor = c.carInteriorColor || '#282828';
							window.carRimColor = c.carRimColor || '#282828';
							window.carSteeringColor = c.carSteeringColor || '#282828';
							window.carTaillightsColor = c.carTaillightsColor || '#282828';
							window.carTireColor = c.carTireColor || '#282828';
							window.carTrimColor = c.carTrimColor || '#282828';
							console.log('✅ Global color variables set from host customization');

							// Show portal for spectators
							if (window.portal) {
								window.portal.visible = true;
								console.log('🌀 Portal visible for spectator');
							}

							if (isSpectatorMode) {
								// Update loading screen
								const loadingStatus = document.getElementById('spectator-loading-status');
								loadingStatus.textContent = 'Connected! Loading world...';

								// Launch spectator into 3D space as ghost observer
								console.log('👻 Entering spectator mode...');

								// Wait for world to be ready, then position camera
								const checkWorldReady = setInterval(() => {
									if (world && world.camera) {
										clearInterval(checkWorldReady);

										loadingStatus.textContent = 'Loading spectator character...';

										// Spectators now have full boxman characters with physics!
										// Character is loaded via the standard loadGLTF flow above
										// Mark spectator as ready to broadcast position
										window.spectatorReady = true;
										console.log('👻 Spectator character system ready!');

										// Vintage camera zoom removed - spectators are now full characters with regular camera controls

										// Wait for BOTH character and camera to be ready before hiding loading screen
										const checkSpectatorFullyReady = setInterval(() => {
											if (window.spectatorCharacterReady && window.spectatorCameraReady) {
												clearInterval(checkSpectatorFullyReady);

												loadingStatus.textContent = 'Ready!';

												// Wait a brief moment for final rendering, then hide loading screen
												setTimeout(() => {
													const spectatorLoading = document.getElementById('spectator-loading');
													spectatorLoading.style.display = 'none';
													console.log('👻 Spectator fully loaded and ready (character + camera)');

													// Show multiplayer chat for spectators
													showMpChat();
												}, 500);
											}
										}, 100);
									}
								}, 100);
							} else {
								// Manual join (not via URL) - redirect to spectator URL
								console.log('🔄 Redirecting to spectator URL...');
								const spectatorUrl = `${window.location.origin}${window.location.pathname}?session=${data.sessionCode}`;
								window.location.href = spectatorUrl;
							}
							break;

						case 'error':
							console.error('❌ Multiplayer error:', data.message);

							if (isSpectatorMode) {
								// Show error on loading screen
								const loadingStatus = document.getElementById('spectator-loading-status');
								loadingStatus.textContent = `Error: ${data.message}`;
								loadingStatus.style.color = '#ff4444';

								// Show retry message after a moment
								setTimeout(() => {
									loadingStatus.innerHTML = `${data.message}<br><br>Please check the session code and try again.`;
								}, 1500);
							} else {
								alert(`Error: ${data.message}`);
							}
							break;

						case 'session_closed':
							console.log('🛑 Session closed:', data.message);

							if (isSpectatorMode) {
								// Show smooth disconnect modal for spectators
								const modal = document.getElementById('host-disconnected-modal');
								modal.style.display = 'flex';

								// Pause the world/game
								if (world) {
									world.updatesEnabled = false;
								}
							} else {
								// For non-spectator modes, use alert
								alert(`Session closed: ${data.message}`);
							}

							disconnectMultiplayer();
							break;

						case 'players_update':
							// Receive complete player list from server
							if (data.players) {
								console.log('📋 Received player list update:', data.players.length, 'players');
								window.multiplayerPlayers = data.players; // Store full player list
								if (playerViewerOpen) {
									updatePlayerList();
								}
							}
							break;

						case 'player_joined':
							console.log(`👻 Spectator joined (${data.playerCount} total)`);
							window.spectatorCount = data.playerCount;
							if (playerViewerOpen) {
								updatePlayerList();
							}

							// Send current customization state to the new spectator
							const savedCustomization = localStorage.getItem('characterCustomization');
							if (savedCustomization && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
								const customizationData = JSON.parse(savedCustomization);
								multiplayerWs.send(JSON.stringify({
									type: 'customization_update',
									customization: customizationData
								}));
								console.log('🎨 Sent complete customization state to new spectator:', customizationData);
							}

							// Send current EQ state to the new spectator
							if (window.eqFilters && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
								// Send 3-band EQ
								multiplayerWs.send(JSON.stringify({
									type: 'eq_update',
									band: 'low',
									value: window.eqFilters.low.gain.value
								}));
								multiplayerWs.send(JSON.stringify({
									type: 'eq_update',
									band: 'mid',
									value: window.eqFilters.mid.gain.value
								}));
								multiplayerWs.send(JSON.stringify({
									type: 'eq_update',
									band: 'high',
									value: window.eqFilters.high.gain.value
								}));
								// Send master volume
								multiplayerWs.send(JSON.stringify({
									type: 'eq_update',
									band: 'masterVolume',
									value: window.eqFilters.masterGain.gain.value * 100
								}));
								// Send lowpass filter
								multiplayerWs.send(JSON.stringify({
									type: 'eq_update',
									band: 'lowpass',
									value: window.eqFilters.lowpass.frequency.value
								}));
								// Send highpass filter
								multiplayerWs.send(JSON.stringify({
									type: 'eq_update',
									band: 'highpass',
									value: window.eqFilters.highpass.frequency.value
								}));
								console.log('🎚️ Sent complete EQ state to new spectator');
							}
							break;

						case 'player_left':
							console.log(`👤 Spectator left (${data.playerCount} remaining) - ID: ${data.spectatorId}`);
							window.spectatorCount = data.playerCount;

							// Remove the spectator's boxman character from the scene
							if (data.spectatorId && window.spectatorCharacters && window.spectatorCharacters[data.spectatorId]) {
								console.log('🗑️ Removing character for spectator:', data.spectatorId);
								world.graphicsWorld.remove(window.spectatorCharacters[data.spectatorId]);
								delete window.spectatorCharacters[data.spectatorId];
								delete window.spectatorCharacters[data.spectatorId + '_scene'];
								delete window.spectatorCharacterTargets[data.spectatorId];
								delete window.spectatorAnimationMixers[data.spectatorId];
								delete window.spectatorAnimations[data.spectatorId];
							}

							if (playerViewerOpen) {
								updatePlayerList();
							}
							break;

						case 'host_position':
							// Handle host position updates when spectating
							if (isSpectatorMode && data.position) {
								// Debug: Log animation state occasionally
								if (Math.random() < 0.01) { // 1% of updates
									console.log('📥 Spectator received animation:', data.animationState);
								}

								// Load host character model if not loaded yet
								if (!window.hostCharacterModel && !window.hostCharacterLoading) {
									window.hostCharacterLoading = true;
									console.log('👤 Loading host character model for spectator...');

									loadingManager.loadGLTF('build/assets/boxman.glb', (charModel) => {
										// Apply host's customization BEFORE adding to scene
										if (window.hostCustomization) {
											console.log('🎨 Applying host customization to character model...');
											const skinColor = window.hostCustomization.skinColor || '#bee17b';
											const shirtColor = window.hostCustomization.shirtColor || '#282828';
											const pantsColor = window.hostCustomization.pantsColor || '#282828';
											const hatColor = window.hostCustomization.hatColor || '#282828';

											charModel.scene.traverse((child) => {
												if (child.isMesh && child.material) {
													const materialName = child.material.name.toLowerCase();

													// Skip TAPE and character FACE materials entirely - NEVER TOUCH THEM!
													if (materialName.includes('tape')) {
														return; // ABSOLUTELY DO NOT TOUCH TAPE
													}
													if (materialName.includes('face') && !materialName.includes('speaker')) {
														return; // Don't modify character face material
													}

													if (materialName.includes('skin')) {
														child.material.color.set(skinColor);
													} else if (materialName.includes('shirt')) {
														child.material.color.set(shirtColor);
													} else if (materialName.includes('pants')) {
														child.material.color.set(pantsColor);
													} else if (materialName.includes('hat')) {
														child.material.color.set(hatColor);
													}
													child.material.needsUpdate = true;
												}
											});
											console.log('✅ Host customization applied!');

											// Apply host username to hat texture
											const hostUsername = window.hostCustomization.username || 'HOST';
											if (window.updateHatWithUsername) {
												// Temporarily set window.character to host character scene so updateHatWithUsername can find the hat
												const originalCharacter = window.character;
												const tempCharacterWrapper = {
													traverse: (callback) => charModel.scene.traverse(callback)
												};
												window.character = tempCharacterWrapper;
												// window.updateHatWithUsername(hostUsername); // Removed - using floating name tags now
												window.character = originalCharacter;
												console.log('🧢 Applied host username to hat:', hostUsername);
											}

											// Apply host profile picture to FACE material
											const hostPhotoURL = window.hostCustomization.photoURL;
											console.log('🔍 Host photoURL:', hostPhotoURL);
											console.log('🔍 applyPhotoToCharacterFace function exists?', !!window.applyPhotoToCharacterFace);
											if (hostPhotoURL && window.applyPhotoToCharacterFace) {
												console.log('📞 Calling applyPhotoToCharacterFace for host with:', hostPhotoURL);
												window.applyPhotoToCharacterFace(charModel.scene, hostPhotoURL, 'host-character');
												console.log('😀 applyPhotoToCharacterFace called (async loading)');
											} else {
												console.warn('⚠️ Cannot update FACE - photoURL or function missing');
											}
										}

										// Create container hierarchy to match Character class structure
										window.hostCharacterContainer = new THREE.Group(); // Main container at physics position
										window.hostCharacterTilt = new THREE.Group();      // Tilt container
										window.hostCharacterModel = new THREE.Group();     // Model container with offset

										// Apply the same -0.57 offset as Character.ts line 101
										window.hostCharacterModel.position.y = -0.57;

										// Build hierarchy: container → tilt → model → scene
										window.hostCharacterContainer.add(window.hostCharacterTilt);
										window.hostCharacterTilt.add(window.hostCharacterModel);
										window.hostCharacterModel.add(charModel.scene);

										// Store reference to the actual character scene for customization updates
										window.hostCharacterScene = charModel.scene;

										// Set scale on the actual model
										charModel.scene.scale.set(1, 1, 1);

										// Initialize position of the main container (physics position)
										window.hostCharacterContainer.position.set(
											data.position.x,
											data.position.y,
											data.position.z
										);

										// Use quaternion if available, fallback to euler
										if (data.rotation && data.rotation.w !== undefined) {
											window.hostCharacterContainer.quaternion.set(
												data.rotation.x,
												data.rotation.y,
												data.rotation.z,
												data.rotation.w
											);
										}

										world.graphicsWorld.add(window.hostCharacterContainer);

										// Set up animation mixer (on the actual character scene, not containers)
										if (charModel.animations && charModel.animations.length > 0) {
											window.hostAnimationMixer = new THREE.AnimationMixer(charModel.scene);
											window.hostAnimations = {};

											charModel.animations.forEach((clip) => {
												const action = window.hostAnimationMixer.clipAction(clip);
												action.setLoop(THREE.LoopRepeat); // Set animations to loop
												action.clampWhenFinished = false;
												window.hostAnimations[clip.name] = action;
											});

											console.log('✅ Host character loaded with', Object.keys(window.hostAnimations).length, 'animations');

											// Play idle animation by default
											if (window.hostAnimations['idle']) {
												window.hostAnimations['idle'].play();
											} else if (Object.keys(window.hostAnimations).length > 0) {
												// If no 'idle', play first available animation
												const firstAnim = Object.keys(window.hostAnimations)[0];
												window.hostAnimations[firstAnim].play();
											}
										} else {
											console.log('⚠️ No animations found in character model');
										}

										// Create THREE.js sprite name tag for host character
										const hostUsername = window.hostCustomization?.username || 'HOST';
										const hostNameTagSprite = window.createNameTagSprite(hostUsername);
										hostNameTagSprite.position.set(0, 0.75, 0); // Position just above character head
										window.hostCharacterContainer.add(hostNameTagSprite); // Attach to container so it moves with host
										window.hostNameTag = hostNameTagSprite;
										console.log('🏷️ Created name tag sprite for host character:', hostUsername);

										window.hostCharacterLoading = false;
									});
								}

								// Store update in interpolation buffer
								const newUpdate = {
									x: data.position.x,
									y: data.position.y,
									z: data.position.z,
									quaternion: data.rotation && data.rotation.w !== undefined ? new THREE.Quaternion(
										data.rotation.x,
										data.rotation.y,
										data.rotation.z,
										data.rotation.w
									) : null,
									animationState: data.animationState || 'Idle',
									animations: data.animations || [], // NEW: Blend data for smooth transitions
									velocity: data.velocity ? new THREE.Vector3(
										data.velocity.x,
										data.velocity.y,
										data.velocity.z
									) : new THREE.Vector3(),
									timestamp: data.timestamp || performance.now(),
									receivedAt: performance.now()
								};

								// Initialize buffer if doesn't exist
								if (!window.hostUpdateBuffer) {
									window.hostUpdateBuffer = [];
								}

								// Add to buffer
								window.hostUpdateBuffer.push(newUpdate);

								// Keep buffer size manageable (max 10 updates = ~333ms of history at 30Hz)
								if (window.hostUpdateBuffer.length > 10) {
									window.hostUpdateBuffer.shift();
								}

								// Set target to latest for immediate use
								window.hostCharacterTarget = newUpdate;

								// Apply car position/rotation if available
								if (data.car && window.car && window.car.collision) {
									const carPos = data.car.position;
									const carRot = data.car.rotation;

									// Apply position directly to physics body
									window.car.collision.position.set(carPos.x, carPos.y, carPos.z);

									// Apply rotation directly to physics body
									window.car.collision.quaternion.set(carRot.x, carRot.y, carRot.z, carRot.w);

									// Sync visual representation with physics
									window.car.position.copy(window.car.collision.position);
									window.car.quaternion.copy(window.car.collision.quaternion);

									// Hide/show host character based on whether they're in the vehicle
									if (window.hostCharacterContainer) {
										window.hostCharacterContainer.visible = !data.car.characterInVehicle;
									}
								}
							}
							break;

						case 'spectator_character':
							// Receive spectator CHARACTER state - show full boxman with animations (works for host AND other spectators)
							if (data.position) {
								const playerId = data.playerId || 'Spectator';

								// Don't show your own spectator character
								if (isSpectatorMode && playerId === window.mySpectatorId) {
									break;
								}

								// Create spectator characters map if it doesn't exist
								if (!window.spectatorCharacters) {
									window.spectatorCharacters = {};
								}

								// Create target state map for smooth interpolation
								if (!window.spectatorCharacterTargets) {
									window.spectatorCharacterTargets = {};
								}

								// Create animation mixers map
								if (!window.spectatorAnimationMixers) {
									window.spectatorAnimationMixers = {};
								}

								// Create animations map
								if (!window.spectatorAnimations) {
									window.spectatorAnimations = {};
								}

								// Create last animation tracking map (to prevent redundant switches)
								if (!window.spectatorLastAnimation) {
									window.spectatorLastAnimation = {};
								}

								// Load boxman character for this spectator if it doesn't exist
								if (!window.spectatorCharacters[playerId] && !window.spectatorCharacters[playerId + '_loading']) {
									window.spectatorCharacters[playerId + '_loading'] = true;
									console.log('👤 Loading boxman character for spectator:', playerId, isHosting ? '(host view)' : '(spectator view)');

									loadingManager.loadGLTF('build/assets/boxman.glb', (charModel) => {
										// Create container for character and name tag
										const container = new THREE.Group();
										window.spectatorCharacters[playerId] = container;

										// Add character model to container
										const characterScene = charModel.scene;

										// Reset any local transforms on the character model
										characterScene.position.set(0, 0, 0);
										characterScene.rotation.set(0, 0, 0);
										characterScene.scale.set(1, 1, 1);

										container.add(characterScene);

										// Store scene reference for customization updates
										window.spectatorCharacters[playerId + '_scene'] = characterScene;

										console.log('📦 Character scene local position:', characterScene.position.y);

										// Initialize position at target - use latest target if available
										const latestTarget = window.spectatorCharacterTargets[playerId];
										if (latestTarget && latestTarget.position) {
											container.position.copy(latestTarget.position);
											// Apply the same Y offset that Sketchbook.Character uses (-0.57)
											container.position.y -= 0.57;
											console.log('📍 Initialized spectator at latest target position:', latestTarget.position.x.toFixed(2), latestTarget.position.y.toFixed(2), latestTarget.position.z.toFixed(2), '(with -0.57 offset)');
										} else {
											container.position.set(
												data.position.x,
												data.position.y - 0.57,  // Apply Y offset
												data.position.z
											);
											console.log('📍 Initialized spectator at data position:', data.position.x.toFixed(2), (data.position.y - 0.57).toFixed(2), data.position.z.toFixed(2), '(with -0.57 offset)');
										}

										// Set rotation if available
										if (latestTarget && latestTarget.rotation) {
											container.quaternion.copy(latestTarget.rotation);
										} else if (data.rotation) {
											container.quaternion.set(
												data.rotation.x,
												data.rotation.y,
												data.rotation.z,
												data.rotation.w
											);
										}

										// Setup animation mixer (SAME AS HOST)
										window.spectatorAnimationMixers[playerId] = new THREE.AnimationMixer(characterScene);
										window.spectatorAnimations[playerId] = {};

										// Load all animations with RAW CLIP NAMES (same as host - line 6336)
										charModel.animations.forEach((clip) => {
											const action = window.spectatorAnimationMixers[playerId].clipAction(clip);
											action.setLoop(THREE.LoopRepeat);
											action.clampWhenFinished = false;
											// Store by clip name (e.g., 'idle', 'run', 'sprint')
											window.spectatorAnimations[playerId][clip.name] = action;
										});

										console.log('✅ Spectator character loaded with', Object.keys(window.spectatorAnimations[playerId]).length, 'animations:', Object.keys(window.spectatorAnimations[playerId]));

										// Play idle animation by default and set it up properly
										if (window.spectatorAnimations[playerId]['idle']) {
											const idleAction = window.spectatorAnimations[playerId]['idle'];
											idleAction.reset();
											idleAction.setEffectiveWeight(1.0);
											idleAction.play();
											console.log('🎬 Initial spectator animation:', playerId, '→ idle');
										} else if (Object.keys(window.spectatorAnimations[playerId]).length > 0) {
											// If no 'idle', play first available animation
											const firstAnim = Object.keys(window.spectatorAnimations[playerId])[0];
											const firstAction = window.spectatorAnimations[playerId][firstAnim];
											firstAction.reset();
											firstAction.setEffectiveWeight(1.0);
											firstAction.play();
											console.log('🎬 Initial spectator animation:', playerId, '→', firstAnim);
										}

										// Apply spectator customization if available
										if (data.customization) {
											const c = data.customization;
											console.log('🎨 Applying spectator customization:', playerId, c);

											characterScene.traverse((child) => {
												if (child.isMesh && child.material) {
													const materialName = child.material.name.toLowerCase();

													// Skip TAPE and FACE materials
													if (materialName.includes('tape') || (materialName.includes('face') && !materialName.includes('speaker'))) {
														return;
													}

													// Apply colors
													if (materialName.includes('skin') && c.skinColor) {
														child.material.color.set(c.skinColor);
													} else if (materialName.includes('shirt') && c.shirtColor) {
														child.material.color.set(c.shirtColor);
													} else if (materialName.includes('pants') && c.pantsColor) {
														child.material.color.set(c.pantsColor);
													} else if (materialName.includes('hat') && c.hatColor) {
														child.material.color.set(c.hatColor);
													}
													child.material.needsUpdate = true;
												}
											});
										}

										// Create name tag sprite for spectator (use real username if available)
										const spectatorUsername = data.customization?.username || 'Spectator ' + playerId.slice(-4);
										const nameTagSprite = window.createNameTagSprite(spectatorUsername);
										nameTagSprite.position.set(0, 1.2, 0); // Position higher above character head
										container.add(nameTagSprite);

										// Store name tag reference for updates
										window.spectatorCharacters[playerId + '_nametag'] = nameTagSprite;

										// Apply spectator's photoURL to FACE material if available
										if (data.customization?.photoURL && window.applyPhotoToCharacterFace) {
											window.applyPhotoToCharacterFace(characterScene, data.customization.photoURL, playerId);
											console.log('📸 Applying spectator photoURL:', playerId, data.customization.photoURL);
										}

										world.graphicsWorld.add(container);
										console.log('✅ Boxman character loaded for spectator:', playerId, 'username:', spectatorUsername);
										delete window.spectatorCharacters[playerId + '_loading'];
									});
								}

								// Store target state for smooth interpolation
								window.spectatorCharacterTargets[playerId] = {
									position: new THREE.Vector3(data.position.x, data.position.y, data.position.z),
									rotation: data.rotation ? new THREE.Quaternion(
										data.rotation.x,
										data.rotation.y,
										data.rotation.z,
										data.rotation.w
									) : null,
									animationState: data.animationState || 'Idle',
									animations: data.animations || [], // NEW: Blend data for smooth transitions
									velocity: data.velocity ? new THREE.Vector3(
										data.velocity.x,
										data.velocity.y,
										data.velocity.z
									) : new THREE.Vector3(),
									timestamp: data.timestamp || performance.now(),
									receivedAt: performance.now()
								};

								// Apply customization if character already exists and customization data is new
								if (window.spectatorCharacters[playerId] && data.customization) {
									const characterScene = window.spectatorCharacters[playerId + '_scene'];
									const currentCustomization = window.spectatorCharacters[playerId + '_customization'];

									// Check if customization changed
									const customizationChanged = !currentCustomization ||
										JSON.stringify(currentCustomization) !== JSON.stringify(data.customization);

									if (customizationChanged && characterScene) {
										console.log('🎨 Updating spectator customization:', playerId, data.customization);
										const c = data.customization;

										characterScene.traverse((child) => {
											if (child.isMesh && child.material) {
												const materialName = child.material.name.toLowerCase();

												// Skip TAPE and FACE materials
												if (materialName.includes('tape') || (materialName.includes('face') && !materialName.includes('speaker'))) {
													return;
												}

												// Apply colors
												if (materialName.includes('skin') && c.skinColor) {
													child.material.color.set(c.skinColor);
												} else if (materialName.includes('shirt') && c.shirtColor) {
													child.material.color.set(c.shirtColor);
												} else if (materialName.includes('pants') && c.pantsColor) {
													child.material.color.set(c.pantsColor);
												} else if (materialName.includes('hat') && c.hatColor) {
													child.material.color.set(c.hatColor);
												}
												child.material.needsUpdate = true;
											}
										});

										// Update name tag with real username
										const nameTag = window.spectatorCharacters[playerId + '_nametag'];
										if (nameTag && c.username && window.updateNameTagSprite) {
											window.updateNameTagSprite(nameTag, c.username);
											console.log('🏷️ Updated spectator name tag:', playerId, c.username);
										}

										// Apply spectator's photoURL to FACE material if changed
										if (c.photoURL && window.applyPhotoToCharacterFace) {
											const previousPhotoURL = currentCustomization?.photoURL;
											if (previousPhotoURL !== c.photoURL) {
												window.applyPhotoToCharacterFace(characterScene, c.photoURL, playerId);
												console.log('📸 Updated spectator photoURL:', playerId, c.photoURL);
											}
										}

										// Store customization to prevent redundant updates
										window.spectatorCharacters[playerId + '_customization'] = data.customization;
									}
								}

								// Debug logging (occasional) - show position too
								if (Math.random() < 0.01) { // 1% of updates
									console.log('📥 HOST received spectator update:', playerId, {
										anim: data.animationState,
										pos: `(${data.position.x.toFixed(1)}, ${data.position.y.toFixed(1)}, ${data.position.z.toFixed(1)})`,
										hasCustomization: !!data.customization,
										username: data.customization?.username
									});
								}
							}
							break;

						case 'customization_update':
							// Receive live customization changes from host
							if (data.customization) {
								console.log('🎨 Received live customization update:', data.customization);
								window.hostCustomization = data.customization;
								const c = data.customization;

								// Update host name tag sprite if username changed
								if (window.hostNameTag && c.username && window.updateNameTagSprite) {
									window.updateNameTagSprite(window.hostNameTag, c.username);
									console.log('🏷️ Updated host name tag sprite:', c.username);
								}

								// Update global color variables (so they're available when objects load)
								window.floorGlowColor = c.floorGlowColor;
								window.floorPanelColor = c.floorPanelColor;
								window.speakerCabColor = c.speakerCabColor;
								window.speakerTrimColor = c.speakerTrimColor;
								window.speakerFaceColor = c.speakerFaceColor;
								window.speakerFrameColor = c.speakerFrameColor;
								window.computerChassisColor = c.computerChassisColor;
								window.computerKeyboardColor = c.computerKeyboardColor;
								window.computerFeaturesColor = c.computerFeaturesColor;
								window.skyTopColor = c.skyTopColor;
								window.skyBottomColor = c.skyBottomColor;
								window.skyTopPosition = c.skyTopPosition !== undefined ? c.skyTopPosition : 0;
								window.skyBottomPosition = c.skyBottomPosition !== undefined ? c.skyBottomPosition : 100;
								window.carDoorColor = c.carDoorColor;
								window.carFrameColor = c.carFrameColor;
								window.carHeadlightsColor = c.carHeadlightsColor;
								window.carHoodColor = c.carHoodColor;
								window.carInteriorColor = c.carInteriorColor;
								window.carRimColor = c.carRimColor;
								window.carSteeringColor = c.carSteeringColor;
								window.carTaillightsColor = c.carTaillightsColor;
								window.carTireColor = c.carTireColor;
								window.carTrimColor = c.carTrimColor;

								console.log('🔍 Checking object availability:');
								console.log('   window.car:', !!window.car);
								console.log('   window.speakers:', !!window.speakers);
								console.log('   window.computer:', !!window.computer);
								console.log('   window.groundMesh:', !!window.groundMesh);
								console.log('   window.hostCharacterScene:', !!window.hostCharacterScene);

								// Apply to host character (if loaded)
								if (window.hostCharacterScene) {
									window.hostCharacterScene.traverse((child) => {
										if (child.isMesh && child.material) {
											const materialName = child.material.name.toLowerCase();

											// Skip TAPE and character FACE materials entirely - NEVER TOUCH THEM!
											if (materialName.includes('tape')) {
												return; // ABSOLUTELY DO NOT TOUCH TAPE
											}
											if (materialName.includes('face') && !materialName.includes('speaker')) {
												return; // Don't modify character face material
											}

											if (materialName.includes('skin')) {
												child.material.color.set(c.skinColor || '#bee17b');
											} else if (materialName.includes('shirt')) {
												child.material.color.set(c.shirtColor || '#282828');
											} else if (materialName.includes('pants')) {
												child.material.color.set(c.pantsColor || '#282828');
											} else if (materialName.includes('hat')) {
												child.material.color.set(c.hatColor || '#282828');
											}
											child.material.needsUpdate = true;
										}
									});
								}

								// Apply to floor (if exists)
								if (window.groundMesh && window.generateGridTexture) {
									window.generateGridTexture(c.floorGlowColor, c.floorPanelColor);
									window.groundMesh.material.emissive.set(c.floorGlowColor);
									window.groundMesh.material.color.set(c.floorPanelColor);
									window.groundMesh.material.needsUpdate = true;
								}

								// Apply to speakers (if exists)
								if (window.speakers) {
									window.speakers.traverse((child) => {
										if (child.isMesh && child.material) {
											const matName = child.material.name;
											if (matName === 'CAB' || matName.toLowerCase().includes('cab')) {
												child.material.color.set(c.speakerCabColor);
											} else if (matName === 'TRIM' || matName === 'SPEAKER_TRIM' || (matName.toLowerCase().includes('trim') && matName.toLowerCase().includes('speaker'))) {
												child.material.color.set(c.speakerTrimColor);
											} else if (matName === 'FACE' || matName.toLowerCase().includes('face')) {
												child.material.color.set(c.speakerFaceColor);
											} else if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
												child.material.color.set(c.speakerFrameColor);
											}
											child.material.needsUpdate = true;
										}
									});
								}

								// Apply to computer (if exists)
								if (window.computer) {
									window.computer.traverse((child) => {
										if (child.isMesh && child.material) {
											const matName = child.material.name;
											if (matName === 'CHASSIS' || matName.toLowerCase().includes('chassis')) {
												child.material.color.set(c.computerChassisColor);
											} else if (matName === 'KEYBOARD' || matName.toLowerCase().includes('keyboard')) {
												child.material.color.set(c.computerKeyboardColor);
											} else if (matName === 'FEATURES' || matName.toLowerCase().includes('features')) {
												child.material.color.set(c.computerFeaturesColor);
											}
											child.material.needsUpdate = true;
										}
									});
								}

								// Apply to sky (if function exists)
								if (c.skyTopColor && c.skyBottomColor && window.updateSkyGradient) {
									const skyTopPos = c.skyTopPosition !== undefined ? c.skyTopPosition : 0;
									const skyBottomPos = c.skyBottomPosition !== undefined ? c.skyBottomPosition : 100;
									window.updateSkyGradient(c.skyTopColor, c.skyBottomColor, skyTopPos, skyBottomPos);
								}

								// Apply to car (if exists)
								if (window.car) {
									window.car.traverse((child) => {
										if (child.isMesh && child.material) {
											const matName = child.material.name;
											if (matName === 'DOOR' || matName.toLowerCase().includes('door')) {
												child.material.color.set(c.carDoorColor);
											} else if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
												child.material.color.set(c.carFrameColor);
											} else if (matName === 'HEADLIGHTS' || matName.toLowerCase().includes('headlight')) {
												child.material.color.set(c.carHeadlightsColor);
											} else if (matName === 'HOOD' || matName.toLowerCase().includes('hood')) {
												child.material.color.set(c.carHoodColor);
											} else if (matName === 'INTERIOR' || matName.toLowerCase().includes('interior')) {
												child.material.color.set(c.carInteriorColor);
											} else if (matName === 'RIM' || matName.toLowerCase().includes('rim')) {
												child.material.color.set(c.carRimColor);
											} else if (matName === 'STEERING' || matName.toLowerCase().includes('steering')) {
												child.material.color.set(c.carSteeringColor);
											} else if (matName === 'TAILLIGHTS' || matName.toLowerCase().includes('taillight')) {
												child.material.color.set(c.carTaillightsColor);
											} else if (matName === 'TIRE' || matName.toLowerCase().includes('tire')) {
												child.material.color.set(c.carTireColor);
											} else if (matName === 'TRIM' || (matName.toLowerCase().includes('trim') && !matName.toLowerCase().includes('speaker'))) {
												child.material.color.set(c.carTrimColor);
											}
											child.material.needsUpdate = true;
										}
									});
								}

								console.log('✅ Applied live customization update to ALL objects');
							}
							break;

						case 'audio_sync':
							// Receive audio sync from host
							if (isSpectatorMode && data.action) {
								console.log('🎵 Received audio sync:', data.action, data.trackData);

								if (data.action === 'play') {
									// Load and play the same track as host
									const track = data.trackData;
									const audioOutput = data.audioOutput === 'car' ? window.carPositionalAudio : window.positionalAudio;

									if (!audioOutput) {
										console.warn('⚠️ Audio output not ready yet');
										return;
									}

									// Stop any currently playing audio
									if (window.carPositionalAudio && window.carPositionalAudio.isPlaying) {
										window.carPositionalAudio.stop();
									}
									if (window.positionalAudio && window.positionalAudio.isPlaying) {
										window.positionalAudio.stop();
									}

									// Build stream URL (same as host)
									const streamUrl = `${RADIO_API_BASE_URL}/api/v1/stream/${track.id}`;
									console.log(`🎵 Spectator loading track: ${track.title} via ${data.audioOutput}`);

									// Load and play the track
									const audioLoader = new THREE.AudioLoader();
									audioLoader.load(streamUrl, (buffer) => {
										audioOutput.setBuffer(buffer);
										audioOutput.setLoop(false);

										// Configure based on output type (matching host setup)
										if (data.audioOutput === 'car') {
											audioOutput.setVolume(0.3); // Spectators likely outside car

											// Connect car EQ chain if available
											if (window.carEQ && window.audioAnalyser) {
												try {
													const source = audioOutput.getOutput();
													source.disconnect();
													source.connect(window.carEQ.bass);
													window.carEQ.bass.connect(window.carEQ.lowMid);
													window.carEQ.lowMid.connect(window.carEQ.highMid);
													window.carEQ.highMid.connect(window.carEQ.treble);
													window.carEQ.treble.connect(window.carEQ.outsideLowpass);
													window.carEQ.outsideLowpass.connect(window.audioAnalyser);
													window.audioAnalyser.connect(audioOutput.context.destination);
													console.log('✅ Car EQ chain connected');
												} catch (e) {
													console.warn('⚠️ Car EQ chain failed, using direct output:', e);
												}
											}
										} else {
											audioOutput.setVolume(1.0);

											// Connect speaker EQ chain if available
											if (window.speakerDirectionalBass && window.eqFilters && window.audioAnalyser) {
												try {
													const source = audioOutput.getOutput();
													source.disconnect();
													source.connect(window.speakerDirectionalBass);
													window.speakerDirectionalBass.connect(window.speakerDirectionalLowpass);
													window.speakerDirectionalLowpass.connect(window.eqFilters.vehicleLowpass);
													window.eqFilters.vehicleLowpass.connect(window.eqFilters.lowpass);
													window.eqFilters.lowpass.connect(window.eqFilters.highpass);
													window.eqFilters.highpass.connect(window.eqFilters.low);
													window.eqFilters.low.connect(window.eqFilters.mid);
													window.eqFilters.mid.connect(window.eqFilters.high);
													window.eqFilters.high.connect(window.eqFilters.masterGain);
													window.eqFilters.masterGain.connect(window.audioAnalyser);
													window.audioAnalyser.connect(audioOutput.context.destination);
													console.log('✅ Speaker EQ chain connected');
												} catch (e) {
													console.warn('⚠️ Speaker EQ chain failed, using direct output:', e);
												}
											}
										}

										audioOutput.play();
										window.spectatorAudioSource = audioOutput; // Store for pause/resume
										console.log('✅ Spectator audio playing:', track.title);
									}, undefined, (error) => {
										console.error('❌ Spectator failed to load audio:', error);
									});

								} else if (data.action === 'pause') {
									// Pause spectator audio
									if (window.spectatorAudioSource && window.spectatorAudioSource.isPlaying) {
										window.spectatorAudioSource.pause();
										console.log('⏸️ Spectator audio paused');
									}

								} else if (data.action === 'resume') {
									// Resume spectator audio
									if (window.spectatorAudioSource && !window.spectatorAudioSource.isPlaying) {
										window.spectatorAudioSource.play();
										console.log('▶️ Spectator audio resumed');
									}
								}
							}
							break;

						case 'chat_message':
							// Receive chat message from server
							if (data.username && data.message) {
								addMpChatMessage(data.username, data.message);
							}
							break;

						case 'audio_ready':
							// Host receives ready signal from spectator
							if (isHosting && window.spectatorReadyHandler && data.spectatorId) {
								window.spectatorReadyHandler(data.spectatorId);
							}
							break;

						case 'pong':
							// Handle pong response for latency calculation
							if (data.timestamp) {
								const latency = Date.now() - data.timestamp;
								const playerId = data.playerId || 'host';
								playerLatencies.set(playerId, latency);

								// Send latency to server so it can broadcast to everyone
								if (multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
									multiplayerWs.send(JSON.stringify({
										type: 'latency_update',
										latency: latency
									}));
								}

								if (playerViewerOpen) {
									updatePlayerList();
								}
							}
							break;

						case 'latencies_update':
							// Receive all player latencies from server
							if (data.latencies) {
								// Update local latency map with all player latencies
								Object.entries(data.latencies).forEach(([playerId, latency]) => {
									playerLatencies.set(playerId, latency);
								});

								if (playerViewerOpen) {
									updatePlayerList();
								}
							}
							break;

						case 'audio_preload':
							// Spectator receives preload instruction - load but don't play yet
							if (isSpectatorMode && data.track) {
								console.log('🎵 Spectator preloading track:', data.track.title);
								addMpChatMessage('', `Loading: ${data.track.title}...`, true);

								// Stop any currently playing audio
								if (positionalAudio && positionalAudio.isPlaying) {
									positionalAudio.stop();
								}

								// Load the track
								const audioLoader = new THREE.AudioLoader();
								audioLoader.load(data.track.url, (buffer) => {
									positionalAudio.setBuffer(buffer);
									positionalAudio.setLoop(false);
									positionalAudio.setVolume(1.0);

									// Connect through full EQ chain for spectators
									const source = positionalAudio.getOutput();
									source.disconnect();

									if (window.speakerDirectionalBass && window.speakerDirectionalLowpass && window.eqFilters && window.audioAnalyser) {
										// Full EQ chain: source → speaker filters → EQ → analyser → destination
										try {
											source.connect(window.speakerDirectionalBass);
											window.speakerDirectionalBass.connect(window.speakerDirectionalLowpass);
											window.speakerDirectionalLowpass.connect(window.eqFilters.vehicleLowpass);
											window.eqFilters.vehicleLowpass.connect(window.eqFilters.lowpass);
											window.eqFilters.lowpass.connect(window.eqFilters.highpass);
											window.eqFilters.highpass.connect(window.eqFilters.low);
											window.eqFilters.low.connect(window.eqFilters.mid);
											window.eqFilters.mid.connect(window.eqFilters.high);
											window.eqFilters.high.connect(window.eqFilters.masterGain);
											window.eqFilters.masterGain.connect(window.audioAnalyser);
											window.audioAnalyser.connect(positionalAudio.context.destination);
											console.log('✅ Spectator audio connected through full EQ chain');
										} catch (e) {
											console.warn('⚠️ Failed to connect full EQ chain, using fallback:', e);
											source.connect(positionalAudio.context.destination);
										}
									} else if (window.audioAnalyser) {
										console.log('⚠️ Some EQ filters not available, connecting through analyser only');
										source.connect(window.audioAnalyser);
										window.audioAnalyser.connect(positionalAudio.context.destination);
									} else {
										console.log('⚠️ No filters available, connecting directly to destination');
										source.connect(positionalAudio.context.destination);
									}

									// Store track info globally
									window.currentPlaybackTrack = data.track;
									window.currentSongTitle = data.track.title;
									window.currentArtworkUrl = data.track.artworkUrl;
									window.currentArtistName = data.track.artistName;

									console.log('🎵 Spectator buffer loaded, sending ready signal');
									addMpChatMessage('', 'Ready!', true);

									// Tell host we're ready
									multiplayerWs.send(JSON.stringify({
										type: 'audio_ready',
										spectatorId: window.mySpectatorId
									}));
								},
								(xhr) => {
									// Progress callback
									const percent = Math.round((xhr.loaded / xhr.total) * 100);
									if (percent % 20 === 0) { // Log every 20%
										console.log(`Loading audio: ${percent}%`);
									}
								},
								(error) => {
									console.error('❌ Failed to load audio for spectator:', error);
									addMpChatMessage('', 'Failed to load track', true);
								});
							}
							break;

						case 'audio_play_sync':
							// Spectator receives synchronized play command
							if (isSpectatorMode && positionalAudio && positionalAudio.buffer) {
								console.log('🎵 Spectator starting synchronized playback');
								addMpChatMessage('', 'Playing!', true);
								positionalAudio.play();
								window.isPlaybackPaused = false;
							}
							break;

						case 'audio_play':
							// Legacy handler for backward compatibility (non-synchronized playback)
							if (isSpectatorMode && data.track) {
								console.log('🎵 Spectator receiving track from host (legacy):', data.track.title);

								// Calculate time offset for sync
								const receiveTime = Date.now();
								const offset = (receiveTime - data.startTime) / 1000; // Convert to seconds

								// Stop any currently playing audio
								if (positionalAudio && positionalAudio.isPlaying) {
									positionalAudio.stop();
								}

								// Load and play the host's track
								const audioLoader = new THREE.AudioLoader();
								audioLoader.load(data.track.url, (buffer) => {
									positionalAudio.setBuffer(buffer);
									positionalAudio.setLoop(false);
									positionalAudio.setVolume(1.0);

									// Connect to audio analyser for visual effects
									const source = positionalAudio.getOutput();
									source.disconnect();

									if (window.audioAnalyser) {
										source.connect(window.audioAnalyser);
										window.audioAnalyser.connect(positionalAudio.context.destination);
									} else {
										source.connect(positionalAudio.context.destination);
									}

									// Start playing at the correct offset to sync with host
									if (offset > 0 && offset < buffer.duration) {
										positionalAudio.offset = offset;
										console.log(`🎵 Starting playback at ${offset.toFixed(2)}s offset for sync`);
									}

									positionalAudio.play();

									// Store track info globally
									window.currentPlaybackTrack = data.track;
									window.currentSongTitle = data.track.title;
									window.currentArtworkUrl = data.track.artworkUrl;
									window.currentArtistName = data.track.artistName;

									console.log('🎵 Spectator now playing:', data.track.title);
								},
								(xhr) => {
									// Progress callback
									const percent = Math.round((xhr.loaded / xhr.total) * 100);
									if (percent % 20 === 0) { // Log every 20%
										console.log(`Loading audio: ${percent}%`);
									}
								},
								(error) => {
									console.error('❌ Failed to load audio for spectator:', error);
								});
							}
							break;

						case 'audio_pause':
							// Spectator receives pause command from host
							console.log('🎵 Spectator received audio_pause message');
							if (isSpectatorMode && positionalAudio) {
								console.log('🎵 Spectator conditions met, isPlaying:', positionalAudio.isPlaying);
								if (positionalAudio.isPlaying) {
									positionalAudio.pause();
									window.isPlaybackPaused = true;
									console.log('🎵 Spectator paused playback');
								} else {
									console.log('🎵 Audio not playing, skipping pause');
								}
							} else {
								console.log('🎵 Spectator conditions not met:', { isSpectatorMode, hasAudio: !!positionalAudio });
							}
							break;

						case 'audio_resume':
							// Spectator receives resume command from host
							console.log('🎵 Spectator received audio_resume message');
							if (isSpectatorMode && positionalAudio) {
								console.log('🎵 Spectator conditions met, isPlaying:', positionalAudio.isPlaying);
								if (!positionalAudio.isPlaying) {
									positionalAudio.play();
									window.isPlaybackPaused = false;
									console.log('🎵 Spectator resumed playback');
								} else {
									console.log('🎵 Audio already playing, skipping resume');
								}
							} else {
								console.log('🎵 Spectator conditions not met:', { isSpectatorMode, hasAudio: !!positionalAudio });
							}
							break;

						case 'track_info':
							// Spectator receives track info from host
							if (data.trackData) {
								console.log('🎵 Spectator received track info:', data.trackData);
								updateNowPlayingDisplay(
									data.trackData.title,
									data.trackData.artistName,
									data.trackData.artistUsername,
									data.trackData.artworkUrl,
									data.trackData.trackId
								);
							}
							break;

						case 'audio_stop':
							// Spectator receives stop command from host
							console.log('🎵 Spectator received audio_stop message');
							if (isSpectatorMode && positionalAudio) {
								positionalAudio.stop();
								window.isPlaybackPaused = false;
								console.log('🎵 Spectator stopped playback');
							} else {
								console.log('🎵 Spectator conditions not met:', { isSpectatorMode, hasAudio: !!positionalAudio });
							}

							// Hide Now Playing display
							hideNowPlayingDisplay();
							break;

						case 'eq_update':
							// Spectator receives EQ change from host
							if (data.band && typeof data.value === 'number' && window.eqFilters) {
								console.log(`🎚️ Spectator received EQ update: ${data.band} = ${data.value}`);
								if (data.band === 'low' && window.eqFilters.low) {
									window.eqFilters.low.gain.value = data.value;
								} else if (data.band === 'mid' && window.eqFilters.mid) {
									window.eqFilters.mid.gain.value = data.value;
								} else if (data.band === 'high' && window.eqFilters.high) {
									window.eqFilters.high.gain.value = data.value;
								} else if (data.band === 'masterVolume' && window.eqFilters.masterGain) {
									window.eqFilters.masterGain.gain.value = data.value / 100;
								} else if (data.band === 'lowpass' && window.eqFilters.lowpass) {
									window.eqFilters.lowpass.frequency.value = data.value;
								} else if (data.band === 'highpass' && window.eqFilters.highpass) {
									window.eqFilters.highpass.frequency.value = data.value;
								}
							}
							break;

						case 'eq_reset':
							// Spectator receives EQ reset from host
							if (window.eqFilters) {
								console.log('🎚️ Spectator received EQ reset');
								window.eqFilters.low.gain.value = 0;
								window.eqFilters.mid.gain.value = 0;
								window.eqFilters.high.gain.value = 0;
								window.eqFilters.lowpass.frequency.value = 20000;
								window.eqFilters.highpass.frequency.value = 20;
							}
							break;
					}
				};

				multiplayerWs.onerror = (error) => {
					console.error('❌ WebSocket error:', error);
				};

				multiplayerWs.onclose = () => {
					console.log('🔌 Disconnected from multiplayer server');
					multiplayerWs = null;
				};
			}

			function disconnectMultiplayer() {
				if (multiplayerWs) {
					multiplayerWs.send(JSON.stringify({ type: 'disconnect' }));
					multiplayerWs.close();
					multiplayerWs = null;
				}

				isHosting = false;
				currentSessionCode = null;
				document.getElementById('session-code-display').style.display = 'none';
				document.getElementById('host-session-btn').style.display = 'block';
				document.getElementById('generated-code').textContent = '------';

				// Re-enable join section
				document.getElementById('session-code').disabled = false;
				document.getElementById('join-session-btn').disabled = false;
				document.getElementById('join-session-btn').style.opacity = '1';
				document.getElementById('session-code').style.opacity = '1';

				// Hide portal when disconnecting
				if (window.portal) {
					window.portal.visible = false;
					console.log('🌀 Portal hidden - multiplayer session ended');
				}

				// Hide and clear multiplayer chat
				hideMpChat();
				closeMpChatInput();
				mpChatMessages.innerHTML = ''; // Clear all messages
				mpChatMessages.style.display = 'none';

				// Reset spam detection
				lastMessageTime = 0;
				messageCount = 0;
				messageHistory = [];
				isSpamBlocked = false;

				// Close player viewer
				if (playerViewerOpen) {
					playerViewerOpen = false;
					playerViewer.style.display = 'none';
				}
				if (pingInterval) {
					clearInterval(pingInterval);
					pingInterval = null;
				}
				playerLatencies.clear();
				window.spectatorCount = 0;

				console.log('💬 Multiplayer chat cleared');
			}

			// Return home button handler (for spectators when host disconnects)
			document.getElementById('return-home-btn').addEventListener('click', () => {
				// Remove session parameter from URL and reload
				window.location.href = window.location.origin + window.location.pathname;
			});

			// ========================================
			// MULTIPLAYER CHAT SYSTEM
			// ========================================
			let mpChatOpen = false;
			const mpChatContainer = document.getElementById('multiplayer-chat');
			const mpChatMessages = document.getElementById('chat-messages');
			const mpChatInputContainer = document.getElementById('chat-input-container');
			const mpChatInput = document.getElementById('chat-input');

			// Spam detection
			let lastMessageTime = 0;
			let messageCount = 0;
			let messageHistory = [];
			const MESSAGE_COOLDOWN = 1000; // 1 second between messages
			const SPAM_THRESHOLD = 5; // Max 5 messages
			const SPAM_WINDOW = 10000; // Within 10 seconds
			let isSpamBlocked = false;

			function showMpChat() {
				if (!isHosting && !isSpectatorMode) return; // Only show in multiplayer sessions
				mpChatContainer.style.display = 'block';
			}

			function hideMpChat() {
				mpChatContainer.style.display = 'none';
			}

			function openMpChatInput() {
				if (!isHosting && !isSpectatorMode) return;

				mpChatOpen = true;
				mpChatInputContainer.style.display = 'block';
				mpChatMessages.style.display = 'block';
				mpChatInput.focus();

				// Disable game controls
				if (world && world.inputManager) {
					world.inputManager.inputReceiver = window.dummyInputReceiver;
				}

				// Exit pointer lock
				if (document.pointerLockElement) {
					document.exitPointerLock();
				}
			}

			function closeMpChatInput() {
				mpChatOpen = false;
				mpChatInputContainer.style.display = 'none';

				// Clear input field
				mpChatInput.value = '';

				// If no messages, hide the whole chat
				if (mpChatMessages.children.length === 0) {
					mpChatMessages.style.display = 'none';
				}

				// Re-enable game controls (works for both host and spectators)
				if (character) {
					character.takeControl();
				}

				// Re-lock pointer after a small delay
				setTimeout(() => {
					if (world && world.renderer && world.renderer.domElement) {
						world.renderer.domElement.requestPointerLock();
					}
				}, 100);
			}

			function addMpChatMessage(username, message, isSystem = false) {
				const messageEl = document.createElement('div');
				messageEl.style.marginBottom = '8px';
				messageEl.style.lineHeight = '1.4';
				messageEl.style.fontFamily = "'Share Tech Mono', monospace";
				messageEl.style.fontSize = '13px';

				if (isSystem) {
					messageEl.style.color = '#888';
					messageEl.innerHTML = `[SYSTEM] ${message}`;
				} else {
					messageEl.innerHTML = `<span style="color: #bee17b; font-weight: bold;">[${username}]</span> ${message}`;
				}

				mpChatMessages.appendChild(messageEl);
				mpChatMessages.scrollTop = mpChatMessages.scrollHeight;

				// Show messages container
				mpChatMessages.style.display = 'block';

				// Auto-hide messages after 10 seconds if chat is closed
				if (!mpChatOpen) {
					setTimeout(() => {
						if (!mpChatOpen && mpChatMessages.children.length > 0) {
							messageEl.style.transition = 'opacity 1s';
							messageEl.style.opacity = '0';
							setTimeout(() => {
								if (messageEl.parentNode) {
									messageEl.remove();
								}
								// Hide container if no messages left
								if (mpChatMessages.children.length === 0) {
									mpChatMessages.style.display = 'none';
								}
							}, 1000);
						}
					}, 10000);
				}
			}

			function sendMpChatMessage() {
				const message = mpChatInput.value.trim();
				if (!message || !multiplayerWs || multiplayerWs.readyState !== WebSocket.OPEN) {
					return;
				}

				// Check if spam blocked
				if (isSpamBlocked) {
					addMpChatMessage('', 'You are temporarily blocked from sending messages', true);
					return;
				}

				// Check cooldown
				const now = Date.now();
				const timeSinceLastMessage = now - lastMessageTime;
				if (timeSinceLastMessage < MESSAGE_COOLDOWN) {
					const remainingTime = Math.ceil((MESSAGE_COOLDOWN - timeSinceLastMessage) / 1000);
					addMpChatMessage('', `Please wait ${remainingTime}s before sending another message`, true);
					return;
				}

				// Update message history
				messageHistory.push(now);
				messageHistory = messageHistory.filter(time => now - time < SPAM_WINDOW);

				// Check for spam
				if (messageHistory.length > SPAM_THRESHOLD) {
					isSpamBlocked = true;
					addMpChatMessage('', 'Spam detected! You have been blocked for 30 seconds', true);
					setTimeout(() => {
						isSpamBlocked = false;
						messageHistory = [];
						addMpChatMessage('', 'Chat block removed', true);
					}, 30000);
					mpChatInput.value = '';
					return;
				}

				// Get username from Firebase auth or fallback
				const username = window.authState?.user?.username ||
								window.authState?.user?.displayName ||
								window.authState?.email?.split('@')[0] ||
								(isHosting ? 'Host' : 'Spectator');

				// Send message to server
				multiplayerWs.send(JSON.stringify({
					type: 'chat_message',
					message: message,
					username: username
				}));

				// Update last message time
				lastMessageTime = now;

				// Clear input but keep chat open for conversation
				mpChatInput.value = '';
				mpChatInput.focus();
			}

			// Chat input enter key
			mpChatInput.addEventListener('keydown', (e) => {
				if (e.key === 'Enter') {
					e.preventDefault();
					e.stopPropagation();
					sendMpChatMessage();
				} else if (e.key === 'Escape') {
					e.preventDefault();
					e.stopPropagation();
					closeMpChatInput();
				}
			});

			// T key to open chat
			document.addEventListener('keydown', (e) => {
				// Don't open chat if already typing or in other UI
				if (mpChatOpen || window.terminalOpen || window.customizationOpen) return;
				if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

				if (e.key === 't' || e.key === 'T') {
					e.preventDefault();
					openMpChatInput();
				}
			});

			// ========================================
			// MULTIPLAYER PLAYER VIEWER
			// ========================================
			const playerViewer = document.getElementById('player-viewer');
			const playerListBody = document.getElementById('player-list-body');
			const viewerSessionCode = document.getElementById('viewer-session-code');
			let playerViewerOpen = false;
			let playerLatencies = new Map(); // Store latency for each player
			let pingInterval = null;

			function togglePlayerViewer() {
				if (!isHosting && !isSpectatorMode) return;

				playerViewerOpen = !playerViewerOpen;
				playerViewer.style.display = playerViewerOpen ? 'block' : 'none';

				if (playerViewerOpen) {
					updatePlayerList();
					// Start ping monitoring
					if (!pingInterval) {
						pingInterval = setInterval(() => {
							sendPing();
						}, 2000); // Ping every 2 seconds
					}
				} else {
					// Stop ping monitoring
					if (pingInterval) {
						clearInterval(pingInterval);
						pingInterval = null;
					}
				}
			}

			function sendPing() {
				if (multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					const pingTime = Date.now();
					multiplayerWs.send(JSON.stringify({
						type: 'ping',
						timestamp: pingTime
					}));
				}
			}

			function updatePlayerList() {
				if (!currentSessionCode) return;

				viewerSessionCode.textContent = currentSessionCode;

				// Get current player ID
				const myId = isHosting ? 'host' : window.spectatorId;

				let html = '';

				// Use the player list from server if available
				const players = window.multiplayerPlayers || [];

				if (players.length === 0) {
					// Fallback to old method if no player list yet
					const myUsername = window.authState?.user?.username ||
									   window.authState?.user?.displayName ||
									   window.authState?.email?.split('@')[0] ||
									   (isHosting ? 'Host' : 'Spectator');

					const hostLatency = playerLatencies.get('host') || 0;
					html += `
						<tr style="border-bottom: 1px solid rgba(190, 225, 123, 0.3);">
							<td style="padding: 12px 10px;">
								<span style="color: #bee17b;">⬤</span> ${myUsername} ${isHosting ? '(You)' : ''}
							</td>
							<td style="padding: 12px 10px; text-align: center;">
								<span style="background: #bee17b; color: #000; padding: 2px 8px; font-size: 11px; letter-spacing: 1px;">HOST</span>
							</td>
							<td style="padding: 12px 10px; text-align: center; color: ${hostLatency < 50 ? '#0f0' : hostLatency < 100 ? '#ff0' : '#f00'};">
								${hostLatency}ms
							</td>
						</tr>
					`;
				} else {
					// Use the full player list from server
					players.forEach(player => {
						const latency = playerLatencies.get(player.id) || 0;
						const isMe = player.id === myId;
						const roleLabel = player.isHost ? 'HOST' : 'SPEC';
						const roleStyle = player.isHost
							? 'background: #bee17b; color: #000;'
							: 'background: rgba(190, 225, 123, 0.3); color: #bee17b;';

						html += `
							<tr style="border-bottom: 1px solid rgba(190, 225, 123, 0.3);">
								<td style="padding: 12px 10px;">
									<span style="color: #bee17b;">⬤</span> ${player.username} ${isMe ? '(You)' : ''}
								</td>
								<td style="padding: 12px 10px; text-align: center;">
									<span style="${roleStyle} padding: 2px 8px; font-size: 11px; letter-spacing: 1px;">${roleLabel}</span>
								</td>
								<td style="padding: 12px 10px; text-align: center; color: ${latency < 50 ? '#0f0' : latency < 100 ? '#ff0' : '#f00'};">
									${latency}ms
								</td>
							</tr>
						`;
					});
				}

				playerListBody.innerHTML = html;
			}

			// Y key to toggle player viewer
			document.addEventListener('keydown', (e) => {
				if (mpChatOpen || window.terminalOpen || window.customizationOpen) return;
				if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

				if (e.key === 'y' || e.key === 'Y') {
					e.preventDefault();
					togglePlayerViewer();
				}
			});

			// Host session button
			document.getElementById('host-session-btn').addEventListener('click', () => {
				console.log('🎮 Starting host session...');
				connectMultiplayer();

				// Disable join section while hosting
				document.getElementById('session-code').disabled = true;
				document.getElementById('join-session-btn').disabled = true;
				document.getElementById('join-session-btn').style.opacity = '0.5';
				document.getElementById('session-code').style.opacity = '0.5';

				// Wait for connection then send host message
				const checkConnection = setInterval(() => {
					if (multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
						clearInterval(checkConnection);

						// Get customization data from localStorage
						let savedCustomization = localStorage.getItem('characterCustomization');
						let customizationData = savedCustomization ? JSON.parse(savedCustomization) : {};

						multiplayerWs.send(JSON.stringify({
							type: 'host',
							playerData: {
								username: window.authState?.username || 'Host Player'
							},
							customization: customizationData // Include ALL customization colors
						}));
					}
				}, 100);
			});

			// Join session button
			document.getElementById('join-session-btn').addEventListener('click', () => {
				const code = document.getElementById('session-code').value.trim().toUpperCase();
				if (code.length !== 6) {
					alert('Please enter a valid 6-character session code');
					return;
				}

				console.log(`🔗 Joining session: ${code}`);
				connectMultiplayer();

				// Wait for connection then send join message
				const checkConnection = setInterval(() => {
					if (multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
						clearInterval(checkConnection);
						multiplayerWs.send(JSON.stringify({
							type: 'join',
							sessionCode: code,
							playerData: {
								username: window.authState?.username || 'Spectator'
							}
						}));
					}
				}, 100);
			});

			// Disconnect button
			document.getElementById('disconnect-btn').addEventListener('click', () => {
				console.log('🛑 Disconnecting from session...');
				disconnectMultiplayer();
			});

			// Copy session code on click
			document.getElementById('generated-code').addEventListener('click', () => {
				const code = document.getElementById('generated-code').textContent;
				if (code && code !== '------') {
					navigator.clipboard.writeText(code).then(() => {
						console.log('📋 Session code copied to clipboard');
						const codeEl = document.getElementById('generated-code');
						const originalBg = codeEl.style.background;
						codeEl.style.background = '#bee17b';
						codeEl.style.color = '#000';
						setTimeout(() => {
							codeEl.style.background = originalBg;
							codeEl.style.color = '#bee17b';
						}, 200);
					});
				}
			});

			// Copy URL button
			document.getElementById('copy-url-btn').addEventListener('click', () => {
				const url = document.getElementById('share-url').value;
				navigator.clipboard.writeText(url).then(() => {
					console.log('📋 Share URL copied to clipboard');
					const btn = document.getElementById('copy-url-btn');
					btn.textContent = '[COPIED!]';
					setTimeout(() => {
						btn.textContent = '[COPY]';
					}, 1500);
				});
			});

			// Copy URL on input click
			document.getElementById('share-url').addEventListener('click', function() {
				navigator.clipboard.writeText(this.value).then(() => {
					console.log('📋 Share URL copied to clipboard');
					this.select();
				});
			});

			// Chat System (OS Terminal Chat)
			const chatMessages = document.getElementById('os-chat-messages');
			const chatInput = document.getElementById('os-chat-input');
			const chatSend = document.getElementById('os-chat-send');
			const onlineUsers = document.getElementById('online-users');
			const onlineCount = document.getElementById('online-count');
			let lastMessageTimestamp = null;
			let chatPollInterval = null;
			let presencePollInterval = null;
			let displayedMessageIds = new Set(); // Track displayed message IDs to prevent duplicates

			function addChatMessage(username, message, timestamp, photoURL, messageId, uid) {
				// Check if message already displayed
				if (messageId && displayedMessageIds.has(messageId)) {
					console.log('⚠️ Skipping duplicate message:', messageId);
					return;
				}

				const messageDiv = document.createElement('div');
				messageDiv.style.marginBottom = '10px';
				messageDiv.style.display = 'flex';
				messageDiv.style.alignItems = 'center';
				messageDiv.style.justifyContent = 'space-between';
				messageDiv.setAttribute('data-msg-id', messageId); // Store message ID on element
				const time = new Date(timestamp).toLocaleTimeString();

				const isMyMessage = window.authState?.uid === uid;

				// Make username clickable - link to their Sublair profile
				const usernameDisplay = `<a href="https://www.sublair.com/u/${username}" target="_blank" class="artist-link" onclick="event.stopPropagation();" style="color: #bee17b; font-weight: bold; text-decoration: none; cursor: pointer; border-bottom: 1px solid transparent; transition: border-color 0.2s;" onmouseover="this.style.borderBottomColor='#bee17b'" onmouseout="this.style.borderBottomColor='transparent'">${username}</a>`;

				// Linkify URLs in message
				const urlRegex = /(https?:\/\/[^\s]+)/g;
				const linkedMessage = message.replace(urlRegex, (url) => {
					return `<a href="${url}" target="_blank" rel="noopener noreferrer" style="color: #5b9bd5; text-decoration: underline; cursor: pointer;">${url}</a>`;
				});

				messageDiv.innerHTML = `
					<div style="flex: 1;">
						<span style="color: #666;">[${time}]</span>
						${usernameDisplay}:
						<span style="color: #fff;">${linkedMessage}</span>
					</div>
					${isMyMessage ? `<button class="delete-msg-btn" data-msg-id="${messageId}" style="padding: 4px 10px; background: #000; color: #f00; border: 1px solid #f00; cursor: pointer; font-family: 'Share', monospace; font-size: 12px; margin-left: 10px; transition: all 0.2s;">[DELETE]</button>` : ''}
				`;

				chatMessages.appendChild(messageDiv);

				// Track this message as displayed
				if (messageId) {
					displayedMessageIds.add(messageId);
				}

				// Add delete handler if it's the user's message
				if (isMyMessage && messageId) {
					const deleteBtn = messageDiv.querySelector('.delete-msg-btn');
					deleteBtn.addEventListener('click', () => deleteMessage(messageId, messageDiv));
				}

				chatMessages.scrollTop = chatMessages.scrollHeight;
			}

			async function deleteMessage(messageId, messageDiv) {
				if (!confirm('Delete this message?')) return;

				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/chat/messages/${messageId}`, {
						method: 'DELETE',
						headers: {
							'Content-Type': 'application/json',
							'Authorization': `Bearer ${window.authState.idToken}`
						}
					});

					const result = await response.json();

					if (result.success) {
						messageDiv.remove();
						// Remove from tracking set
						displayedMessageIds.delete(messageId);
					} else {
						alert('Failed to delete message');
					}
				} catch (error) {
					console.error('Error deleting message:', error);
					alert('Failed to delete message');
				}
			}

			async function loadChatMessages() {
				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/chat/messages?limit=50`);
					const result = await response.json();

					if (result.success && result.data.length > 0) {
						chatMessages.innerHTML = '';
						displayedMessageIds.clear(); // Clear tracking set when reloading all messages

						result.data.forEach(msg => {
							addChatMessage(msg.username, msg.text, msg.createdAt, msg.photoURL, msg.id, msg.uid);
							lastMessageTimestamp = msg.createdAt;
						});
					} else {
						chatMessages.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">[NO MESSAGES YET]</div>';
					}
				} catch (error) {
					console.error('Error loading messages:', error);
					chatMessages.innerHTML = '<div style="color: #f00; text-align: center; padding: 20px;">[ERROR LOADING MESSAGES]</div>';
				}
			}

			async function pollNewMessages() {
				if (!lastMessageTimestamp) return;

				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/chat/messages?limit=10`);
					const result = await response.json();

					if (result.success && result.data.length > 0) {
						result.data.forEach(msg => {
							if (msg.createdAt > lastMessageTimestamp) {
								addChatMessage(msg.username, msg.text, msg.createdAt, msg.photoURL, msg.id, msg.uid);
								lastMessageTimestamp = msg.createdAt;
							}
						});
					}
				} catch (error) {
					console.error('Error polling messages:', error);
				}
			}

			async function sendChatMessage() {
				const message = chatInput.value.trim();
				if (!message) return;

				if (!window.authState?.isLoggedIn) {
					alert('You must be logged in to send messages');
					return;
				}

				if (message.length > 500) {
					alert('Message too long (max 500 characters)');
					return;
				}

				try {
					chatSend.disabled = true;
					chatSend.textContent = '[SENDING...]';

					const username = window.authState.user?.username ||
									 window.authState.user?.displayName ||
									 window.authState.email?.split('@')[0] ||
									 'USER';

					const response = await fetch(`${API_BASE_URL}/api/v1/chat/messages`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							text: message,
							idToken: window.authState.idToken
						})
					});

					const result = await response.json();

					if (!result.success) {
						throw new Error(result.error || 'Failed to send message');
					}

					// Clear placeholder if it exists
					const placeholder = chatMessages.querySelector('[style*="text-align: center"]');
					if (placeholder) {
						chatMessages.innerHTML = '';
					}

					// Immediately add message to UI
					addChatMessage(username, message, Date.now(), window.authState.user?.photoURL, result.data.id, window.authState.uid);
					lastMessageTimestamp = Date.now();

					chatInput.value = '';
				} catch (error) {
					console.error('Error sending message:', error);
					alert(error.message || 'Failed to send message');
				} finally {
					chatSend.disabled = false;
					chatSend.textContent = '[SEND]';
				}
			}

			// Fast polling presence system
			async function updatePresence() {
				if (!window.authState?.isLoggedIn) return;

				try {
					await fetch(`${API_BASE_URL}/api/v1/chat/presence`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							idToken: window.authState.idToken,
							status: 'online'
						})
					});
				} catch (error) {
					console.error('Error updating presence:', error);
				}
			}

			async function setPresenceOffline() {
				if (!window.authState?.isLoggedIn) return;

				try {
					await fetch(`${API_BASE_URL}/api/v1/chat/presence`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							idToken: window.authState.idToken,
							status: 'offline'
						})
					});
				} catch (error) {
					console.error('Error setting presence offline:', error);
				}
			}

			async function loadOnlineUsers() {
				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/chat/presence`);
					const result = await response.json();

					if (result.success) {
						onlineCount.textContent = result.data.length;

						if (result.data.length === 0) {
							onlineUsers.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">[NO USERS ONLINE]</div>';
						} else {
							onlineUsers.innerHTML = result.data.map(user => {
								return `<div style="padding: 8px; border-bottom: 1px solid #222; color: #bee17b;">${user.username}</div>`;
							}).join('');
						}
					}
				} catch (error) {
					console.error('Error loading online users:', error);
				}
			}

			function startChatPolling() {
				if (chatPollInterval) return;

				console.log('🚀 Starting chat polling');

				// Load initial data
				loadChatMessages();
				loadOnlineUsers();

				// Set presence online immediately
				if (window.authState?.isLoggedIn) {
					updatePresence();
				}

				// Poll for new messages every 2 seconds
				chatPollInterval = setInterval(pollNewMessages, 2000);

				// Update presence and poll online users every 2 seconds (fast for instant feel)
				presencePollInterval = setInterval(() => {
					if (window.authState?.isLoggedIn) {
						updatePresence();
					}
					loadOnlineUsers();
				}, 2000);
			}

			function stopChatPolling() {
				console.log('🛑 Stopping chat polling');

				// Stop message polling
				if (chatPollInterval) {
					clearInterval(chatPollInterval);
					chatPollInterval = null;
				}

				// Stop presence polling
				if (presencePollInterval) {
					clearInterval(presencePollInterval);
					presencePollInterval = null;
				}

				// Set presence offline
				setPresenceOffline();
			}

			chatSend.addEventListener('click', sendChatMessage);
			chatInput.addEventListener('keypress', (e) => {
				if (e.key === 'Enter') {
					sendChatMessage();
				}
			});

			// Handle files view
			const originalSwitchToApp = switchToApp;
			switchToApp = function(appName) {
				originalSwitchToApp(appName);
				if (appName === 'files') {
					loadFileSystem();
				}
			};

			// ========================================
			// DEEPWAVES FILE BROWSER SYSTEM
			// ========================================

			let currentFolderId = null; // null = root
			let folderStack = []; // For navigation history
			let allFiles = []; // Cache of all files for search

			// Load file system from API
			async function loadFileSystem(projectId = null) {
				const filesContainer = document.getElementById('files-container');
				const currentPath = document.getElementById('current-path');
				const backButton = document.getElementById('files-back');
				const fileDetailsPanel = document.getElementById('file-details-panel');

				try {
					filesContainer.innerHTML = '<div style="text-align: center; color: #bee17b; padding: 40px 20px;">[LOADING FILES...]</div>';

					// Hide details panel when loading new folder
					fileDetailsPanel.style.display = 'none';

					// Build URL with user UID if logged in
					let endpoint = `${API_BASE_URL}/api/v1/files`;
					const params = new URLSearchParams();

					if (projectId) {
						params.append('projectId', projectId);
					}

					// Add user UID if logged in
					if (window.authState?.isLoggedIn && window.authState?.uid) {
						params.append('uid', window.authState.uid);
					}

					if (params.toString()) {
						endpoint += '?' + params.toString();
					}

					const response = await fetch(endpoint);
					const result = await response.json();

					if (!result.success) {
						throw new Error(result.error || 'Failed to load files');
					}

					currentFolderId = projectId;
					allFiles = result.data.files || [];

					// Update path display
					const pathParts = result.data.path || ['C:', 'DEEPWAVES'];
					currentPath.textContent = pathParts.join('\\') + '\\';

					// Enable/disable back button
					backButton.disabled = folderStack.length === 0;

					// Render files and folders
					renderFileSystem(result.data);

				} catch (error) {
					console.error('Error loading files:', error);
					filesContainer.innerHTML = `
						<div style="text-align: center; color: #f00; padding: 40px 20px;">
							[ERROR LOADING FILES]<br>
							<span style="font-size: 12px;">${error.message}</span>
						</div>
					`;
				}
			}

			// Render file system UI
			function renderFileSystem(data) {
				const filesContainer = document.getElementById('files-container');
				const fileCount = document.getElementById('file-count');
				const folderCount = document.getElementById('folder-count');

				const folders = data.folders || [];
				const files = data.files || [];

				fileCount.textContent = files.length;
				folderCount.textContent = folders.length;

				if (folders.length === 0 && files.length === 0) {
					// Check if user is not logged in
					if (!window.authState?.isLoggedIn) {
						filesContainer.innerHTML = `
							<div style="text-align: center; color: #bee17b; padding: 40px 20px; line-height: 1.6;">
								[LOGIN REQUIRED]<br><br>
								<span style="color: #666; font-size: 12px;">
									Please login to view your DEEPWAVES projects.<br>
									Click the profile button in the top-right to login.
								</span>
							</div>
						`;
					} else {
						filesContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 40px 20px;">[NO PROJECTS FOUND]</div>';
					}
					return;
				}

				// Use different layouts for folders vs files
				const hasFolders = folders.length > 0;
				const hasFiles = files.length > 0;

				let html = '';

				// Folders in grid layout
				if (hasFolders) {
					html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 15px; margin-bottom: 20px;">';
				}

				// Render folders first
				folders.forEach(folder => {
					html += `
						<div class="file-item" data-type="folder" data-id="${folder.id}" style="cursor: pointer; padding: 12px; background: #111; border: 2px solid #bee17b; transition: all 0.2s;">
							<div style="font-size: 32px; text-align: center; margin-bottom: 8px;">[F]</div>
							<div style="color: #bee17b; font-size: 12px; text-align: center; word-break: break-word; font-family: 'Share', monospace; font-weight: bold;">${folder.name}</div>
							<div style="color: #666; font-size: 10px; text-align: center; margin-top: 4px;">${folder.itemCount || 0} items</div>
						</div>
					`;
				});

				// Close folders grid
				if (hasFolders) {
					html += '</div>';
				}

				// Files (versions) in list layout
				if (hasFiles) {
					html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
				}

				// Render files (versions)
				files.forEach(file => {
					const sizeText = formatFileSize(file.size);
					const versionNum = file.metadata?.version_number || 'v1.0.0';
					const commitType = file.metadata?.commit_type || 'update';
					const commitMsg = file.description || 'No description';
					const commitDate = file.createdAt ? new Date(file.createdAt).toLocaleDateString() : '';

					// Determine commit badge styling
					let badgeBg = '#333';
					let badgeText = '#bee17b';
					let badgeBorder = '#bee17b';

					if (commitType === 'initial') {
						badgeBg = 'transparent';
						badgeText = '#bee17b';
						badgeBorder = '#bee17b';
					} else if (commitType === 'update') {
						badgeBg = 'transparent';
						badgeText = '#5b9bd5';
						badgeBorder = '#5b9bd5';
					} else if (commitType === 'fix') {
						badgeBg = 'transparent';
						badgeText = '#e06c75';
						badgeBorder = '#e06c75';
					}

					html += `
						<div class="file-item version-item" data-type="file" data-id="${file.id}" style="cursor: pointer; padding: 15px; background: #0a0a0a; border: 2px solid #333; transition: all 0.2s; display: flex; flex-direction: column; gap: 8px;">
							<div style="display: flex; justify-content: space-between; align-items: center;">
								<div style="display: flex; align-items: center; gap: 10px;">
									<div style="color: #bee17b; font-size: 16px; font-weight: bold; font-family: 'Share', monospace;">${versionNum}</div>
									<div style="background: ${badgeBg}; color: ${badgeText}; border: 1px solid ${badgeBorder}; padding: 3px 10px; font-size: 10px; font-weight: bold; text-transform: uppercase; font-family: 'Share', monospace; letter-spacing: 0.5px;">[${commitType}]</div>
								</div>
								<div style="color: #666; font-size: 10px;">${commitDate}</div>
							</div>
							<div style="color: #888; font-size: 11px; font-family: 'Share', monospace; line-height: 1.4; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${commitMsg}</div>
							<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 4px; padding-top: 8px; border-top: 1px solid #222;">
								<div style="color: #666; font-size: 10px;">${sizeText}</div>
								${file.metadata?.bpm ? `<div style="color: #bee17b; font-size: 10px;">${file.metadata.bpm} BPM</div>` : ''}
								${file.metadata?.key ? `<div style="color: #bee17b; font-size: 10px;">KEY: ${file.metadata.key}</div>` : ''}
							</div>
						</div>
					`;
				});

				// Close files list
				if (hasFiles) {
					html += '</div>';
				}

				filesContainer.innerHTML = html;

				// Add hover effects and click handlers
				document.querySelectorAll('.file-item').forEach(item => {
					// Hover effect
					item.addEventListener('mouseenter', function() {
						if (this.classList.contains('version-item')) {
							this.style.background = '#151515';
							this.style.borderColor = '#bee17b';
						} else {
							this.style.background = '#222';
							this.style.borderColor = '#bee17b';
						}
					});
					item.addEventListener('mouseleave', function() {
						if (this.classList.contains('version-item')) {
							this.style.background = '#0a0a0a';
							this.style.borderColor = '#333';
						} else {
							this.style.background = '#111';
							if (this.dataset.type === 'folder') {
								this.style.borderColor = '#bee17b';
							} else {
								this.style.borderColor = '#555';
							}
						}
					});

					// Click handler
					item.addEventListener('click', function() {
						const type = this.dataset.type;
						const id = this.dataset.id;

						if (type === 'folder') {
							openFolder(id);
						} else {
							showFileDetails(id, files);
						}
					});
				});
			}

			// Open folder
			function openFolder(folderId) {
				// Push current location to stack (null = root)
				folderStack.push(currentFolderId);
				loadFileSystem(folderId);
			}

			// Go back to parent folder
			function goBackFolder() {
				if (folderStack.length > 0) {
					const parentId = folderStack.pop();
					loadFileSystem(parentId);
				} else {
					// Already at root, do nothing
					loadFileSystem(null);
				}
			}

			// Show file details in sidebar
			function showFileDetails(fileId, files) {
				const file = files.find(f => f.id === fileId);
				if (!file) return;

				const detailsPanel = document.getElementById('file-details-panel');
				const detailsContent = document.getElementById('file-details-content');

				const uploadDate = file.createdAt ? new Date(file.createdAt).toLocaleString() : 'N/A';

				// Build metadata display
				let metadataHTML = '';
				if (file.metadata) {
					if (file.metadata.bpm) {
						metadataHTML += `
							<div style="margin-bottom: 12px;">
								<div style="color: #666; font-size: 10px; margin-bottom: 3px;">BPM:</div>
								<div style="color: #bee17b;">${file.metadata.bpm}</div>
							</div>
						`;
					}
					if (file.metadata.key) {
						metadataHTML += `
							<div style="margin-bottom: 12px;">
								<div style="color: #666; font-size: 10px; margin-bottom: 3px;">KEY:</div>
								<div style="color: #bee17b;">${file.metadata.key}</div>
							</div>
						`;
					}
					if (file.metadata.genre) {
						metadataHTML += `
							<div style="margin-bottom: 12px;">
								<div style="color: #666; font-size: 10px; margin-bottom: 3px;">GENRE:</div>
								<div style="color: #bee17b;">${file.metadata.genre}</div>
							</div>
						`;
					}
					if (file.metadata.version_number) {
						metadataHTML += `
							<div style="margin-bottom: 12px;">
								<div style="color: #666; font-size: 10px; margin-bottom: 3px;">VERSION:</div>
								<div style="color: #bee17b;">${file.metadata.version_number}</div>
							</div>
						`;
					}
				}

				detailsContent.innerHTML = `
					<div style="margin-bottom: 12px;">
						<div style="color: #666; font-size: 10px; margin-bottom: 3px;">NAME:</div>
						<div style="color: #bee17b; word-break: break-word; font-size: 11px;">${file.name}</div>
					</div>
					<div style="margin-bottom: 12px;">
						<div style="color: #666; font-size: 10px; margin-bottom: 3px;">TYPE:</div>
						<div style="color: #bee17b;">${file.type || 'Unknown'}</div>
					</div>
					<div style="margin-bottom: 12px;">
						<div style="color: #666; font-size: 10px; margin-bottom: 3px;">SIZE:</div>
						<div style="color: #bee17b;">${formatFileSize(file.size)}</div>
					</div>
					${file.createdAt ? `
						<div style="margin-bottom: 12px;">
							<div style="color: #666; font-size: 10px; margin-bottom: 3px;">COMMITTED:</div>
							<div style="color: #bee17b; font-size: 11px;">${uploadDate}</div>
						</div>
					` : ''}
					${file.description ? `
						<div style="margin-bottom: 12px;">
							<div style="color: #666; font-size: 10px; margin-bottom: 3px;">COMMIT MESSAGE:</div>
							<div style="color: #bee17b; font-size: 11px; line-height: 1.4;">${file.description}</div>
						</div>
					` : ''}
					${metadataHTML}
					${file.previewUrl ? `
						<div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #333;">
							<button class="audio-btn" id="play-preview-btn" style="width: 100%;">[PLAY PREVIEW]</button>
						</div>
					` : ''}
				`;

				// Add event listener for play button
				if (file.previewUrl) {
					const playBtn = document.getElementById('play-preview-btn');
					if (playBtn) {
						playBtn.addEventListener('click', () => {
							playPreviewTrack(file.previewUrl, file.name);
						});
					}
				}

				detailsPanel.style.display = 'block';
			}

			// Play preview track using the same audio system as music player
			function playPreviewTrack(previewUrl, trackName) {
				// Update desktop audio player
				document.getElementById('desktop-audio-status').textContent = 'LOADING...';
				document.getElementById('audio-play-pause').disabled = false;
				document.getElementById('audio-stop').disabled = false;
				currentTrackTitle = trackName || 'UNKNOWN TRACK';

				// Stop current track if playing
				if (positionalAudio.isPlaying) {
					positionalAudio.stop();
				}

				// Load and play preview
				const audioLoader = new THREE.AudioLoader();
				audioLoader.load(previewUrl, (buffer) => {
					positionalAudio.setBuffer(buffer);
					positionalAudio.setLoop(false);
					positionalAudio.setVolume(1.0);

					// Connect EQ filters chain
					const source = positionalAudio.getOutput();
					source.disconnect();
					source.connect(window.speakerDirectionalBass);
					window.speakerDirectionalBass.connect(window.speakerDirectionalLowpass);
					window.speakerDirectionalLowpass.connect(window.eqFilters.vehicleLowpass);
					window.eqFilters.vehicleLowpass.connect(window.eqFilters.lowpass);
					window.eqFilters.lowpass.connect(window.eqFilters.highpass);
					window.eqFilters.highpass.connect(window.eqFilters.low);
					window.eqFilters.low.connect(window.eqFilters.mid);
					window.eqFilters.mid.connect(window.eqFilters.high);
					window.eqFilters.high.connect(window.audioAnalyser);
					window.audioAnalyser.connect(audioListener.context.destination);

					positionalAudio.play();
					isPlaying = true;

					// Update UI
					document.getElementById('desktop-audio-status').textContent = trackName;
					document.getElementById('audio-play-pause').textContent = '⏸ PAUSE';

					console.log('🎵 Playing preview:', trackName);
				}, undefined, (error) => {
					console.error('Error loading preview:', error);
					alert('Failed to load audio preview');
					document.getElementById('desktop-audio-status').textContent = 'ERROR LOADING';
				});
			}

			// Helper: Get file icon based on type
			function getFileIcon(type, filename) {
				if (!type && filename) {
					const ext = filename.split('.').pop().toLowerCase();
					if (['mp3', 'wav', 'ogg', 'flac'].includes(ext)) return '🎵';
					if (['mp4', 'avi', 'mkv', 'mov'].includes(ext)) return '🎬';
					if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext)) return '🖼️';
					if (['txt', 'doc', 'docx', 'pdf'].includes(ext)) return '📄';
					if (['zip', 'rar', '7z', 'tar', 'gz'].includes(ext)) return '📦';
				}

				if (type?.includes('audio')) return '🎵';
				if (type?.includes('video')) return '🎬';
				if (type?.includes('image')) return '🖼️';
				if (type?.includes('text') || type?.includes('document')) return '📄';
				if (type?.includes('archive') || type?.includes('zip')) return '📦';
				return '📄';
			}

			// Helper: Format file size
			function formatFileSize(bytes) {
				if (!bytes) return '0 B';
				const k = 1024;
				const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
				const i = Math.floor(Math.log(bytes) / Math.log(k));
				return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
			}

			// Search files
			function searchFiles(query) {
				if (!query.trim()) {
					loadFileSystem(currentFolderId);
					return;
				}

				const filesContainer = document.getElementById('files-container');
				const searchLower = query.toLowerCase();
				const filtered = allFiles.filter(f => f.name.toLowerCase().includes(searchLower));

				if (filtered.length === 0) {
					filesContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 40px 20px;">[NO RESULTS FOUND]</div>';
					return;
				}

				renderFileSystem({ folders: [], files: filtered });
			}

			// Event Listeners
			document.getElementById('files-back').addEventListener('click', goBackFolder);
			document.getElementById('files-refresh').addEventListener('click', () => loadFileSystem(currentFolderId));
			document.getElementById('files-search').addEventListener('input', (e) => searchFiles(e.target.value));

			// Text reader close button
			document.getElementById('text-close').addEventListener('click', () => {
				switchToApp('files');
			});

			// Login Modal Handlers
			const loginModal = document.getElementById('login-modal');
			const profileBtn = document.getElementById('profile-btn');
			const loginModalClose = document.getElementById('login-modal-close');
			const loginForm = document.getElementById('login-form');
			const loginError = document.getElementById('login-error');

			// Close login modal
			loginModalClose.addEventListener('click', () => {
				loginModal.classList.remove('show');
				loginError.classList.remove('show');
			});

			// Close when clicking outside
			loginModal.addEventListener('click', (e) => {
				if (e.target === loginModal) {
					loginModal.classList.remove('show');
					loginError.classList.remove('show');
				}
			});

			// Global auth state
			window.authState = {
				isLoggedIn: false,
				user: null,
				idToken: null,
				refreshToken: null
			};

			// Save auth to localStorage
			function saveAuth(authData) {
				localStorage.setItem('sublair_auth', JSON.stringify(authData));
				window.authState = authData;
			}

			// Load auth from localStorage and verify/refresh token
			async function loadAuth() {
				const saved = localStorage.getItem('sublair_auth');
				if (!saved) {
					console.log('No saved auth found');
					return false;
				}

				try {
					const authData = JSON.parse(saved);
					window.authState = authData;

					// Check if token is expired or about to expire (within 5 minutes)
					const tokenAge = Date.now() - (authData.loginTime || 0);
					const tokenLifetime = parseInt(authData.expiresIn) * 1000; // Convert to ms
					const timeUntilExpiry = tokenLifetime - tokenAge;

					console.log('Token age:', Math.floor(tokenAge / 1000 / 60), 'minutes');
					console.log('Time until expiry:', Math.floor(timeUntilExpiry / 1000 / 60), 'minutes');

					// If token expires in less than 5 minutes or already expired, refresh it
					if (timeUntilExpiry < 5 * 60 * 1000) {
						console.log('Token expired or expiring soon, refreshing...');
						await refreshAuthToken();
					} else {
						console.log('Token still valid, user auto-logged in');

						// Fetch latest user data from Firebase to get current OM count
						try {
							const userResponse = await fetch(`${API_BASE_URL}/api/v1/users/${authData.uid}`);
							const userResult = await userResponse.json();
							if (userResult.success && userResult.data) {
								window.authState.user = userResult.data;
								saveAuth(window.authState);
								console.log('🎮 Fetched latest user data with OMs:', userResult.data.oms);
							}
						} catch (error) {
							console.warn('Could not fetch latest user data:', error);
						}

						updateUIForAuth();
					}

					return true;
				} catch (error) {
					console.error('Error loading auth:', error);
					clearAuth();
					return false;
				}
			}

			// Refresh authentication token
			async function refreshAuthToken() {
				if (!window.authState.refreshToken) {
					console.error('No refresh token available');
					clearAuth();
					return false;
				}

				try {
					console.log('Refreshing auth token...');
					const response = await fetch(`${API_BASE_URL}/api/v1/auth/refresh`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							refreshToken: window.authState.refreshToken
						})
					});

					const result = await response.json();

					if (!response.ok || !result.success) {
						throw new Error(result.error || 'Token refresh failed');
					}

					// Update tokens
					window.authState.idToken = result.data.idToken;
					window.authState.refreshToken = result.data.refreshToken;
					window.authState.expiresIn = result.data.expiresIn;
					window.authState.loginTime = Date.now();

					// Save updated auth
					saveAuth(window.authState);
					updateUIForAuth();

					console.log('Token refreshed successfully');
					return true;

				} catch (error) {
					console.error('Token refresh failed:', error);
					clearAuth();
					return false;
				}
			}

			// Start automatic token refresh timer
			function startTokenRefreshTimer() {
				// Refresh token every 50 minutes (tokens typically last 1 hour)
				setInterval(async () => {
					if (window.authState.isLoggedIn) {
						console.log('Auto-refreshing token...');
						await refreshAuthToken();
					}
				}, 50 * 60 * 1000); // 50 minutes
			}

			// Clear auth
			function clearAuth() {
				localStorage.removeItem('sublair_auth');
				window.authState = {
					isLoggedIn: false,
					user: null,
					idToken: null,
					refreshToken: null
				};
				updateUIForAuth();
			}

			// Update UI based on auth state
			function updateUIForAuth() {
				const profileStatus = document.getElementById('profile-status');
				const omCountElement = document.getElementById('om-count');

				console.log('Updating auth UI - isLoggedIn:', window.authState.isLoggedIn);
				console.log('Auth state:', window.authState);

				if (window.authState.isLoggedIn) {
					const username = window.authState.user?.username ||
									 window.authState.user?.displayName ||
									 window.authState.email?.split('@')[0] ||
									 'USER';
					console.log('Setting username to:', username.toUpperCase());
					profileStatus.textContent = username.toUpperCase();

					// Update OM count display
					const oms = window.authState.user?.oms || 0;
					if (omCountElement) {
						omCountElement.textContent = oms;
						console.log(`🎮 Displaying user OMs: ${oms}`);
					}

					// Update computer screen with user's photoURL
					const photoURL = window.authState.user?.photoURL;
					if (photoURL && window.updateComputerScreen) {
						console.log('Updating computer screen with user photo:', photoURL);
						window.updateComputerScreen(photoURL);
					}

					// Update name tag sprite with new username
					if (window.localNameTag && window.updateNameTagSprite) {
						window.updateNameTagSprite(window.localNameTag, username);
						console.log('🏷️ Updated name tag sprite:', username);
					}

					// Update character FACE material with user's photoURL
					if (photoURL && window.updateCharacterFace) {
						console.log('Updating character FACE with user photo:', photoURL);
						window.updateCharacterFace(photoURL);
					}

					// Save username and photoURL to localStorage for multiplayer
					try {
						const savedCustomization = localStorage.getItem('characterCustomization');
						if (savedCustomization) {
							const customizationData = JSON.parse(savedCustomization);
							customizationData.username = username;
							customizationData.photoURL = photoURL;
							localStorage.setItem('characterCustomization', JSON.stringify(customizationData));
							console.log('💾 Updated customization with username and photoURL:', username, photoURL);

							// Broadcast to spectators if hosting
							if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
								multiplayerWs.send(JSON.stringify({
									type: 'customization_update',
									customization: customizationData
								}));
								console.log('📡 Broadcast updated customization to spectators');
							}
						}
					} catch (e) {
						console.error('Failed to update customization:', e);
					}
				} else {
					console.log('Setting to GUEST');
					profileStatus.textContent = 'GUEST';
					// Reset OM count to 0 for guest
					if (omCountElement) {
						omCountElement.textContent = '0';
					}
					// Clear computer screen when logged out
					if (window.updateComputerScreen) {
						window.updateComputerScreen(null);
					}
					// Clear character FACE material when logged out
					if (window.updateCharacterFace) {
						window.updateCharacterFace(null);
					}
				}
			}

			// Logout function
			function logout() {
				clearAuth();
				console.log('User logged out');
			}

			// Handle profile button clicks
			profileBtn.addEventListener('click', () => {
				if (window.authState.isLoggedIn) {
					// User is logged in, show confirmation
					if (confirm('Do you want to logout?')) {
						logout();
					}
				} else {
					// User is not logged in, show login modal
					loginModal.classList.add('show');
				}
			});

			// Form submit
			loginForm.addEventListener('submit', async (e) => {
				e.preventDefault();
				const email = document.getElementById('login-email').value;
				const password = document.getElementById('login-password').value;

				loginError.classList.remove('show');
				const submitBtn = document.getElementById('login-form').querySelector('.login-submit-btn');
				submitBtn.textContent = 'LOGGING IN...';
				submitBtn.disabled = true;

				try {
					const response = await fetch(`${API_BASE_URL}/api/v1/auth/login`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ email, password })
					});

					const result = await response.json();

					if (!response.ok || !result.success) {
						throw new Error(result.error || 'Login failed');
					}

					// Use user data from login response (already has oms initialized)
					console.log('Login response user data:', result.data.user);

					// Save auth data with login timestamp and full user profile
					saveAuth({
						isLoggedIn: true,
						user: result.data.user,
						email: result.data.email,
						uid: result.data.localId,
						idToken: result.data.idToken,
						refreshToken: result.data.refreshToken,
						expiresIn: result.data.expiresIn,
						loginTime: Date.now()
					});

					console.log('Login successful:', result.data.email);

					// Update UI
					updateUIForAuth();

					// Close modal
					loginModal.classList.remove('show');
					loginForm.reset();

				} catch (error) {
					console.error('Login error:', error);
					loginError.textContent = error.message || 'Login failed';
					loginError.classList.add('show');
				} finally {
					submitBtn.textContent = 'LOGIN';
					submitBtn.disabled = false;
				}
			});

			// ========================================
			// INITIALIZE AUTHENTICATION ON PAGE LOAD
			// ========================================
			setTimeout(async () => {
				console.log('Initializing authentication system...');
				await loadAuth();
				startTokenRefreshTimer();
				console.log('Authentication system initialized');
			}, 500);

			// Shuffle array function
			function shuffleArray(array) {
				const shuffled = [...array];
				for (let i = shuffled.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
				}
				return shuffled;
			}

			// API endpoint configuration
			const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
				? 'http://localhost:3000'
				: window.location.origin; // Use same domain as the app (Vercel)

			// Fetch tracks and users from API
			let tracksData = [];
			let usersData = {};
			let currentTrackIndex = -1;

			// Fetch both tracks and users
			Promise.all([
				fetch(`${API_BASE_URL}/api/v1/tracks`).then(r => r.json()),
				fetch(`${API_BASE_URL}/api/v1/users`).then(r => r.json())
			])
				.then(([tracksResult, usersResult]) => {
					if (tracksResult.success && tracksResult.data) {
						tracksData = tracksResult.data;
					} else {
						throw new Error('Failed to load tracks');
					}

					if (usersResult.success && usersResult.data) {
						usersData = usersResult.data;
					}

					// Merge user data into tracks
					tracksData = tracksData.map(track => {
						if (track.user_id && usersData[track.user_id]) {
							const user = usersData[track.user_id];
							return {
								...track,
								artistName: user.displayName || user.username || 'Unknown Artist',
								artistUsername: user.username || null
							};
						}
						return {
							...track,
							artistName: 'Unknown Artist',
							artistUsername: null
						};
					});

					// Shuffle the tracks for random order
					tracksData = shuffleArray(tracksData);
					displayTracks(tracksData);
				})
				.catch(error => {
					console.error('Error loading data from API:', error);
					document.getElementById('tracks-container').innerHTML = '<div style="text-align: center; color: #ff0000; padding: 20px;">Failed to load tracks. Make sure API server is running.</div>';
				});

			// Setup search
			document.getElementById('search-input').addEventListener('input', (e) => {
				const query = e.target.value.toLowerCase();
				const filtered = tracksData.filter(track =>
					(track.title && track.title.toLowerCase().includes(query)) ||
					(track.genre && track.genre.toLowerCase().includes(query)) ||
					(track.description && track.description.toLowerCase().includes(query)) ||
					(track.artistName && track.artistName.toLowerCase().includes(query))
				);
				displayTracks(filtered);
			});

			function displayTracks(tracks) {
				const container = document.getElementById('tracks-container');

				if (tracks.length === 0) {
					container.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No tracks found</div>';
					return;
				}

				container.innerHTML = tracks.map((track, index) => {
					const artistDisplay = track.artistUsername
						? `<a href="https://www.sublair.com/u/${track.artistUsername}" target="_blank" class="artist-link" onclick="event.stopPropagation();">${track.artistName}</a>`
						: (track.artistName || 'Unknown Artist');

					return `
						<div class="track-item" data-track-index="${index}" data-track-id="${track.id}" data-user-id="${track.user_id || ''}" data-title="${track.title || 'UNKNOWN'}" data-artwork="${track.artwork_url || ''}" data-artist-name="${track.artistName || 'Unknown Artist'}" data-artist-username="${track.artistUsername || ''}">
							<div class="track-title">${track.title}</div>
							<div class="track-meta">${artistDisplay} • ${track.genre || 'Unknown'}</div>
						</div>
					`;
				}).join('');

				// Add click handlers to play tracks
			document.querySelectorAll('.track-item').forEach(item => {
				item.addEventListener('click', function() {
					const trackIndex = parseInt(this.getAttribute('data-track-index'));
					const trackId = this.getAttribute('data-track-id');
					const trackUserId = this.getAttribute('data-user-id');
					const trackTitle = this.getAttribute('data-title');
					const artworkUrl = this.getAttribute('data-artwork');
					const artistName = this.getAttribute('data-artist-name');
					const artistUsername = this.getAttribute('data-artist-username');
					// Use API stream proxy instead of direct URL
					const streamUrl = `${API_BASE_URL}/api/v1/stream/${trackId}`;
					currentTrackIndex = trackIndex;
					playTrack(streamUrl, trackTitle, artworkUrl, trackId, trackUserId, artistName, artistUsername);
				});
			});
			}

			let currentTrack = null;
			let currentTrackTitle = '';
			let isAudioPaused = false;

			// Audio play/pause button
			document.getElementById('audio-play-pause').addEventListener('click', () => {
				if (!positionalAudio.buffer) return; // No track loaded

				if (positionalAudio.isPlaying) {
					// Pause
					positionalAudio.pause();
					isAudioPaused = true;
					window.isPlaybackPaused = true;
					const playPauseBtn = document.getElementById('audio-play-pause');
					if (playPauseBtn) playPauseBtn.textContent = '▶ PLAY';
					const statusEl = document.getElementById('desktop-audio-status');
					if (statusEl) statusEl.textContent = 'PAUSED';
					updatePhonePlayerUI();

					// Broadcast pause to spectators
					if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
						multiplayerWs.send(JSON.stringify({
							type: 'audio_pause'
						}));
						console.log('🎵 Broadcasting pause to spectators');
					}
				} else {
					// Play/Resume
					positionalAudio.play();
					isAudioPaused = false;
					window.isPlaybackPaused = false;
					const playPauseBtn = document.getElementById('audio-play-pause');
					if (playPauseBtn) playPauseBtn.textContent = '❚❚ PAUSE';
					const statusEl = document.getElementById('desktop-audio-status');
					if (statusEl) statusEl.textContent = `NOW PLAYING:\n${currentTrackTitle}`;
					updatePhonePlayerUI();

					// Broadcast resume to spectators
					if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
						multiplayerWs.send(JSON.stringify({
							type: 'audio_resume'
						}));
						console.log('🎵 Broadcasting resume to spectators');
					}
				}
			});

			// Audio stop button
			document.getElementById('audio-stop').addEventListener('click', () => {
				if (positionalAudio.buffer) {
					positionalAudio.stop();
					isAudioPaused = false;
					const statusEl = document.getElementById('desktop-audio-status');
					if (statusEl) statusEl.textContent = 'STOPPED';
					const playPauseBtn = document.getElementById('audio-play-pause');
					if (playPauseBtn) {
						playPauseBtn.textContent = '▶ PLAY';
						playPauseBtn.disabled = true;
					}
					const stopBtn = document.getElementById('audio-stop');
					if (stopBtn) stopBtn.disabled = true;

					// Hide Now Playing display
					hideNowPlayingDisplay();

					// Broadcast stop to spectators
					if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
						multiplayerWs.send(JSON.stringify({
							type: 'audio_stop'
						}));
						console.log('🎵 Broadcasting stop to spectators');
					}
				}
			});

			// EQ Controls
			document.getElementById('eq-low').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.low.gain.value = value;
				document.getElementById('eq-low-value').textContent = `${value > 0 ? '+' : ''}${value} dB`;

				// Broadcast EQ change to spectators if hosting
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					multiplayerWs.send(JSON.stringify({
						type: 'eq_update',
						band: 'low',
						value: value
					}));
				}
			});

			document.getElementById('eq-mid').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.mid.gain.value = value;
				document.getElementById('eq-mid-value').textContent = `${value > 0 ? '+' : ''}${value} dB`;

				// Broadcast EQ change to spectators if hosting
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					multiplayerWs.send(JSON.stringify({
						type: 'eq_update',
						band: 'mid',
						value: value
					}));
				}
			});

			document.getElementById('eq-high').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.high.gain.value = value;
				document.getElementById('eq-high-value').textContent = `${value > 0 ? '+' : ''}${value} dB`;

				// Broadcast EQ change to spectators if hosting
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					multiplayerWs.send(JSON.stringify({
						type: 'eq_update',
						band: 'high',
						value: value
					}));
				}
			});

			document.getElementById('master-volume').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				if (window.eqFilters && window.eqFilters.masterGain) {
					window.eqFilters.masterGain.gain.value = value / 100;
				}
				document.getElementById('master-volume-value').textContent = `${value}%`;

				// Broadcast master volume change to spectators if hosting
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					multiplayerWs.send(JSON.stringify({
						type: 'eq_update',
						band: 'masterVolume',
						value: value
					}));
				}
			});

			document.getElementById('filter-lowpass').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.lowpass.frequency.value = value;
				document.getElementById('filter-lowpass-value').textContent = `${value} Hz`;

				// Broadcast lowpass filter change to spectators if hosting
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					multiplayerWs.send(JSON.stringify({
						type: 'eq_update',
						band: 'lowpass',
						value: value
					}));
				}
			});

			document.getElementById('filter-highpass').addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.eqFilters.highpass.frequency.value = value;
				document.getElementById('filter-highpass-value').textContent = `${value} Hz`;

				// Broadcast highpass filter change to spectators if hosting
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					multiplayerWs.send(JSON.stringify({
						type: 'eq_update',
						band: 'highpass',
						value: value
					}));
				}
			});

			document.getElementById('eq-reset').addEventListener('click', () => {
				// Reset all EQ filters to 0
				window.eqFilters.low.gain.value = 0;
				window.eqFilters.mid.gain.value = 0;
				window.eqFilters.high.gain.value = 0;

				// Reset lowpass/highpass to defaults
				window.eqFilters.lowpass.frequency.value = 20000;
				window.eqFilters.highpass.frequency.value = 20;

				// Reset UI
				document.getElementById('eq-low').value = 0;
				document.getElementById('eq-mid').value = 0;
				document.getElementById('eq-high').value = 0;
				document.getElementById('eq-low-value').textContent = '0 dB';
				document.getElementById('eq-mid-value').textContent = '0 dB';
				document.getElementById('eq-high-value').textContent = '0 dB';

				document.getElementById('filter-lowpass').value = 20000;
				document.getElementById('filter-highpass').value = 20;
				document.getElementById('filter-lowpass-value').textContent = '20000 Hz';
				document.getElementById('filter-highpass-value').textContent = '20 Hz';

				// Broadcast EQ reset to spectators if hosting
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					multiplayerWs.send(JSON.stringify({
						type: 'eq_reset'
					}));
				}
			});

			// Play count tracking
			let currentTrackId = null;
			let hasAwardedPlayCount = false;

			// Function to show floating OM reward - simple centered toast
			function showOmReward(amount) {
				// Create centered toast notification
				const toast = document.createElement('div');
				toast.style.position = 'fixed';
				toast.style.top = '50%';
				toast.style.left = '50%';
				toast.style.transform = 'translate(-50%, -50%)';
				toast.style.background = 'rgba(0, 0, 0, 0.9)';
				toast.style.border = '2px solid #bee17b';
				toast.style.borderRadius = '8px';
				toast.style.padding = '12px 24px';
				toast.style.fontFamily = 'Share, Courier New, monospace';
				toast.style.fontSize = '28px';
				toast.style.fontWeight = 'bold';
				toast.style.color = '#bee17b';
				toast.style.textShadow = '0 0 10px rgba(190, 225, 123, 0.8)';
				toast.style.boxShadow = '0 0 20px rgba(190, 225, 123, 0.5)';
				toast.style.pointerEvents = 'none';
				toast.style.zIndex = '10001';
				toast.textContent = `+${amount} Ω`;

				document.body.appendChild(toast);
				console.log('✨ Created OM reward toast notification');

				// Animate: scale in, pause, scale out and fade
				const startTime = Date.now();
				const duration = 2000;

				function animate() {
					const elapsed = Date.now() - startTime;
					const progress = elapsed / duration;

					if (progress < 0.2) {
						// Scale in
						const scale = progress / 0.2;
						toast.style.transform = `translate(-50%, -50%) scale(${scale})`;
						toast.style.opacity = '1';
					} else if (progress < 0.7) {
						// Hold
						toast.style.transform = 'translate(-50%, -50%) scale(1)';
						toast.style.opacity = '1';
					} else {
						// Scale out and fade
						const fadeProgress = (progress - 0.7) / 0.3;
						const scale = 1 + (fadeProgress * 0.5);
						toast.style.transform = `translate(-50%, -50%) scale(${scale})`;
						toast.style.opacity = (1 - fadeProgress).toString();
					}

					if (progress < 1) {
						requestAnimationFrame(animate);
					} else {
						toast.remove();
						console.log('🗑️ Removed OM reward toast');
					}
				}

				animate();
			}

			window.incrementPlayCount = async function(trackId, trackUserId) {
				if (!trackId) return;

				// Don't count plays if the user is listening to their own track
				if (window.authState?.isLoggedIn && window.authState?.uid === trackUserId) {
					console.log(`⏭️ Skipping play count for own track ${trackId}`);
					return;
				}

				try {
					// Send uid to award OMs if user is logged in
					const body = window.authState?.isLoggedIn ? { uid: window.authState.uid } : {};

					const response = await fetch(`${API_BASE_URL}/api/v1/tracks/${trackId}/play`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(body)
					});
					const result = await response.json();
					if (result.success) {
						console.log(`✅ Listen count incremented for track ${trackId}: ${result.data.listens_count}`);

						// Update OM display if OMs were awarded
						if (result.data.oms !== null && result.data.oms !== undefined) {
							console.log(`🎮 Earned 33 OMs! New total: ${result.data.oms}`);
							console.log(`🎮 Calling showOmReward(33)...`);
							console.log(`🎮 window.character exists:`, !!window.character);
							console.log(`🎮 window.world exists:`, !!window.world);

							// Show floating +33 animation above character
							showOmReward(33);

							const omCountElement = document.getElementById('om-count');
							if (omCountElement) {
								omCountElement.textContent = result.data.oms;
							}
							// Update authState
							if (window.authState) {
								window.authState.user.oms = result.data.oms;
							}
						}
					}
				} catch (error) {
					console.error('Error incrementing listen count:', error);
				}
			};

			// Helper function to update Now Playing display
			function updateNowPlayingDisplay(title, artistName, artistUsername, artworkUrl, trackId) {
				const display = document.getElementById('now-playing-display');
				const titleEl = document.getElementById('now-playing-title');
				const artistEl = document.getElementById('now-playing-artist');
				const artworkImg = document.getElementById('now-playing-artwork-img');

				// Make title clickable if trackId is provided
				if (trackId) {
					titleEl.innerHTML = `<a href="https://www.sublair.com/track/${trackId}" target="_blank" style="pointer-events: auto; color: inherit; text-decoration: none;">${title || 'UNKNOWN TRACK'}</a>`;
				} else {
					titleEl.textContent = title || 'UNKNOWN TRACK';
				}

				if (artistUsername) {
					artistEl.innerHTML = `by <a href="https://www.sublair.com/u/${artistUsername}" target="_blank" style="pointer-events: auto;">${artistName || 'Unknown Artist'}</a>`;
				} else {
					artistEl.textContent = `by ${artistName || 'Unknown Artist'}`;
				}

				if (artworkUrl) {
					artworkImg.src = artworkUrl;
					artworkImg.style.display = 'block';
				} else {
					artworkImg.style.display = 'none';
				}

				display.classList.add('show');
			}

			// Helper function to hide Now Playing display
			function hideNowPlayingDisplay() {
				const display = document.getElementById('now-playing-display');
				display.classList.remove('show');
			}

			function playTrack(url, title, artworkUrl, trackId, trackUserId, artistName, artistUsername) {
				// Reset playback tracking for new track
				currentTrackId = trackId;
				const currentTrackUserId = trackUserId;
				hasAwardedPlayCount = false;

				// Update desktop audio player
				document.getElementById('desktop-track-title').textContent = title || 'UNKNOWN TRACK';

				// Update artist name with link if username available
				const artistEl = document.getElementById('desktop-artist-name');
				if (artistUsername) {
					artistEl.innerHTML = `by <a href="https://www.sublair.com/u/${artistUsername}" target="_blank">${artistName || 'Unknown Artist'}</a>`;
				} else {
					artistEl.textContent = `by ${artistName || 'Unknown Artist'}`;
				}

				document.getElementById('audio-play-pause').disabled = false;
				document.getElementById('audio-stop').disabled = false;
				currentTrackTitle = title || 'UNKNOWN TRACK';
				window.currentArtistName = artistName || 'Unknown Artist';
				window.currentArtistUsername = artistUsername;

				// Update Now Playing display
				updateNowPlayingDisplay(title, artistName, artistUsername, artworkUrl, trackId);

				// Broadcast track info to spectators if hosting
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					multiplayerWs.send(JSON.stringify({
						type: 'track_info',
						trackData: {
							title: title || 'UNKNOWN TRACK',
							artistName: artistName || 'Unknown Artist',
							artistUsername: artistUsername,
							artworkUrl: artworkUrl,
							trackId: trackId
						}
					}));
					console.log('📡 Broadcasting track info to spectators:', title);
				}

				// Show loading indicator
				const loadingDiv = document.getElementById('audio-loading');
				loadingDiv.classList.add('show');
				loadingDiv.innerHTML = 'Loading audio... 0%';

				// Stop current track if playing
				if (positionalAudio.isPlaying) {
					positionalAudio.stop();
				}

				// Load and play new track
				const audioLoader = new THREE.AudioLoader();
				audioLoader.load(url, (buffer) => {
					positionalAudio.setBuffer(buffer);
					positionalAudio.setLoop(false);
					positionalAudio.setVolume(1.0);

					// Connect EQ filters chain
					const source = positionalAudio.getOutput();
					source.disconnect();
					source.connect(window.speakerDirectionalBass);
					window.speakerDirectionalBass.connect(window.speakerDirectionalLowpass);
					window.speakerDirectionalLowpass.connect(window.eqFilters.vehicleLowpass);
					window.eqFilters.vehicleLowpass.connect(window.eqFilters.lowpass);
					window.eqFilters.lowpass.connect(window.eqFilters.highpass);
					window.eqFilters.highpass.connect(window.eqFilters.low);
					window.eqFilters.low.connect(window.eqFilters.mid);
					window.eqFilters.mid.connect(window.eqFilters.high);
					window.eqFilters.high.connect(window.eqFilters.masterGain);
					window.eqFilters.masterGain.connect(window.audioAnalyser);
					window.audioAnalyser.connect(positionalAudio.context.destination);

					// In multiplayer, wait for spectators to load before playing
					if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN && window.spectatorCount > 0) {
						console.log('🎵 Waiting for spectators to load track...');
						loadingDiv.innerHTML = 'Waiting for spectators...';

						// Broadcast preload to spectators
						multiplayerWs.send(JSON.stringify({
							type: 'audio_preload',
							track: {
								title: title,
								artworkUrl: artworkUrl,
								trackId: trackId,
								url: url,
								artistName: artistName,
								artistUsername: artistUsername
							}
						}));

						// Wait for all spectators to be ready (with 10 second timeout)
						const waitForSpectators = new Promise((resolve) => {
							const readySpectators = new Set();
							const expectedCount = window.spectatorCount;
							const timeout = setTimeout(() => {
								console.log('⏱️ Timeout waiting for spectators, playing anyway');
								resolve();
							}, 10000); // 10 second timeout

							window.spectatorReadyHandler = (spectatorId) => {
								readySpectators.add(spectatorId);
								console.log(`✅ Spectator ${spectatorId} ready (${readySpectators.size}/${expectedCount})`);
								loadingDiv.innerHTML = `Waiting... ${readySpectators.size}/${expectedCount} ready`;

								if (readySpectators.size >= expectedCount) {
									clearTimeout(timeout);
									resolve();
								}
							};
						});

						waitForSpectators.then(() => {
							// All spectators ready, do countdown
							let countdown = 3;
							loadingDiv.innerHTML = `Starting in ${countdown}...`;
							const countdownInterval = setInterval(() => {
								countdown--;
								if (countdown > 0) {
									loadingDiv.innerHTML = `Starting in ${countdown}...`;
								} else {
									clearInterval(countdownInterval);
									loadingDiv.classList.remove('show');

									// Broadcast play command
									window.trackStartTime = Date.now();
									multiplayerWs.send(JSON.stringify({
										type: 'audio_play_sync',
										startTime: window.trackStartTime
									}));

									// Play for host
									positionalAudio.play();
									console.log('🎵 Synchronized playback started!');
								}
							}, 1000);
						});
					} else {
						// No multiplayer or no spectators, play immediately
						positionalAudio.play();
						loadingDiv.classList.remove('show');
					}

					currentTrack = url;

					// Set global playback state for desktop
					window.currentPlaybackSource = 'desktop';
					window.currentPlaybackTrack = {
						title: title,
						artworkUrl: artworkUrl,
						trackId: trackId,
						url: url
					};
					window.isPlaybackPaused = false;
					updatePhonePlayerUI();

					// Use timeupdate event to track playback progress (industry standard)
					const timeUpdateHandler = function() {
						const currentTime = positionalAudio.context.currentTime - (positionalAudio._startedAt || 0) + (positionalAudio._progress || 0);

						// Award play count when user reaches 30 seconds of playback
						if (currentTime >= 30 && !hasAwardedPlayCount && currentTrackId) {
							hasAwardedPlayCount = true;
							window.incrementPlayCount(currentTrackId, currentTrackUserId);
							console.log(`✅ Awarded play count at ${currentTime.toFixed(1)}s of playback`);
							// Remove listener after awarding
							positionalAudio.source.removeEventListener('ended', timeUpdateHandler);
						}
					};

					// Check playback time periodically
					const playbackCheckInterval = setInterval(() => {
						if (positionalAudio.isPlaying) {
							timeUpdateHandler();
						}
						if (hasAwardedPlayCount) {
							clearInterval(playbackCheckInterval);
						}
					}, 1000);

					// Auto-play next track when current one ends
					positionalAudio.onEnded = function() {
						clearInterval(playbackCheckInterval);
						console.log('🔄 Track ended, playing next...');
						playNextTrack();
					};

					// Update desktop audio player (already updated at start of playTrack)
					document.getElementById('audio-play-pause').textContent = '❚❚ PAUSE';
					document.getElementById('audio-play-pause').disabled = false;
					document.getElementById('audio-stop').disabled = false;
					isAudioPaused = false;

					// Update desktop album art
					const albumArtEl = document.getElementById('desktop-album-art');
					if (artworkUrl) {
						albumArtEl.style.backgroundImage = `url(${artworkUrl})`;
						albumArtEl.style.backgroundSize = 'cover';
						albumArtEl.style.backgroundPosition = 'center';
						albumArtEl.textContent = '';
					} else {
						albumArtEl.style.backgroundImage = 'none';
						albumArtEl.textContent = 'NO ARTWORK';
					}

					// Update computer screen with artwork
					if (window.updateComputerScreen) {
						window.updateComputerScreen(artworkUrl);
					}

					// Hide loading indicator and show success
					loadingDiv.innerHTML = 'NOW PLAYING';
					setTimeout(() => {
						loadingDiv.classList.remove('show');
					}, 2000);
				},
				(progress) => {
					const percent = (progress.loaded / progress.total * 100).toFixed(0);
					loadingDiv.innerHTML = `Loading audio... ${percent}%`;
					console.log('Loading audio:', percent + '%');
				},
				(error) => {
					console.error('Error loading audio:', error);
					loadingDiv.innerHTML = 'ERROR LOADING AUDIO';
					document.getElementById('desktop-track-title').textContent = 'ERROR: FAILED TO LOAD';
					document.getElementById('audio-play-pause').disabled = true;
					document.getElementById('audio-stop').disabled = true;
					setTimeout(() => {
						loadingDiv.classList.remove('show');
					}, 3000);
				});
			}

			// Play next track (random shuffle)
			function playNextTrack() {
				if (tracksData.length === 0) return;

				// Pick a random next track
				const nextIndex = Math.floor(Math.random() * tracksData.length);
				currentTrackIndex = nextIndex;

				const track = tracksData[nextIndex];
				const streamUrl = `${API_BASE_URL}/api/v1/stream/${track.id}`;
				playTrack(streamUrl, track.title, track.artwork_url, track.id, track.user_id, track.artistName, track.artistUsername);
			}

			// Create interaction prompt
			const interactionPrompt = document.createElement('div');
			interactionPrompt.className = 'interaction-prompt';
			interactionPrompt.innerHTML = 'Press <kbd>F</kbd> to use computer';
			document.body.appendChild(interactionPrompt);

			// Create audio loading indicator
			const audioLoadingDiv = document.createElement('div');
			audioLoadingDiv.id = 'audio-loading';
			audioLoadingDiv.innerHTML = 'Loading audio...';
			document.body.appendChild(audioLoadingDiv);

			// Load the retro computer
			let computerPosition = new THREE.Vector3(-5, 0.75, 5);
			loadingManager.loadGLTF('build/assets/retro_computer.glb', (computerModel) => {
				const computer = computerModel.scene;
				window.computer = computer; // Make globally accessible for customization
				computer.position.copy(computerPosition);
				computer.scale.set(1, 1, 1);

				// Add to world
				world.graphicsWorld.add(computer);

				// Apply host customization to computer if spectator and customization already received
				if (isSpectatorMode && window.hostCustomization) {
					const c = window.hostCustomization;
					computer.traverse((child) => {
						if (child.isMesh && child.material) {
							const matName = child.material.name;
							if (matName === 'CHASSIS' || matName.toLowerCase().includes('chassis')) {
								child.material.color.set(c.computerChassisColor);
							} else if (matName === 'KEYBOARD' || matName.toLowerCase().includes('keyboard')) {
								child.material.color.set(c.computerKeyboardColor);
							} else if (matName === 'FEATURES' || matName.toLowerCase().includes('features')) {
								child.material.color.set(c.computerFeaturesColor);
							}
							child.material.needsUpdate = true;
						}
					});
					console.log('🎨 Applied host computer customization on load');
				}

				// Setup materials for shadows, apply saved colors, and find screen
				let screenMesh = null;
				computer.traverse((child) => {
					if (child.isMesh) {
						child.castShadow = true;
						child.receiveShadow = true;
						if (child.material) {
							world.sky.csm.setupMaterial(child.material);

							// Apply saved customization colors - check both lowercase and uppercase
							const matName = child.material.name;
							if ((matName === 'CHASIS' || matName.toLowerCase().includes('chasis')) && window.computerChassisColor) {
								child.material.color.set(window.computerChassisColor);
								console.log('✅ Applied CHASIS color:', window.computerChassisColor);
							} else if ((matName === 'KEYBOARD' || matName.toLowerCase().includes('keyboard')) && window.computerKeyboardColor) {
								child.material.color.set(window.computerKeyboardColor);
								console.log('✅ Applied KEYBOARD color:', window.computerKeyboardColor);
							} else if ((matName === 'FEATURES' || matName.toLowerCase().includes('features')) && window.computerFeaturesColor) {
								child.material.color.set(window.computerFeaturesColor);
								console.log('✅ Applied FEATURES color:', window.computerFeaturesColor);
							}
						}

					// Look for screen material by name
					if (child.material && child.material.name &&
					    child.material.name.toLowerCase().includes('screen')) {
						screenMesh = child;
						console.log('✅ Found screen mesh:', child.name, 'with material:', child.material.name);
					}
					}
				});

				// Make screen glow and store reference globally
				if (screenMesh) {
					// Clone material to avoid affecting other meshes
					screenMesh.material = screenMesh.material.clone();
					screenMesh.material.color = new THREE.Color(0x000000); // Dark screen
					screenMesh.material.emissive = new THREE.Color(0x000000); // No glow initially
					screenMesh.material.emissiveIntensity = 0;

					// Store screen mesh globally for updating album art
					window.computerScreenMesh = screenMesh;

					// Add point light for screen glow (off initially)
					const screenLight = new THREE.PointLight(0x000000, 0, 3);
					screenLight.position.copy(computerPosition);
					screenLight.position.y += 0.5; // Raise light to screen height
					world.graphicsWorld.add(screenLight);
					window.computerScreenLight = screenLight;

					console.log('💻 Computer screen ready for album art display');
				} else {
					// Fallback: create manual screen plane
					const screenGeometry = new THREE.PlaneGeometry(0.3, 0.2);
					const screenMaterial = new THREE.MeshStandardMaterial({
						color: 0x000000,
						emissive: 0xbee17b,
						emissiveIntensity: 0.5
					});
					const screenPlane = new THREE.Mesh(screenGeometry, screenMaterial);
					screenPlane.position.copy(computerPosition);
					screenPlane.position.y += 0.3;
					screenPlane.position.z += 0.3;
					computer.add(screenPlane);

					window.computerScreenMesh = screenPlane;

					// Add point light
					const screenLight = new THREE.PointLight(0xbee17b, 1.5, 3);
					screenLight.position.copy(computerPosition);
					screenLight.position.y += 0.5;
					world.graphicsWorld.add(screenLight);
					window.computerScreenLight = screenLight;

					console.log('💻 Computer screen (fallback) ready for album art display');
				}

				// Add physics collision box for the computer
				const computerShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.75, 0.5));
				const computerBody = new CANNON.Body({
					mass: 0, // Static object (won't move)
					shape: computerShape,
					position: new CANNON.Vec3(-5, 0.75, 5)
				});
				world.physicsWorld.addBody(computerBody);
			});


		// Function to update computer screen with album artwork
		window.updateComputerScreen = function(artworkUrl) {
			if (!window.computerScreenMesh) {
				console.warn('Computer screen mesh not ready');
				return;
			}

			if (!artworkUrl) {
				// No artwork - show green glow
				if (window.computerScreenMesh.material.map) {
					window.computerScreenMesh.material.map.dispose();
					window.computerScreenMesh.material.map = null;
				}
				window.computerScreenMesh.material.emissive = new THREE.Color(0xbee17b);
				window.computerScreenMesh.material.emissiveIntensity = 0.5;
				window.computerScreenMesh.material.needsUpdate = true;
				if (window.computerScreenLight) {
					window.computerScreenLight.color = new THREE.Color(0xbee17b);
				}
				return;
			}

			// Load artwork image
			const loader = new THREE.TextureLoader();
			loader.crossOrigin = "anonymous";
			loader.load(artworkUrl, (texture) => {
				// Create normalized square canvas with artwork centered
				const size = 512; // Fixed square size

				// Draw everything in normal orientation
				const canvas = document.createElement('canvas');
				const ctx = canvas.getContext('2d');
				canvas.width = size;
				canvas.height = size;

				// Fill with black background
				ctx.fillStyle = '#000000';
				ctx.fillRect(0, 0, size, size);

				// Calculate dimensions to fit image in square while maintaining aspect ratio
				const img = texture.image;
				const scale = Math.min(size / img.width, size / img.height) * 0.5; // Scale down to 50% for padding
				const scaledWidth = img.width * scale;
				const scaledHeight = img.height * scale;

				// Draw the album art centered, with space at top for VU meters
				const artY = (size - scaledHeight) / 2 + 40; // Offset down for VU meters
				const artX = (size - scaledWidth) / 2;
				ctx.drawImage(img, artX, artY, scaledWidth, scaledHeight);

				// Store the base canvas for animation (normal orientation)
				window.screenBaseCanvas = canvas;
				window.screenBaseImage = ctx.getImageData(0, 0, size, size);

				// Create animated canvas with glitch effects
				const animCanvas = document.createElement('canvas');
				animCanvas.width = size;
				animCanvas.height = size;
				const animCtx = animCanvas.getContext('2d');

				// Create new texture from animated canvas
				const normalizedTexture = new THREE.CanvasTexture(animCanvas);
				normalizedTexture.wrapS = THREE.ClampToEdgeWrapping;
				normalizedTexture.wrapT = THREE.ClampToEdgeWrapping;

				// Update screen material with normalized artwork
				if (window.computerScreenMesh.material.map) {
					window.computerScreenMesh.material.map.dispose();
				}
				window.computerScreenMesh.material.map = normalizedTexture;
				window.computerScreenMesh.material.color = new THREE.Color(0xffffff); // White to show texture
				window.computerScreenMesh.material.emissive = new THREE.Color(0x222222);
				window.computerScreenMesh.material.emissiveIntensity = 0.3;
				window.computerScreenMesh.material.needsUpdate = true;

				// Glitch animation loop
				let glitchOffset = 0;
				let scanlineOffset = 0;
				let glitchIntensity = 0;
				let nextGlitch = Date.now() + Math.random() * 3000 + 2000; // Random glitch every 2-5 seconds

				// Waveform history for Rekordbox-style display
				const waveformHistory = [];
				const waveformMaxBars = 60;

				function animateScreen() {
					if (!window.screenBaseCanvas || !window.screenBaseImage) return;

					// Get audio data for reactive effects
					let audioLevel = 0;
					let bassLevel = 0;
					let trebleLevel = 0;

					if (window.audioAnalyser && positionalAudio && positionalAudio.isPlaying) {
						const frequencyData = new Uint8Array(window.audioAnalyser.frequencyBinCount);
						window.audioAnalyser.getByteFrequencyData(frequencyData);

						// Calculate bass (low frequencies)
						let bassSum = 0;
						for (let i = 0; i < frequencyData.length * 0.1; i++) {
							bassSum += frequencyData[i];
						}
						bassLevel = bassSum / (frequencyData.length * 0.1) / 255;

						// Calculate treble (high frequencies)
						let trebleSum = 0;
						for (let i = Math.floor(frequencyData.length * 0.7); i < frequencyData.length; i++) {
							trebleSum += frequencyData[i];
						}
						trebleLevel = trebleSum / (frequencyData.length * 0.3) / 255;

						// Overall audio level
						let sum = 0;
						for (let i = 0; i < frequencyData.length; i++) {
							sum += frequencyData[i];
						}
						audioLevel = sum / frequencyData.length / 255;
					}

					// Put base image on animated canvas
					animCtx.putImageData(window.screenBaseImage, 0, 0);

					// Draw mini VU meters, Stereoscope, and Waveform (inline, 75% width)
					if (window.audioAnalyser && positionalAudio && positionalAudio.isPlaying) {
						const frequencyData = new Uint8Array(window.audioAnalyser.frequencyBinCount);
						window.audioAnalyser.getByteFrequencyData(frequencyData);

						const timeData = new Uint8Array(window.audioAnalyser.frequencyBinCount);
						window.audioAnalyser.getByteTimeDomainData(timeData);

						const baseY = size / 2 - 135; // Moved up more to clear cover art
						const totalContainerWidth = size * 0.75; // 75% of screen width
						const containerStartX = (size - totalContainerWidth) / 2;
						const gap = 10; // Gap between blocks
						const blockWidth = (totalContainerWidth - gap * 2) / 3; // Each block gets 1/3

						// ==== VU METERS (Left side) ====
						const meterCount = 20; // Fewer meters to fit in smaller space
						const meterWidth = Math.floor(blockWidth / meterCount) - 2;
						const meterMaxHeight = 40;
						const meterY = baseY;
						const meterStartX = containerStartX;

						// Dark background for VU meters
						animCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
						animCtx.fillRect(meterStartX - 5, meterY - 10, blockWidth + 10, meterMaxHeight + 20);

						for (let i = 0; i < meterCount; i++) {
							const dataIndex = Math.floor((i / meterCount) * frequencyData.length);
							const value = frequencyData[dataIndex] / 255;
							const meterHeight = value * meterMaxHeight;
							const x = meterStartX + i * (meterWidth + 2);

							// Color based on height
							let color;
							if (value < 0.5) {
								color = '#00ff00';
							} else if (value < 0.8) {
								color = '#ffff00';
							} else {
								color = '#ff0000';
							}

							animCtx.fillStyle = color;
							animCtx.fillRect(x, meterY + meterMaxHeight - meterHeight, meterWidth, meterHeight);

							animCtx.strokeStyle = '#bee17b';
							animCtx.lineWidth = 1;
							animCtx.strokeRect(x, meterY, meterWidth, meterMaxHeight);
						}

						// ==== STEREOSCOPE (Middle) ====
						const scopeY = baseY;
						const scopeWidth = blockWidth;
						const scopeHeight = 40; // Match VU meter height
						const scopeStartX = containerStartX + blockWidth + gap;

						// Dark background for stereoscope
						animCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
						animCtx.fillRect(scopeStartX - 5, scopeY - 10, scopeWidth + 10, scopeHeight + 20);

						// Draw oscilloscope waveform
						animCtx.strokeStyle = '#00ff00';
						animCtx.lineWidth = 2;
						animCtx.beginPath();

						const sliceWidth = scopeWidth / timeData.length;
						let x = scopeStartX;

						for (let i = 0; i < timeData.length; i++) {
							const v = timeData[i] / 128.0;
							const y = scopeY + (v * scopeHeight / 2);

							if (i === 0) {
								animCtx.moveTo(x, y);
							} else {
								animCtx.lineTo(x, y);
							}

							x += sliceWidth;
						}

						animCtx.stroke();

						// Draw border
						animCtx.strokeStyle = '#bee17b';
						animCtx.lineWidth = 1;
						animCtx.strokeRect(scopeStartX, scopeY, scopeWidth, scopeHeight);

						// ==== WAVEFORM (Right side - Rekordbox RGB style) ====
						const waveY = baseY;
						const waveWidth = blockWidth;
						const waveHeight = 40;
						const waveStartX = containerStartX + (blockWidth + gap) * 2;

						// Calculate frequency bands for RGB waveform
						const bassEnd = Math.floor(frequencyData.length * 0.1); // Low frequencies
						const midEnd = Math.floor(frequencyData.length * 0.5); // Mid frequencies
						// Rest is highs

						let bassLevel = 0;
						let midLevel = 0;
						let highLevel = 0;

						// Sum up each frequency band
						for (let i = 0; i < bassEnd; i++) {
							bassLevel += frequencyData[i];
						}
						for (let i = bassEnd; i < midEnd; i++) {
							midLevel += frequencyData[i];
						}
						for (let i = midEnd; i < frequencyData.length; i++) {
							highLevel += frequencyData[i];
						}

						// Normalize to 0-1 range
						bassLevel = (bassLevel / bassEnd) / 255;
						midLevel = (midLevel / (midEnd - bassEnd)) / 255;
						highLevel = (highLevel / (frequencyData.length - midEnd)) / 255;

						// Add to waveform history
						waveformHistory.push({ bass: bassLevel, mid: midLevel, high: highLevel });
						if (waveformHistory.length > waveformMaxBars) {
							waveformHistory.shift(); // Remove oldest
						}

						// Dark background for waveform
						animCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
						animCtx.fillRect(waveStartX - 5, waveY - 10, waveWidth + 10, waveHeight + 20);

						// Draw center line
						animCtx.strokeStyle = '#333333';
						animCtx.lineWidth = 1;
						animCtx.beginPath();
						animCtx.moveTo(waveStartX, waveY + waveHeight / 2);
						animCtx.lineTo(waveStartX + waveWidth, waveY + waveHeight / 2);
						animCtx.stroke();

						// Draw RGB waveform bars (Rekordbox style)
						const barWidth = waveWidth / waveformMaxBars;
						const centerY = waveY + waveHeight / 2;

						for (let i = 0; i < waveformHistory.length; i++) {
							const frame = waveformHistory[i];
							const barX = waveStartX + i * barWidth;

							// Calculate total amplitude and individual band heights
							const totalAmplitude = (frame.bass + frame.mid + frame.high) / 3;
							const maxBarHeight = waveHeight / 2;

							// Draw stacked frequency bands (from center outward)
							// Red (bass) at bottom/top
							const bassHeight = frame.bass * maxBarHeight;
							animCtx.fillStyle = '#ff0000';
							animCtx.fillRect(barX, centerY - bassHeight, barWidth - 1, bassHeight);
							animCtx.fillRect(barX, centerY, barWidth - 1, bassHeight);

							// Green (mids) on top of bass
							const midHeight = frame.mid * maxBarHeight;
							animCtx.fillStyle = '#00ff00';
							animCtx.fillRect(barX, centerY - bassHeight - midHeight, barWidth - 1, midHeight);
							animCtx.fillRect(barX, centerY + bassHeight, barWidth - 1, midHeight);

							// Blue (highs) on top of everything
							const highHeight = frame.high * maxBarHeight;
							animCtx.fillStyle = '#0088ff';
							animCtx.fillRect(barX, centerY - bassHeight - midHeight - highHeight, barWidth - 1, highHeight);
							animCtx.fillRect(barX, centerY + bassHeight + midHeight, barWidth - 1, highHeight);
						}

						// Draw border
						animCtx.strokeStyle = '#bee17b';
						animCtx.lineWidth = 1;
						animCtx.strokeRect(waveStartX, waveY, waveWidth, waveHeight);
					}

					// Scanline effect - speed varies with music
					const scanlineSpeed = 2 + (audioLevel * 8);
					scanlineOffset = (scanlineOffset + scanlineSpeed) % size;
					const scanlineOpacity = 0.03 + (audioLevel * 0.1);
					animCtx.fillStyle = `rgba(0, 255, 0, ${scanlineOpacity})`;
					for (let i = scanlineOffset; i < size; i += 4) {
						animCtx.fillRect(0, i, size, 1);
					}

					// Bass-triggered glitch
					if (bassLevel > 0.7) {
						glitchIntensity = Math.max(glitchIntensity, bassLevel);
					}

					// Random glitch effect
					const now = Date.now();
					if (now > nextGlitch) {
						glitchIntensity = 1.0;
						nextGlitch = now + Math.random() * 3000 + 2000;
					}

					if (glitchIntensity > 0) {
						// RGB shift glitch - intensity based on music
						const shift = Math.floor(glitchIntensity * 10 * (1 + audioLevel));
						const imgData = animCtx.getImageData(0, 0, size, size);
						const data = imgData.data;

						for (let i = 0; i < data.length; i += 4) {
							const shiftIndex = i + shift * 4;
							if (shiftIndex < data.length) {
								data[i] = data[shiftIndex]; // R channel shift
							}
						}
						animCtx.putImageData(imgData, 0, 0);

						// Random horizontal glitch lines
						if (Math.random() > 0.7) {
							const y = Math.floor(Math.random() * size);
							const height = Math.floor(Math.random() * 20) + 5;
							const offset = (Math.random() - 0.5) * 30 * glitchIntensity;

							const sliceData = animCtx.getImageData(0, y, size, height);
							animCtx.putImageData(sliceData, offset, y);
						}

						glitchIntensity *= 0.85; // Decay glitch effect
					}

					// Screen flicker - treble reactive
					if (trebleLevel > 0.6 || Math.random() > 0.95) {
						animCtx.fillStyle = `rgba(190, 225, 123, ${Math.random() * 0.1 * (1 + trebleLevel)})`;
						animCtx.fillRect(0, 0, size, size);
					}

					// Pulse glow effect on bass hits
					if (bassLevel > 0.65) {
						const pulseGradient = animCtx.createRadialGradient(size / 2, size / 2 + 40, 0, size / 2, size / 2 + 40, size / 2);
						pulseGradient.addColorStop(0, `rgba(190, 225, 123, ${bassLevel * 0.3})`);
						pulseGradient.addColorStop(1, 'rgba(190, 225, 123, 0)');
						animCtx.fillStyle = pulseGradient;
						animCtx.fillRect(0, 0, size, size);
					}

					// NOW apply rotation and flip to a final canvas
					const rotatedCanvas = document.createElement('canvas');
					rotatedCanvas.width = size;
					rotatedCanvas.height = size;
					const rotatedCtx = rotatedCanvas.getContext('2d');

					rotatedCtx.save();
					rotatedCtx.translate(size / 2, size / 2);
					rotatedCtx.rotate(-Math.PI / 2);
					rotatedCtx.scale(1, -1);
					rotatedCtx.drawImage(animCanvas, -size / 2, -size / 2);
					rotatedCtx.restore();

					// Copy rotated result back to animCanvas
					animCtx.clearRect(0, 0, size, size);
					animCtx.drawImage(rotatedCanvas, 0, 0);

					// Update texture
					normalizedTexture.needsUpdate = true;

					requestAnimationFrame(animateScreen);
				}

				// Start animation
				animateScreen();

				// Extract dominant color for light (sample center of normalized canvas)
				const centerX = Math.floor(size / 2);
				const centerY = Math.floor(size / 2);
				const pixel = ctx.getImageData(centerX, centerY, 1, 1).data;
				const dominantColor = new THREE.Color(pixel[0] / 255, pixel[1] / 255, pixel[2] / 255);

				if (window.computerScreenLight) {
					window.computerScreenLight.color = dominantColor;
					window.computerScreenLight.intensity = 2.0;
				}

				console.log('💻 Computer screen updated with artwork:', artworkUrl);
			}, undefined, (error) => {
				console.error('Failed to load artwork for computer screen:', error);
				// Fallback to green glow
				window.updateComputerScreen(null);
			});
		};

		// Function to update hat material with username text
		window.updateHatWithUsername = function(username) {
			if (!window.character) {
				console.warn('Character not ready for hat update');
				return;
			}

			// Find the hat mesh in the character model (use character.traverse, not modelContainer)
			let hatMesh = null;
			console.log('🔍 Searching for hat mesh on character...');
			window.character.traverse((child) => {
				if (child.isMesh && child.material) {
					const materialName = child.material.name?.toLowerCase() || '';
					console.log('  Character mesh:', child.name, 'material:', child.material.name);
					if (materialName.includes('hat')) {
						hatMesh = child;
						console.log('✅ Found hat mesh:', child.name, 'material:', child.material.name);
					}
				}
			});

			if (!hatMesh) {
				console.warn('Hat mesh not found on character');
				return;
			}

			// Clone the material so we don't affect other instances
			if (!hatMesh.userData.originalMaterial) {
				hatMesh.userData.originalMaterial = hatMesh.material;
			}
			hatMesh.material = hatMesh.material.clone();

			// Store the current hat color to preserve it
			const currentHatColor = hatMesh.material.color.clone();

			// Create canvas - fill with white so material color shows through
			const canvas = document.createElement('canvas');
			canvas.width = 512;
			canvas.height = 512;
			const ctx = canvas.getContext('2d');

			// Fill with white (this gets multiplied by material.color to show hat color)
			ctx.fillStyle = '#ffffff';
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			// Use the ACTUAL hat color from the picker, not from material
			const hatColorHex = window.hatColor || '#282828';

			// Convert hex to RGB (parse the picker color, not material color)
			const hexToRgb = (hex) => {
				const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				return result ? {
					r: parseInt(result[1], 16) / 255,
					g: parseInt(result[2], 16) / 255,
					b: parseInt(result[3], 16) / 255
				} : { r: 0, g: 0, b: 0 };
			};

			// Convert RGB to HSL to get saturation and lightness
			const rgbToHsl = (r, g, b) => {
				const max = Math.max(r, g, b);
				const min = Math.min(r, g, b);
				let h, s, l = (max + min) / 2;

				if (max === min) {
					h = s = 0; // achromatic
				} else {
					const d = max - min;
					s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
					switch (max) {
						case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
						case g: h = ((b - r) / d + 2) / 6; break;
						case b: h = ((r - g) / d + 4) / 6; break;
					}
				}
				return { h, s, l };
			};

			const rgb = hexToRgb(hatColorHex);
			const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);

			// Better contrast calculation that considers saturation and lightness
			// Use luminance formula for perceptual brightness
			const luminance = (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114);

			// For saturated colors, use a different threshold
			// High saturation colors need more careful contrast calculation
			let textColor;
			if (hsl.s > 0.5) {
				// Saturated color - use luminance with lower threshold
				textColor = luminance > 0.45 ? '#000000' : '#ffffff';
			} else {
				// Desaturated color - use standard threshold
				textColor = hsl.l > 0.5 ? '#000000' : '#ffffff';
			}

			console.log(`🎨 Hat color: ${hatColorHex}, HSL: ${JSON.stringify(hsl)}, Luminance: ${luminance.toFixed(2)}, Text: ${textColor}`);

			// Draw username text with contrasting color
			const text = username.toUpperCase();
			ctx.fillStyle = textColor;
			ctx.font = 'bold 16px Arial';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';

			// Add outline for better visibility (inverse of text color)
			ctx.strokeStyle = textColor === '#ffffff' ? '#000000' : '#ffffff';
			ctx.lineWidth = 2;

			// Rotate text 90 degrees, mirror, and position for normalized UVs
			ctx.save();
			// Since UVs are normalized (0,0 to 1,1), position text accordingly
			// Move to the position where the hat front face UVs are mapped
			ctx.translate(canvas.width / 2, canvas.height / 4);
			// Rotate 90 degrees clockwise (Math.PI / 2 radians)
			ctx.rotate(Math.PI / 2);
			// Mirror horizontally
			ctx.scale(-1, 1);
			// Draw text at this rotated and mirrored position
			ctx.strokeText(text, 0, 0);
			ctx.fillText(text, 0, 0);
			ctx.restore();

			// Create texture from canvas
			const texture = new THREE.CanvasTexture(canvas);
			texture.wrapS = THREE.ClampToEdgeWrapping;
			texture.wrapT = THREE.ClampToEdgeWrapping;
			texture.needsUpdate = true;

			// Apply texture to hat material
			if (hatMesh.material.map) {
				hatMesh.material.map.dispose();
			}
			hatMesh.material.map = texture;
			hatMesh.material.color = currentHatColor; // Preserve the original hat color
			hatMesh.material.roughness = 1.0; // Make it less glossy
			hatMesh.material.metalness = 0.0; // No metallic effect
			hatMesh.material.needsUpdate = true;

			console.log('🧢 Hat updated with username:', username.toUpperCase());
		};

		// Update character FACE material with user's profile picture
		// Generic function to apply photoURL to any character's FACE material
		window.applyPhotoToCharacterFace = function(characterScene, photoURL, characterId = 'character') {
			console.log('🎨 applyPhotoToCharacterFace called for:', characterId, 'photoURL:', photoURL);

			if (!characterScene) {
				console.warn('❌ Character scene not provided for FACE material update');
				return;
			}

			// Find the FACE material on the character
			let faceMesh = null;
			characterScene.traverse((child) => {
				if (child.isMesh && child.material && child.material.name === 'FACE') {
					faceMesh = child;
					console.log('✅ Found FACE mesh for', characterId, ':', child.name);
				}
			});

			if (!faceMesh) {
				console.warn('❌ FACE material not found on character:', characterId);
				return;
			}

			if (!photoURL) {
				// No photo - clear texture and set default appearance
				if (faceMesh.material.map) {
					faceMesh.material.map.dispose();
					faceMesh.material.map = null;
				}
				faceMesh.material.color = new THREE.Color(0xffffff);
				faceMesh.material.needsUpdate = true;
				console.log('😶 FACE material cleared for', characterId);
				return;
			}

			// Clone material to avoid affecting other meshes
			faceMesh.material = faceMesh.material.clone();

			// Load profile picture
			const loader = new THREE.TextureLoader();
			loader.crossOrigin = "anonymous";
			loader.load(photoURL, (texture) => {
				// Create canvas to process the image
				const canvas = document.createElement('canvas');
				canvas.width = 512;
				canvas.height = 512;
				const ctx = canvas.getContext('2d');

				// Fill with black background
				ctx.fillStyle = '#000000';
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// Calculate dimensions to fit image while maintaining aspect ratio
				const img = texture.image;
				const scale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.5; // Shrink to 50%
				const scaledWidth = img.width * scale;
				const scaledHeight = img.height * scale;

				// Position the image (adjusted for UV mapping)
				const x = (canvas.width - scaledWidth) / 2;
				const y = (canvas.height - scaledHeight) / 3; // Move down

				// Flip the image vertically to fix upside-down issue
				ctx.save();
				ctx.translate(x + scaledWidth / 2, y + scaledHeight / 2); // Move to center of image
				ctx.scale(1, -1); // Flip vertically
				ctx.drawImage(img, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
				ctx.restore();

				// Create texture from canvas
				const faceTexture = new THREE.CanvasTexture(canvas);
				faceTexture.wrapS = THREE.ClampToEdgeWrapping;
				faceTexture.wrapT = THREE.ClampToEdgeWrapping;
				faceTexture.needsUpdate = true;

				// Apply texture to FACE material
				if (faceMesh.material.map) {
					faceMesh.material.map.dispose();
				}
				faceMesh.material.map = faceTexture;
				faceMesh.material.color = new THREE.Color(0xffffff); // White so texture shows correctly
				faceMesh.material.needsUpdate = true;

				console.log('😀 FACE material updated with profile picture for', characterId);
			}, undefined, (error) => {
				console.error('Failed to load profile picture for FACE material:', characterId, error);
			});
		};

		// Wrapper for local character (backwards compatibility)
		window.updateCharacterFace = function(photoURL) {
			console.log('🎨 updateCharacterFace called with photoURL:', photoURL);
			if (!window.character) {
				console.warn('❌ Character not ready for FACE material update');
				return;
			}
			window.applyPhotoToCharacterFace(window.character, photoURL, 'local-character');
		};

		// Function to create a THREE.js sprite-based name tag
		window.createNameTagSprite = function(username) {
			// Create canvas for the text
			const canvas = document.createElement('canvas');
			const context = canvas.getContext('2d');

			// Set canvas size
			canvas.width = 512;
			canvas.height = 128;

			// Configure text style
			context.font = 'Bold 36px Share, Arial, sans-serif';
			context.textAlign = 'center';
			context.textBaseline = 'middle';

			// Add ">_" prefix for flare
			const displayText = '>_ ' + username.toUpperCase();

			// Draw semi-transparent background
			const textWidth = context.measureText(displayText).width;
			const padding = 16;
			const bgWidth = textWidth + padding * 2;
			const bgHeight = 56;
			const bgX = (canvas.width - bgWidth) / 2;
			const bgY = (canvas.height - bgHeight) / 2;

			context.fillStyle = 'rgba(0, 0, 0, 0.6)';
			context.roundRect(bgX, bgY, bgWidth, bgHeight, 8);
			context.fill();

			// Draw text with outline
			context.strokeStyle = '#000000';
			context.lineWidth = 5;
			context.strokeText(displayText, canvas.width / 2, canvas.height / 2);

			context.fillStyle = '#ffffff';
			context.fillText(displayText, canvas.width / 2, canvas.height / 2);

			// Create texture from canvas
			const texture = new THREE.CanvasTexture(canvas);
			texture.needsUpdate = true;

			// Create sprite material
			const material = new THREE.SpriteMaterial({
				map: texture,
				transparent: true,
				depthTest: false,
				depthWrite: false
			});

			// Create sprite
			const sprite = new THREE.Sprite(material);
			sprite.scale.set(0.8, 0.2, 1); // Much smaller size: Width, height, depth

			return sprite;
		};

		// Function to update name tag sprite text
		window.updateNameTagSprite = function(sprite, username) {
			if (!sprite || !sprite.material || !sprite.material.map) return;

			const canvas = sprite.material.map.image;
			const context = canvas.getContext('2d');

			// Clear canvas
			context.clearRect(0, 0, canvas.width, canvas.height);

			// Redraw with new text
			context.font = 'Bold 36px Share, Arial, sans-serif';
			context.textAlign = 'center';
			context.textBaseline = 'middle';

			// Add ">_" prefix for flare
			const displayText = '>_ ' + username.toUpperCase();

			const textWidth = context.measureText(displayText).width;
			const padding = 16;
			const bgWidth = textWidth + padding * 2;
			const bgHeight = 56;
			const bgX = (canvas.width - bgWidth) / 2;
			const bgY = (canvas.height - bgHeight) / 2;

			context.fillStyle = 'rgba(0, 0, 0, 0.6)';
			context.roundRect(bgX, bgY, bgWidth, bgHeight, 8);
			context.fill();

			context.strokeStyle = '#000000';
			context.lineWidth = 5;
			context.strokeText(displayText, canvas.width / 2, canvas.height / 2);

			context.fillStyle = '#ffffff';
			context.fillText(displayText, canvas.width / 2, canvas.height / 2);

			sprite.material.map.needsUpdate = true;
		};

			// Load the dome surrounding everything
			loadingManager.loadGLTF('build/assets/dome.glb', (domeModel) => {
				const dome = domeModel.scene;
				dome.position.set(0, -15, 0); // Lower to prevent base collision
				dome.scale.set(20, 20, 20);

				// Add to world
				world.graphicsWorld.add(dome);

				// Play dome animation if it exists
				if (domeModel.animations && domeModel.animations.length > 0) {
					console.log('🎬 Found dome animations:', domeModel.animations.map(a => a.name));

					const domeMixer = new THREE.AnimationMixer(dome);

					// Find the "rotate" animation or use the first one
					const rotateAnim = domeModel.animations.find(a => a.name.toLowerCase() === 'rotate') || domeModel.animations[0];
					const domeAction = domeMixer.clipAction(rotateAnim);

					// Set to loop indefinitely at 0.05x speed
					domeAction.setLoop(THREE.LoopRepeat, Infinity);
					domeAction.clampWhenFinished = false;
					domeAction.timeScale = 0.05;
					domeAction.play();

					// Store mixer globally so it can be updated in the render loop
					window.domeMixer = domeMixer;
					window.domeAction = domeAction;

					console.log('🎬 Dome animation playing:', rotateAnim.name, 'duration:', rotateAnim.duration, 'tracks:', rotateAnim.tracks.length);
				} else {
					console.warn('⚠️ No animations found in dome model');
				}

				// Create hollow sphere collision using multiple planes facing inward
				const domeRadius = 80; // Collision radius
				const segments = 12; // More segments for better coverage
				const rings = 12; // More rings for better coverage

				for (let lat = 0; lat < segments; lat++) {
					const theta = (lat / segments) * Math.PI; // 0 to PI

					for (let lon = 0; lon < rings; lon++) {
						const phi = (lon / rings) * Math.PI * 2; // 0 to 2PI

						// Calculate position on sphere
						const x = domeRadius * Math.sin(theta) * Math.cos(phi);
						const y = domeRadius * Math.cos(theta) - 5; // Offset by dome position
						const z = domeRadius * Math.sin(theta) * Math.sin(phi);

						// Create plane facing inward (toward center)
						const planeShape = new CANNON.Plane();
						const planeBody = new CANNON.Body({
							mass: 0,
							shape: planeShape,
							position: new CANNON.Vec3(x, y, z)
						});

						// Point the plane normal toward center (0, -5, 0)
						const centerX = 0;
						const centerY = -5;
						const centerZ = 0;

						const normalX = centerX - x;
						const normalY = centerY - y;
						const normalZ = centerZ - z;

						const length = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
						const nx = normalX / length;
						const ny = normalY / length;
						const nz = normalZ / length;

						// Use lookAt-style quaternion calculation
						const quaternion = new CANNON.Quaternion();
						quaternion.setFromVectors(new CANNON.Vec3(0, 0, 1), new CANNON.Vec3(nx, ny, nz));
						planeBody.quaternion.copy(quaternion);

						world.physicsWorld.addBody(planeBody);
					}
				}
			});

			// Create spatial audio setup
			const audioListener = new THREE.AudioListener();
			const positionalAudio = new THREE.PositionalAudio(audioListener);
			let speakers; // Store speakers reference globally

			// Create 3-band EQ using Web Audio API
			const audioContext = audioListener.context;
			const lowFilter = audioContext.createBiquadFilter();
			const midFilter = audioContext.createBiquadFilter();
			const highFilter = audioContext.createBiquadFilter();
			const lowpassFilter = audioContext.createBiquadFilter();
			const highpassFilter = audioContext.createBiquadFilter();

			// Configure EQ filters
			lowFilter.type = 'lowshelf';
			lowFilter.frequency.value = 320; // Low frequencies
			lowFilter.gain.value = 0;

			midFilter.type = 'peaking';
			midFilter.frequency.value = 1000; // Mid frequencies
			midFilter.Q.value = 0.5;
			midFilter.gain.value = 0;

			highFilter.type = 'highshelf';
			highFilter.frequency.value = 3200; // High frequencies
			highFilter.gain.value = 0;

			// Configure lowpass/highpass filters
			lowpassFilter.type = 'lowpass';
			lowpassFilter.frequency.value = 20000; // Default max
			lowpassFilter.Q.value = 1;

			highpassFilter.type = 'highpass';
			highpassFilter.frequency.value = 20; // Default min
			highpassFilter.Q.value = 1;

			// Create vehicle lowpass filter for in-car effect
			const vehicleLowpass = audioContext.createBiquadFilter();
			vehicleLowpass.type = 'lowpass';
			vehicleLowpass.frequency.value = 20000; // Default off (full range)
			vehicleLowpass.Q.value = 1;

			// Create master volume gain node
			const masterGain = audioContext.createGain();
			masterGain.gain.value = 1.0; // 100%

			// Create analyzer node (AFTER all filters to see post-processed audio)
			const analyser = audioContext.createAnalyser();
			analyser.fftSize = 2048;
			analyser.smoothingTimeConstant = 0.8;

			// Store filters globally for access
			window.eqFilters = {
				low: lowFilter,
				mid: midFilter,
				high: highFilter,
				lowpass: lowpassFilter,
				highpass: highpassFilter,
				vehicleLowpass: vehicleLowpass,
				masterGain: masterGain
			};

			window.audioAnalyser = analyser;

			// Initialize main sound engine for game sounds
			window.soundEngine = soundEngine = new SoundEngine(audioListener);

			// Initialize separate UI sound engine for interface sounds
			window.uiSoundEngine = uiSoundEngine = new SoundEngine(audioListener);

			// Load game sounds
			soundEngine.loadSounds([
				// Footstep sounds
				{ name: 'footstep1', path: 'build/snds/step1.wav', options: { volume: 0.5 } },
				{ name: 'footstep2', path: 'build/snds/step2.wav', options: { volume: 0.5 } },
				{ name: 'footstep3', path: 'build/snds/step3.wav', options: { volume: 0.5 } },
				{ name: 'footstep4', path: 'build/snds/step4.wav', options: { volume: 0.5 } },
				{ name: 'footstep5', path: 'build/snds/step5.wav', options: { volume: 0.5 } },
				{ name: 'footstep6', path: 'build/snds/step6.wav', options: { volume: 0.5 } },
				{ name: 'footstep7', path: 'build/snds/step7.wav', options: { volume: 0.5 } },
				// Ambient background music
				{ name: 'ambience', path: 'build/snds/ambience.mp3', options: { volume: 0.15, loop: true } }
			]).then(() => {
				console.log('Game sounds loaded!');
			});

			// Load UI sounds separately
			uiSoundEngine.loadSounds([
				{ name: 'lock', path: 'build/snds/lock.wav', options: { volume: 0.4 } },
				{ name: 'sentMessage', path: 'build/snds/SentMessage.wav', options: { volume: 0.4 } },
				{ name: 'tock', path: 'build/snds/Tock.wav', options: { volume: 0.3 } },
				// Flappy Bird sounds
				{ name: 'fb_wing', path: 'build/snds/fb_wing.wav', options: { volume: 0.5 } },
				{ name: 'fb_point', path: 'build/snds/fb_point.wav', options: { volume: 0.5 } },
				{ name: 'fb_hit', path: 'build/snds/fb_hit.wav', options: { volume: 0.5 } },
				{ name: 'fb_die', path: 'build/snds/fb_die.wav', options: { volume: 0.5 } }
			]).then(() => {
				console.log('UI sounds loaded!');
				console.log('All sounds loaded!');

				// Resume AudioContext on first user interaction (required by browser autoplay policy)
				const resumeAudio = () => {
					console.log('🎯 User interaction detected, AudioContext state:', audioListener.context.state);
					if (audioListener.context.state === 'suspended') {
						audioListener.context.resume().then(() => {
							console.log('✅ AudioContext resumed - footsteps should work now');
						}).catch(err => {
							console.error('❌ Failed to resume AudioContext:', err);
						});
					} else {
						console.log('✅ AudioContext already running:', audioListener.context.state);
					}
					// Remove listeners after first interaction
					document.removeEventListener('click', resumeAudio);
					document.removeEventListener('keydown', resumeAudio);
				};
				document.addEventListener('click', resumeAudio);
				document.addEventListener('keydown', resumeAudio);

				// Also check immediately
				console.log('🔍 Initial AudioContext state:', audioListener.context.state);

				// Start playing ambient music immediately
				soundEngine.play('ambience');
				console.log('Ambient music started');
			}).catch(error => {
				console.error('Error loading sounds:', error);
			});

			// Update crosshair visibility based on aim mode
			const crosshairElement = document.getElementById('crosshair');
			setInterval(() => {
				if (window.character && crosshairElement) {
					// Show crosshair only when in aim mode (holding E)
					crosshairElement.style.display = window.character.aimMode ? 'block' : 'none';
				}
			}, 16); // 60fps

			// Monitor character movement for footsteps
			let footstepDebugCount = 0;
			let debugCounter = 0;
			setInterval(() => {
				const char = window.character; // Use global reference

				// Debug every 100 cycles (5 seconds)
				if (debugCounter % 100 === 0 && char) {
					// Footstep check (logging disabled)
				}
				debugCounter++;

				if (char && !terminalOpen && !customizationOpen && soundEngine) {
					// Check if character is in a moving state and on ground
					if (isMovingState(char) && char.rayHasHit) {
						const now = Date.now();
						const dynamicInterval = getFootstepInterval(char);

						if (now - lastFootstepTime > dynamicInterval) {
							// Add organic variation to volume and pitch
							const volumeVariation = 0.8 + Math.random() * 0.4; // 0.8 to 1.2
							const pitchVariation = 0.95 + Math.random() * 0.1; // 0.95 to 1.05

							// Calculate volume based on movement speed
							const velocity = char.velocity;
							const speed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
							const speedMultiplier = Math.min(1.0, 0.5 + speed * 0.3); // Louder when faster

							const finalVolume = 0.10 * volumeVariation * speedMultiplier;

							// Play random footstep sound with variation
							const footstepName = getRandomFootstep();

							// Debug logging (only show every 5th footstep to avoid spam)
							if (footstepDebugCount % 5 === 0) {
								// Footstep played (logging disabled)
							}
							footstepDebugCount++;

							soundEngine.play(footstepName, {
								allowOverlap: false,
								volume: finalVolume,
								pitch: pitchVariation
							});
							lastFootstepTime = now;
						}
					}
				}
			}, 50);

			// Load the speakers behind the computer
			loadingManager.loadGLTF('build/assets/speakers.glb', (speakersModel) => {
				const speakers = speakersModel.scene;
				window.speakers = speakers; // Make globally accessible for customization
				speakers.position.set(-10, 0, 5); // Behind the computer, Y at ground level
				speakers.scale.set(1, 1, 1);

				// Calculate bounding box BEFORE rotation
				const bbox = new THREE.Box3().setFromObject(speakers);
				const size = new THREE.Vector3();
				bbox.getSize(size);

				// Now rotate the visual model
				speakers.rotation.y = Math.PI / 2; // Rotate 90 degrees

				// Add to world
				world.graphicsWorld.add(speakers);

				// Apply host customization to speakers if spectator and customization already received
				if (isSpectatorMode && window.hostCustomization) {
					const c = window.hostCustomization;
					speakers.traverse((child) => {
						if (child.isMesh && child.material) {
							const matName = child.material.name;
							if (matName === 'CAB' || matName.toLowerCase().includes('cab')) {
								child.material.color.set(c.speakerCabColor);
							} else if (matName === 'TRIM' || matName === 'SPEAKER_TRIM' || (matName.toLowerCase().includes('trim') && matName.toLowerCase().includes('speaker'))) {
								child.material.color.set(c.speakerTrimColor);
							} else if (matName === 'FACE' || matName.toLowerCase().includes('face')) {
								child.material.color.set(c.speakerFaceColor);
							} else if (matName === 'FRAME' || matName.toLowerCase().includes('frame')) {
								child.material.color.set(c.speakerFrameColor);
							}
							child.material.needsUpdate = true;
						}
					});
					console.log('🎨 Applied host speakers customization on load');
				}

				// Add positional audio to speakers
				speakers.add(positionalAudio);
				positionalAudio.position.set(1, 1, -3.5); // Offset on X, Y, and Z in local space
				positionalAudio.setRefDistance(10); // Distance at which volume starts to drop
				positionalAudio.setMaxDistance(50); // Max distance audio can be heard
				positionalAudio.setRolloffFactor(1); // How quickly sound fades with distance

				// Store globally for direction calculations
				window.positionalAudio = positionalAudio;

				// Make it directional like a real festival speaker (front-facing cone)
				positionalAudio.setDirectionalCone(120, 230, 0.3); // innerAngle, outerAngle, outerGain
				// innerAngle: 120° - Full volume cone in front
				// outerAngle: 230° - Volume drops outside this cone
				// outerGain: 0.3 - Behind the speaker is 70% quieter

				// Create a dynamic lowpass filter for directional muffling
				window.speakerDirectionalLowpass = audioContext.createBiquadFilter();
				window.speakerDirectionalLowpass.type = 'lowpass';
				window.speakerDirectionalLowpass.frequency.value = 20000; // Start at full range
				window.speakerDirectionalLowpass.Q.value = 1;

				// Create bass boost for behind-speaker effect (clippy bass)
				window.speakerDirectionalBass = audioContext.createBiquadFilter();
				window.speakerDirectionalBass.type = 'lowshelf';
				window.speakerDirectionalBass.frequency.value = 150;
				window.speakerDirectionalBass.gain.value = 0; // Start at 0, boost when behind

				console.log('🔊 Directional speaker cone configured with dynamic lowpass');

				// Store speaker position globally for direction calculation
				// Account for the positionalAudio offset in world space
				window.speakerPosition = new THREE.Vector3();
				positionalAudio.getWorldPosition(window.speakerPosition);

				// Create debug visualization for speaker position
				const speakerMarkerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
				const speakerMarkerMaterial = new THREE.MeshBasicMaterial({
					color: 0xff0000,
					transparent: true,
					opacity: 0.8
				});
				window.debugSpeakerMarker = new THREE.Mesh(speakerMarkerGeometry, speakerMarkerMaterial);
				window.debugSpeakerMarker.position.copy(window.speakerPosition);
				window.debugSpeakerMarker.visible = false;
				world.graphicsWorld.add(window.debugSpeakerMarker);

				// Create arrow showing speaker direction (will be updated to actual direction)
				const initialDir = new THREE.Vector3();
				positionalAudio.getWorldDirection(initialDir);
				const arrowHelper = new THREE.ArrowHelper(
					initialDir, // direction
					window.speakerPosition, // origin
					5, // length
					0x00ffff, // cyan color
					1, // headLength
					0.5 // headWidth
				);
				window.debugSpeakerArrow = arrowHelper;
				window.debugSpeakerArrow.visible = false;
				world.graphicsWorld.add(window.debugSpeakerArrow);

				// Create cone visualizations - simpler and more visible
				// Inner cone (145°)
				const innerConeAngle = 145 * Math.PI / 180;
				const innerConeRadius = Math.tan(innerConeAngle / 2) * 15;
				const innerConeGeometry = new THREE.ConeGeometry(innerConeRadius, 15, 32, 1, false);
				const innerConeMaterial = new THREE.MeshBasicMaterial({
					color: 0x00ff00,
					transparent: true,
					opacity: 0.2,
					side: THREE.DoubleSide
				});
				window.debugInnerCone = new THREE.Mesh(innerConeGeometry, innerConeMaterial);

				// Outer cone (230°)
				const outerConeAngle = 230 * Math.PI / 180;
				const outerConeRadius = Math.tan(outerConeAngle / 2) * 15;
				const outerConeGeometry = new THREE.ConeGeometry(outerConeRadius, 15, 32, 1, false);
				const outerConeMaterial = new THREE.MeshBasicMaterial({
					color: 0xffff00,
					transparent: true,
					opacity: 0.15,
					side: THREE.DoubleSide
				});
				window.debugOuterCone = new THREE.Mesh(outerConeGeometry, outerConeMaterial);

				// Back cone (90° to 180° behind - distortion zone)
				// This is a 180° cone (full hemisphere) pointing backwards
				const backConeAngle = 180 * Math.PI / 180; // 180° cone for full rear hemisphere
				const backConeRadius = Math.tan(backConeAngle / 2) * 20; // Massive radius for 180°
				const backConeGeometry = new THREE.ConeGeometry(backConeRadius, 20, 32, 1, false);
				const backConeMaterial = new THREE.MeshBasicMaterial({
					color: 0xff0000,
					transparent: true,
					opacity: 0.25,
					side: THREE.DoubleSide
				});
				window.debugBackCone = new THREE.Mesh(backConeGeometry, backConeMaterial);

				// Position and rotate cones - point from speaker position in positive X direction
				// Cone geometry points down -Y by default, so we rotate to point along +X
				const coneRotation = new THREE.Euler(-Math.PI / 2, 0, Math.PI / 2, 'XYZ');
				window.debugInnerCone.rotation.copy(coneRotation);
				window.debugOuterCone.rotation.copy(coneRotation);

				// Back cone points opposite direction (rotate 180° more on Y)
				const backConeRotation = new THREE.Euler(-Math.PI / 2, 0, -Math.PI / 2, 'XYZ');
				window.debugBackCone.rotation.copy(backConeRotation);

				// Position cones at speaker position, offset along direction
				const coneOffset = new THREE.Vector3(7.5, 0, 0); // Half the cone height along X axis
				window.debugInnerCone.position.copy(window.speakerPosition).add(coneOffset);
				window.debugOuterCone.position.copy(window.speakerPosition).add(coneOffset);

				// Back cone offset in opposite direction (longer cone needs bigger offset)
				const backConeOffset = new THREE.Vector3(-10, 0, 0); // Negative X (backwards)
				window.debugBackCone.position.copy(window.speakerPosition).add(backConeOffset);

				// Add to scene but hide by default
				window.debugInnerCone.visible = false;
				window.debugOuterCone.visible = false;
				window.debugBackCone.visible = false;
				world.graphicsWorld.add(window.debugInnerCone);
				world.graphicsWorld.add(window.debugOuterCone);
				world.graphicsWorld.add(window.debugBackCone);

				console.log('🔍 Debug speaker cones created (press Q to toggle)');

				// Setup materials for shadows and apply saved colors
				speakers.traverse((child) => {
					if (child.isMesh) {
						child.castShadow = true;
						child.receiveShadow = true;
						if (child.material) {
							world.sky.csm.setupMaterial(child.material);

							// Apply saved customization colors - check both lowercase and uppercase
							const matName = child.material.name;
							if ((matName === 'CAB' || matName.toLowerCase().includes('cab')) && window.speakerCabColor) {
								child.material.color.set(window.speakerCabColor);
								console.log('✅ Applied CAB color:', window.speakerCabColor);
							} else if ((matName === 'TRIM' || matName === 'SPEAKER_TRIM' || (matName.toLowerCase().includes('trim') && matName.toLowerCase().includes('speaker'))) && window.speakerTrimColor) {
								child.material.color.set(window.speakerTrimColor);
								console.log('✅ Applied SPEAKER TRIM color:', window.speakerTrimColor);
							} else if ((matName === 'FACE' || matName.toLowerCase().includes('face')) && window.speakerFaceColor) {
								child.material.color.set(window.speakerFaceColor);
								console.log('✅ Applied FACE color:', window.speakerFaceColor);
							} else if ((matName === 'FRAME' || matName === 'SPEAKER_FRAME' || (matName.toLowerCase().includes('frame') && matName.toLowerCase().includes('speaker'))) && window.speakerFrameColor) {
								child.material.color.set(window.speakerFrameColor);
								console.log('✅ Applied SPEAKER FRAME color:', window.speakerFrameColor);
							}
						}
					}
				});

				// Get center position after rotation
				const rotatedBbox = new THREE.Box3().setFromObject(speakers);
				const center = new THREE.Vector3();
				rotatedBbox.getCenter(center);

				// Add physics collision box - swap X and Z because of 90 degree rotation
				const speakersShape = new CANNON.Box(new CANNON.Vec3(size.z / 2, size.y / 2, size.x / 2));
				const speakersBody = new CANNON.Body({
					mass: 0, // Static object (won't move)
					shape: speakersShape,
					position: new CANNON.Vec3(center.x, center.y, center.z)
				});
				world.physicsWorld.addBody(speakersBody);
			});

			// Load the portal for multiplayer (only when hosting)
			loadingManager.loadGLTF('build/assets/portal.glb', (portalModel) => {
				const portal = portalModel.scene;
				window.portal = portal; // Make globally accessible
				portal.position.set(50, 15, 5); // Even further back along X-axis
				portal.scale.set(1, 1, 1);
				portal.rotation.y = Math.PI / 2; // Rotate 90 degrees on Y-axis
				portal.rotation.x = Math.PI / 4; // 45 degrees on X-axis

				// Only add portal to scene if hosting multiplayer
				portal.visible = false; // Hidden by default
				world.graphicsWorld.add(portal);

				// Play portal animation if it exists
				if (portalModel.animations && portalModel.animations.length > 0) {
					const portalMixer = new THREE.AnimationMixer(portal);
					window.portalMixer = portalMixer;
					portalModel.animations.forEach((clip) => {
						const action = portalMixer.clipAction(clip);
						action.loop = THREE.LoopRepeat;
						action.play();
					});
					console.log('🌀 Portal animation playing');
				}

				console.log('🌀 Portal loaded (hidden until hosting)');
			});

			// Computer interaction system
			let nearComputer = false;
			let nearCar = false;
			let radioPromptDismissed = false;

			// Vehicle audio transition
			let vehicleAudioTransition = 0; // 0 = not in vehicle, 1 = fully in vehicle
			let vehicleTransitionStartTime = null;
			const VEHICLE_ENTER_DURATION = 500; // 0.5 seconds to fully fade in/out
			const VEHICLE_EXIT_DURATION = 500; // 0.5 seconds to fade back

			// Bass bounce tracking
			let lastBassLevel = 0;
			let lastBassHitTime = 0;
			const BASS_HIT_COOLDOWN = 150; // Minimum 150ms between hits

			// Check distance to computer every frame
			function checkComputerProximity() {
				if (!character) return;

				const charPos = character.position;
				const distance = charPos.distanceTo(computerPosition);

				if (distance < 3 && !terminalOpen) {
					// Only show prompt for host, not spectators
					if (!isSpectatorMode) {
						nearComputer = true;
						interactionPrompt.innerHTML = 'Press <kbd>F</kbd> to use computer';
						interactionPrompt.classList.add('show');
					} else {
						nearComputer = false;
					}
				} else {
					nearComputer = false;
					if (!nearCar) {
						interactionPrompt.classList.remove('show');
					}
				}
			}

			// Check if character is in a car
			function checkCarProximity() {
				if (!character) return;

				// Check if character is sitting in a vehicle (has controlledObject)
				const inVehicle = character.controlledObject && character.controlledObject.rayCastVehicle;

				if (inVehicle && !nearCar && !radioPromptDismissed) {
					nearCar = true;
					interactionPrompt.innerHTML = 'Press <kbd>R</kbd> for phone';
					interactionPrompt.classList.add('show');

					// Auto-connect to car audio when entering vehicle (only if bluetooth is on)
					if (window.bluetoothEnabled && window.currentAudioOutput !== 'car') {
						window.currentAudioOutput = 'car';
						console.log('🚗 Auto-connected to car audio system');
						// Update UI if settings app is open
						if (document.getElementById('phone-settings-app').classList.contains('active')) {
							window.selectAudioOutput('car');
						}
					}
				} else if (!inVehicle && nearCar) {
					nearCar = false;
					// Reset the dismissed flag when exiting vehicle
					radioPromptDismissed = false;
					if (!nearComputer) {
						interactionPrompt.classList.remove('show');
					}

					// Auto-switch back to stack when exiting vehicle (only if bluetooth is on)
					if (window.bluetoothEnabled && window.currentAudioOutput === 'car') {
						window.currentAudioOutput = 'stack';
						console.log('🏠 Auto-connected to stack audio system');
						// Update UI if settings app is open
						if (document.getElementById('phone-settings-app').classList.contains('active')) {
							window.selectAudioOutput('stack');
						}
					}
				}
			}

			// Add to update loop
			const updateInterval = setInterval(() => {
				// Update portal animation
				if (window.portalMixer) {
					window.portalMixer.update(0.016); // ~60fps delta
				}

				// Smooth interpolation and animation for spectator CHARACTERS - SAME SYSTEM AS HOST!
				if (window.spectatorCharacters && window.spectatorCharacterTargets) {
					const now = performance.now();

					Object.keys(window.spectatorCharacters).forEach(playerId => {
						// Skip loading markers
						if (playerId.includes('_loading') || playerId.includes('_scene')) return;

						const container = window.spectatorCharacters[playerId];
						const target = window.spectatorCharacterTargets[playerId];
						const mixer = window.spectatorAnimationMixers[playerId];
						const animations = window.spectatorAnimations[playerId];

						if (container && target && container.position && target.position) {
							// Calculate velocity magnitude to check if character is moving
							const velocityMag = target.velocity ? target.velocity.length() : 0;
							const isMoving = velocityMag > 0.1;

							// Target position with Y offset applied
							const targetPos = target.position.clone();
							targetPos.y -= 0.57; // Apply Sketchbook.Character offset

							// Calculate distance for adaptive lerp
							const distance = container.position.distanceTo(targetPos);

							// Much more aggressive lerp factors for fast movements
							let lerpFactor;
							if (distance > 5) {
								// Teleport if too far
								container.position.copy(targetPos);
								lerpFactor = 1.0;
							} else if (distance > 2) {
								lerpFactor = 0.8; // Very aggressive catch-up
							} else if (distance > 0.5) {
								lerpFactor = 0.6; // Fast catch-up
							} else if (distance > 0.1) {
								lerpFactor = 0.4; // Medium
							} else {
								lerpFactor = 0.2; // Smooth when very close
							}

							// Smooth interpolate position (if not teleported)
							if (lerpFactor < 1.0) {
								container.position.lerp(targetPos, lerpFactor);
							}

							// Add stronger extrapolation if moving fast
							if (isMoving && target.velocity) {
								const extrapolationTime = velocityMag > 5 ? 0.1 : 0.05; // More prediction for fast movement
								const extrapolation = target.velocity.clone().multiplyScalar(extrapolationTime);
								container.position.add(extrapolation);
							}

							// Smooth interpolate rotation
							if (target.rotation) {
								container.quaternion.slerp(target.rotation, lerpFactor);
							}

							// Update animation mixer with proper delta time (SAME AS HOST - line 10972-10979)
							if (mixer) {
								const now = performance.now();
								// Calculate actual delta time since last update for THIS spectator
								if (!window.spectatorLastAnimUpdate) window.spectatorLastAnimUpdate = {};
								if (!window.spectatorLastAnimUpdate[playerId]) window.spectatorLastAnimUpdate[playerId] = now;
								const animDelta = (now - window.spectatorLastAnimUpdate[playerId]) / 1000; // Convert to seconds
								window.spectatorLastAnimUpdate[playerId] = now;

								mixer.update(Math.min(animDelta, 0.1)); // Cap at 100ms to prevent huge jumps
							}

							// Debug logging (occasional)
							if (Math.random() < 0.05) { // 5% of updates for better visibility
								// Find what's actually running
								let runningAnims = [];
								if (animations) {
									Object.keys(animations).forEach(animName => {
										const action = animations[animName];
										if (action.isRunning()) {
											runningAnims.push(`${animName}(weight:${action.getEffectiveWeight().toFixed(2)})`);
										}
									});
								}
								console.log('🔍 Spectator render loop check:', {
									playerId: playerId,
									hasAnimations: !!animations,
									animationCount: animations ? Object.keys(animations).length : 0,
									hasTarget: !!target,
									targetAnimState: target?.animationState,
									hasMixer: !!mixer,
									runningAnimations: runningAnims,
									currentPos: container.position ? `(${container.position.x.toFixed(1)}, ${container.position.y.toFixed(1)}, ${container.position.z.toFixed(1)})` : 'none',
									targetPos: target?.position ? `(${target.position.x.toFixed(1)}, ${target.position.y.toFixed(1)}, ${target.position.z.toFixed(1)})` : 'none'
								});
							}

							// SAFETY CHECK: Force an animation if NONE are playing (prevents rigid/frozen character)
							if (animations) {
								let anyAnimationRunning = false;
								Object.keys(animations).forEach(animName => {
									if (animations[animName].isRunning() && animations[animName].getEffectiveWeight() > 0.01) {
										anyAnimationRunning = true;
									}
								});

								// Emergency fallback: If nothing is running, play appropriate animation based on velocity
								if (!anyAnimationRunning) {
									console.warn('⚠️ No animation running for spectator:', playerId, 'velocity:', velocityMag.toFixed(2), 'state:', target.animationState);

									// Choose animation based on velocity
									let emergencyAnim = null;
									if (velocityMag > 3) {
										emergencyAnim = Object.keys(animations).find(a => a.toLowerCase() === 'sprint' || a.toLowerCase() === 'run');
									} else if (velocityMag > 0.5) {
										emergencyAnim = Object.keys(animations).find(a => a.toLowerCase() === 'run');
									} else {
										emergencyAnim = Object.keys(animations).find(a => a.toLowerCase() === 'idle');
									}

									if (emergencyAnim) {
										console.log('🚨 Emergency animation recovery:', emergencyAnim);
										animations[emergencyAnim].reset().setEffectiveWeight(1.0).play();
									}
								}
							}

							// Switch animations based on state (EXACT COPY OF HOST SYSTEM)
							if (animations && target.animationState) {
								const targetAnim = target.animationState;

								// Initialize last animation state tracking for this spectator
								if (!window.spectatorLastAnimation) window.spectatorLastAnimation = {};

								// Cache to avoid repeated state changes (SAME AS HOST - line 11003)
								if (window.spectatorLastAnimation[playerId] !== targetAnim) {
									// Animation name mapping (character state → animation clip name)
									const animMap = {
										// Basic movement states
										'Idle': 'idle',
										'IdleRotateLeft': 'idle',
										'IdleRotateRight': 'idle',
										'Walk': 'run',
										'Sprint': 'sprint',
										'StartWalkForward': 'run',
										'StartWalkLeft': 'run',
										'StartWalkRight': 'run',
										'StartWalkBackLeft': 'run',
										'StartWalkBackRight': 'run',
										'EndWalk': 'idle',

										// Jump/fall states
										'JumpIdle': 'jump_idle',
										'JumpRunning': 'jump_running',
										'Falling': 'falling',
										'DropIdle': 'idle',
										'DropRunning': 'run',
										'DropRolling': 'run',

										// Vehicle states
										'Driving': 'driving',
										'Sitting': 'sitting',
										'EnteringVehicle': 'sit_down_left',
										'ExitingVehicle': 'stand_up_left',
										'ExitingAirplane': 'stand_up_left',
										'OpenVehicleDoor': 'open_door_standing_left',
										'CloseVehicleDoorInside': 'close_door_sitting_left',
										'CloseVehicleDoorOutside': 'close_door_standing_left',
										'SwitchingSeats': 'sitting_shift_left'
									};

									// Map the state to animation clip name
									let targetClipName = animMap[targetAnim] || targetAnim.toLowerCase();

									// Try to find matching animation (case-insensitive)
									let matchedAnimName = null;
									Object.keys(animations).forEach(animName => {
										if (animName.toLowerCase() === targetClipName.toLowerCase()) {
											matchedAnimName = animName;
										}
									});

									// Fallback chain: sprint → run → idle
									if (!matchedAnimName) {
										// Special fallback for sprint
										if (targetClipName === 'sprint') {
											matchedAnimName = Object.keys(animations).find(a => a.toLowerCase() === 'run');
										}

										// Final fallback to idle
										if (!matchedAnimName) {
											matchedAnimName = Object.keys(animations).find(a => a.toLowerCase() === 'idle');
										}
									}

									if (matchedAnimName) {
										// Stop all other animations (SAME AS HOST - line 11068-11073)
										Object.keys(animations).forEach(animName => {
											const action = animations[animName];
											if (animName !== matchedAnimName && action.isRunning()) {
												action.fadeOut(0.2);
											}
										});

										// Play the target animation (SAME AS HOST - line 11076-11079)
										const targetAction = animations[matchedAnimName];
										if (!targetAction.isRunning()) {
											targetAction.reset().fadeIn(0.2).play();
										}

										window.spectatorLastAnimation[playerId] = targetAnim;
									}
								}
							}
						}
					});
				}

				// Smooth interpolation and animation for host character (spectator side) - OPTIMIZED v2
				if (window.hostCharacterContainer && window.hostCharacterTarget && window.hostUpdateBuffer) {
					const now = performance.now();
					const target = window.hostCharacterTarget;
					const container = window.hostCharacterContainer;
					const buffer = window.hostUpdateBuffer;

					// Calculate velocity magnitude to check if character is moving
					const velocityMag = target.velocity ? target.velocity.length() : 0;
					const isMoving = velocityMag > 0.1;

					// Render time - slightly in the past (100ms buffer) for smoother interpolation
					const renderTime = now - 100;

					// Find two updates to interpolate between
					let prevUpdate = null;
					let nextUpdate = null;

					for (let i = 0; i < buffer.length - 1; i++) {
						if (buffer[i].receivedAt <= renderTime && buffer[i + 1].receivedAt >= renderTime) {
							prevUpdate = buffer[i];
							nextUpdate = buffer[i + 1];
							break;
						}
					}

					// Fallback: use latest if we don't have buffer data
					if (!prevUpdate || !nextUpdate) {
						prevUpdate = buffer.length > 1 ? buffer[buffer.length - 2] : target;
						nextUpdate = target;
					}

					// Calculate interpolation alpha between the two updates
					const totalTime = nextUpdate.receivedAt - prevUpdate.receivedAt;
					const currentTime = renderTime - prevUpdate.receivedAt;
					let alpha = totalTime > 0 ? currentTime / totalTime : 1;
					alpha = Math.max(0, Math.min(1, alpha)); // Clamp 0-1

					// Interpolate position between prev and next
					let interpPos = new THREE.Vector3(
						prevUpdate.x + (nextUpdate.x - prevUpdate.x) * alpha,
						prevUpdate.y + (nextUpdate.y - prevUpdate.y) * alpha,
						prevUpdate.z + (nextUpdate.z - prevUpdate.z) * alpha
					);

					// Add extrapolation if moving for smoother feel
					if (isMoving && alpha >= 0.8) { // Only extrapolate when close to latest update
						const extrapolationTime = Math.min((now - nextUpdate.receivedAt) / 1000, 0.1);
						interpPos.add(nextUpdate.velocity.clone().multiplyScalar(extrapolationTime));
					}

					// Calculate distance for adaptive lerp
					const distance = container.position.distanceTo(interpPos);

					// Smoother, more aggressive lerp factors
					let lerpFactor;
					if (distance > 5) {
						lerpFactor = 0.6; // Very far, snap quickly
					} else if (distance > 1) {
						lerpFactor = 0.4; // Far - increased from 0.3
					} else if (distance > 0.3) {
						lerpFactor = 0.25; // Medium - increased from 0.2
					} else {
						lerpFactor = 0.15; // Close - increased from 0.12
					}

					// Interpolate position
					container.position.lerp(interpPos, lerpFactor);

					// Interpolate rotation between prev and next quaternions
					if (prevUpdate.quaternion && nextUpdate.quaternion) {
						const interpQuat = prevUpdate.quaternion.clone();
						interpQuat.slerp(nextUpdate.quaternion, alpha);
						container.quaternion.slerp(interpQuat, lerpFactor);
					} else if (nextUpdate.quaternion) {
						container.quaternion.slerp(nextUpdate.quaternion, lerpFactor);
					}

					// Update animation mixer with proper delta time
					if (window.hostAnimationMixer) {
						// Calculate actual delta time since last update
						if (!window.lastHostAnimUpdate) window.lastHostAnimUpdate = now;
						const animDelta = (now - window.lastHostAnimUpdate) / 1000; // Convert to seconds
						window.lastHostAnimUpdate = now;

						window.hostAnimationMixer.update(Math.min(animDelta, 0.1)); // Cap at 100ms to prevent huge jumps

						// Update dome animation mixer if it exists
						if (window.domeMixer) {
							window.domeMixer.update(animDelta);
						}

						// SAFETY CHECK: Force an animation if NONE are playing (prevents rigid/frozen host)
						if (window.hostAnimations) {
							let anyAnimationRunning = false;
							Object.keys(window.hostAnimations).forEach(animName => {
								if (window.hostAnimations[animName].isRunning() && window.hostAnimations[animName].getEffectiveWeight() > 0.01) {
									anyAnimationRunning = true;
								}
							});

							// Emergency fallback: If nothing is running, play appropriate animation based on velocity
							if (!anyAnimationRunning) {
								const hostVelocityMag = velocityMag; // Use velocity from earlier calculation
								console.warn('⚠️ No animation running for host, velocity:', hostVelocityMag.toFixed(2), 'state:', target.animationState);

								// Choose animation based on velocity
								let emergencyAnim = null;
								if (hostVelocityMag > 3) {
									emergencyAnim = Object.keys(window.hostAnimations).find(a => a.toLowerCase() === 'sprint' || a.toLowerCase() === 'run');
								} else if (hostVelocityMag > 0.5) {
									emergencyAnim = Object.keys(window.hostAnimations).find(a => a.toLowerCase() === 'run');
								} else {
									emergencyAnim = Object.keys(window.hostAnimations).find(a => a.toLowerCase() === 'idle');
								}

								if (emergencyAnim) {
									console.log('🚨 Emergency animation recovery for host:', emergencyAnim);
									window.hostAnimations[emergencyAnim].reset().setEffectiveWeight(1.0).play();
								}
							}
						}

						// Switch animations based on state (optimized - cache current anim)
						if (window.hostAnimations && target.animationState) {
							const targetAnim = target.animationState;

							// Cache to avoid repeated state changes
							if (window.lastHostAnimState !== targetAnim) {
								console.log(`🎬 Changing animation: ${window.lastHostAnimState || 'none'} → ${targetAnim}`);
								// Animation name mapping (character state → animation clip name)
								const animMap = {
									// Basic movement states
									'Idle': 'idle',
									'IdleRotateLeft': 'idle',
									'IdleRotateRight': 'idle',
									'Walk': 'run',
									'Sprint': 'sprint',
									'StartWalkForward': 'run',
									'StartWalkLeft': 'run',
									'StartWalkRight': 'run',
									'StartWalkBackLeft': 'run',
									'StartWalkBackRight': 'run',
									'EndWalk': 'idle',

									// Jump/fall states
									'JumpIdle': 'jump_idle',
									'JumpRunning': 'jump_running',
									'Falling': 'falling',
									'DropIdle': 'idle',
									'DropRunning': 'run',
									'DropRolling': 'run',

									// Vehicle states
									'Driving': 'driving',
									'Sitting': 'sitting',
									'EnteringVehicle': 'sit_down_left',
									'ExitingVehicle': 'stand_up_left',
									'ExitingAirplane': 'stand_up_left',
									'OpenVehicleDoor': 'open_door_standing_left',
									'CloseVehicleDoorInside': 'close_door_sitting_left',
									'CloseVehicleDoorOutside': 'close_door_standing_left',
									'SwitchingSeats': 'sitting_shift_left'
								};

								// Map the state to animation clip name
								let targetClipName = animMap[targetAnim] || targetAnim.toLowerCase();

								// Try to find matching animation (case-insensitive)
								let matchedAnimName = null;
								Object.keys(window.hostAnimations).forEach(animName => {
									if (animName.toLowerCase() === targetClipName.toLowerCase()) {
										matchedAnimName = animName;
									}
								});

								// Fallback chain: sprint → run → idle
								if (!matchedAnimName) {
									// Special fallback for sprint
									if (targetClipName === 'sprint') {
										console.warn(`⚠️ 'sprint' animation not found, falling back to 'run'`);
										matchedAnimName = Object.keys(window.hostAnimations).find(a => a.toLowerCase() === 'run');
									}

									// Final fallback to idle
									if (!matchedAnimName) {
										console.warn(`⚠️ Animation '${targetClipName}' not found for state '${targetAnim}', using idle. Available:`, Object.keys(window.hostAnimations));
										matchedAnimName = Object.keys(window.hostAnimations).find(a => a.toLowerCase() === 'idle');
									}
								}

								if (matchedAnimName) {
									// Stop all other animations
									Object.keys(window.hostAnimations).forEach(animName => {
										const action = window.hostAnimations[animName];
										if (animName !== matchedAnimName && action.isRunning()) {
											action.fadeOut(0.2);
										}
									});

									// Play the target animation
									const targetAction = window.hostAnimations[matchedAnimName];
									if (!targetAction.isRunning()) {
										targetAction.reset().fadeIn(0.2).play();
									}

									window.lastHostAnimState = targetAnim;
								}
							}
						}
					}
				}

				// Broadcast host position and animation state to spectators (THROTTLED)
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN && character) {
					// Throttle updates to 30Hz (every ~33ms) instead of 60Hz
					if (!window.lastHostBroadcast) window.lastHostBroadcast = 0;
					const now = performance.now();
					const timeSinceLastBroadcast = now - window.lastHostBroadcast;

					if (timeSinceLastBroadcast >= 33) { // ~30 updates/sec
						window.lastHostBroadcast = now;

						// Get current animation state - use the actual animation being played
						let currentState = 'Idle';
						let hostAnimationData = []; // Collect ALL running animations for smooth blending

						// Best approach: Get the currently playing animation from the mixer
						if (character && character.mixer) {
							const actions = character.mixer._actions;
							if (actions && actions.length > 0) {
								// Map for clip name to state name
								const clipToStateMap = {
									'idle': 'Idle',
									'run': 'Walk',
									'sprint': 'Sprint',
									'jump_idle': 'JumpIdle',
									'jump_running': 'JumpRunning',
									'falling': 'Falling',
									'driving': 'Driving',
									'sitting': 'Sitting',
									'sit_down_left': 'EnteringVehicle',
									'stand_up_left': 'ExitingVehicle',
									'open_door_standing_left': 'OpenVehicleDoor',
									'close_door_sitting_left': 'CloseVehicleDoorInside',
									'close_door_standing_left': 'CloseVehicleDoorOutside',
									'sitting_shift_left': 'SwitchingSeats'
								};

								// Collect ALL running animations (for smooth blending across network)
								for (let action of actions) {
									if (action.isRunning() && action.getEffectiveWeight() > 0.01) {
										const clipName = action.getClip().name;
										const stateName = clipToStateMap[clipName.toLowerCase()] || clipName;

										hostAnimationData.push({
											state: stateName,
											clipName: clipName,
											time: Math.round(action.time * 1000) / 1000, // Round to 3 decimals
											weight: Math.round(action.getEffectiveWeight() * 1000) / 1000
										});

										// Track primary animation (highest weight) for backwards compatibility
										if (action.getEffectiveWeight() > 0.5) {
											currentState = stateName;
										}
									}
								}
							}
						}

						// Get full quaternion rotation for precise orientation
						const quat = new THREE.Quaternion();
						quat.setFromEuler(character.rotation);

						// Check if character is in a vehicle
						const inVehicle = character.occupyingSeat !== null;

						// Prepare car data if car exists
						let carData = null;
						if (window.car && window.car.collision) {
							const carPos = window.car.collision.position;
							const carQuat = window.car.collision.quaternion;
							carData = {
								position: {
									x: Math.round(carPos.x * 1000) / 1000,
									y: Math.round(carPos.y * 1000) / 1000,
									z: Math.round(carPos.z * 1000) / 1000
								},
								rotation: {
									x: Math.round(carQuat.x * 10000) / 10000,
									y: Math.round(carQuat.y * 10000) / 10000,
									z: Math.round(carQuat.z * 10000) / 10000,
									w: Math.round(carQuat.w * 10000) / 10000
								},
								characterInVehicle: inVehicle
							};
						}

						multiplayerWs.send(JSON.stringify({
							type: 'position_update',
							timestamp: now,
							position: {
								x: Math.round(character.position.x * 1000) / 1000,
								y: Math.round(character.position.y * 1000) / 1000,
								z: Math.round(character.position.z * 1000) / 1000
							},
							rotation: {
								x: Math.round(quat.x * 10000) / 10000,
								y: Math.round(quat.y * 10000) / 10000,
								z: Math.round(quat.z * 10000) / 10000,
								w: Math.round(quat.w * 10000) / 10000
							},
							animationState: currentState, // Primary animation for backwards compatibility
							animations: hostAnimationData, // NEW: All running animations with blend weights and times
							velocity: character.velocity ? {
								x: Math.round(character.velocity.x * 100) / 100,
								y: Math.round(character.velocity.y * 100) / 100,
								z: Math.round(character.velocity.z * 100) / 100
							} : null,
							car: carData
						}));
					}
				}

				// Vintage camera zoom removed - spectators use regular camera

				// Broadcast spectator CHARACTER state (full boxman with animations) - THROTTLED
				if (isSpectatorMode && window.spectatorReady && character && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					// Throttle spectator updates to 20Hz (every 50ms)
					if (!window.lastSpectatorBroadcast) window.lastSpectatorBroadcast = 0;
					const now = performance.now();
					const timeSinceLastBroadcast = now - window.lastSpectatorBroadcast;

					if (timeSinceLastBroadcast >= 33) { // 30 updates/sec (same as host)
						window.lastSpectatorBroadcast = now;

						// Get current animation state - use the actual animation being played (SAME AS HOST)
						let currentState = 'Idle';
						let animationData = []; // Collect ALL running animations for smooth blending

						// Best approach: Get the currently playing animation from the mixer
						if (character && character.mixer) {
							const actions = character.mixer._actions;
							if (actions && actions.length > 0) {
								// Map for clip name to state name
								const clipToStateMap = {
									'idle': 'Idle',
									'run': 'Walk',
									'sprint': 'Sprint',
									'jump_idle': 'JumpIdle',
									'jump_running': 'JumpRunning',
									'falling': 'Falling',
									'driving': 'Driving',
									'sitting': 'Sitting',
									'sit_down_left': 'EnteringVehicle',
									'stand_up_left': 'ExitingVehicle',
									'open_door_standing_left': 'OpenVehicleDoor',
									'close_door_sitting_left': 'CloseVehicleDoorInside',
									'close_door_standing_left': 'CloseVehicleDoorOutside',
									'sitting_shift_left': 'SwitchingSeats'
								};

								// Collect ALL running animations (for smooth blending across network)
								for (let action of actions) {
									if (action.isRunning() && action.getEffectiveWeight() > 0.01) {
										const clipName = action.getClip().name;
										const stateName = clipToStateMap[clipName.toLowerCase()] || clipName;

										animationData.push({
											state: stateName,
											clipName: clipName,
											time: Math.round(action.time * 1000) / 1000, // Round to 3 decimals
											weight: Math.round(action.getEffectiveWeight() * 1000) / 1000
										});

										// Track primary animation (highest weight) for backwards compatibility
										if (action.getEffectiveWeight() > 0.5) {
											currentState = stateName;
										}
									}
								}

								// Debug logging (occasional)
								if (Math.random() < 0.01) { // 1% of updates
									console.log('📤 Spectator broadcasting:', {
										primary: currentState,
										blending: animationData.length + ' anims',
										pos: `(${character.position.x.toFixed(1)}, ${character.position.y.toFixed(1)}, ${character.position.z.toFixed(1)})`
									});
								}
							}
						}

						// Get spectator customization data
						let spectatorCustomization = null;
						const savedCustomization = localStorage.getItem('characterCustomization');
						if (savedCustomization) {
							spectatorCustomization = JSON.parse(savedCustomization);
							// Debug log (occasional)
							if (Math.random() < 0.01) {
								console.log('📤 Spectator broadcasting customization:', spectatorCustomization);
							}
						} else {
							console.warn('⚠️ No customization data found in localStorage for spectator');
						}

						multiplayerWs.send(JSON.stringify({
							type: 'spectator_character',
							timestamp: now,
							position: {
								x: Math.round(character.position.x * 1000) / 1000,
								y: Math.round(character.position.y * 1000) / 1000,
								z: Math.round(character.position.z * 1000) / 1000
							},
							rotation: {
								x: Math.round(character.quaternion.x * 10000) / 10000,
								y: Math.round(character.quaternion.y * 10000) / 10000,
								z: Math.round(character.quaternion.z * 10000) / 10000,
								w: Math.round(character.quaternion.w * 10000) / 10000
							},
							animationState: currentState, // Primary animation for backwards compatibility
							animations: animationData, // NEW: All running animations with blend weights and times
							velocity: {
								x: Math.round(character.velocity.x * 1000) / 1000,
								y: Math.round(character.velocity.y * 1000) / 1000,
								z: Math.round(character.velocity.z * 1000) / 1000
							},
							customization: spectatorCustomization // NEW: Username and skin colors
						}));
					}
				}

				if (character) {
					checkComputerProximity();
					checkCarProximity();

					// Update vehicle audio transition with time-based animation
					const inVehicle = character.controlledObject && character.controlledObject.rayCastVehicle;
					const currentTime = Date.now();

					if (inVehicle && vehicleAudioTransition < 1) {
						// Entering vehicle - start timer if not started
						if (vehicleTransitionStartTime === null) {
							vehicleTransitionStartTime = currentTime;
						}

						// Calculate progress based on time elapsed
						const elapsed = currentTime - vehicleTransitionStartTime;
						vehicleAudioTransition = Math.min(1, elapsed / VEHICLE_ENTER_DURATION);
					} else if (!inVehicle && vehicleAudioTransition > 0) {
						// Exiting vehicle - start timer if not started
						if (vehicleTransitionStartTime === null) {
							vehicleTransitionStartTime = currentTime;
						}

						// Calculate progress based on time elapsed
						const elapsed = currentTime - vehicleTransitionStartTime;
						vehicleAudioTransition = Math.max(0, 1 - (elapsed / VEHICLE_EXIT_DURATION));
					} else {
						// Transition complete, reset timer
						vehicleTransitionStartTime = null;
					}

					// Update directional lowpass based on position relative to speakers
					if (window.speakerPosition && window.speakerDirectionalLowpass && window.speakerDirectionalBass && window.world && window.positionalAudio) {
						const camera = window.world.camera;
						// Get the actual world direction the speaker is facing
						const speakerDir = new THREE.Vector3();
						window.positionalAudio.getWorldDirection(speakerDir);
						const toListener = new THREE.Vector3().subVectors(camera.position, window.speakerPosition).normalize();

						// Calculate angle between speaker direction and listener direction
						const angle = speakerDir.angleTo(toListener) * (180 / Math.PI);

						// Apply lowpass based on angle - INSTANT snap, no transition
						// 0-90° = clear (20kHz), 90-180° = BEHIND speakers (180° cone of distortion)
						if (angle < 90) {
							// Front hemisphere - crystal clear
							window.speakerDirectionalLowpass.frequency.value = 20000;
							window.speakerDirectionalBass.gain.value = 0;
						} else {
							// Behind speakers (entire rear 180°) - INSTANT heavy distortion
							window.speakerDirectionalLowpass.frequency.value = 200; // Heavy lowpass to 200Hz
							window.speakerDirectionalBass.gain.value = 18; // +18dB bass boost (clippy)
						}

						// Apply vehicle transition - apply lowpass filter when getting in car
						// Smoothly transition the vehicle lowpass filter based on vehicleAudioTransition
						if (window.eqFilters && window.eqFilters.vehicleLowpass) {
							// Main speakers: When vehicleAudioTransition = 0 (outside): freq = 20000 (no effect)
							//                When vehicleAudioTransition = 1 (inside): freq = 800 (heavy muffling)
							const targetFreq = 20000 - (vehicleAudioTransition * 19200);
							window.eqFilters.vehicleLowpass.frequency.value = targetFreq;
						}

						// Car audio: INVERSE of main speakers
						// When outside car (vehicleAudioTransition = 0): car audio is muffled (800Hz) and quieter
						// When inside car (vehicleAudioTransition = 1): car audio is clear (20000Hz) and full volume
						if (window.carEQ && window.carEQ.outsideLowpass) {
							const carTargetFreq = 800 + (vehicleAudioTransition * 19200);
							window.carEQ.outsideLowpass.frequency.value = carTargetFreq;
						}

						// Adjust car audio volume based on whether inside or outside
						// Outside (0): 30% volume, Inside (1): 100% volume
						if (window.carPositionalAudio) {
							const carVolume = 0.3 + (vehicleAudioTransition * 0.7);
							window.carPositionalAudio.setVolume(carVolume);
						}
					}

					// Update car debug visualizations to follow car
					if (window.car) {
						if (window.debugCarMarker) {
							window.debugCarMarker.position.copy(window.car.position);
						}
						if (window.debugCarArrow) {
							const carDir = new THREE.Vector3();
							window.car.getWorldDirection(carDir);
							window.debugCarArrow.position.copy(window.car.position);
							window.debugCarArrow.setDirection(carDir);
						}
						if (window.debugCarFrontCone) {
							const carFrontOffset = new THREE.Vector3(0, 0, 5);
							carFrontOffset.applyQuaternion(window.car.quaternion);
							window.debugCarFrontCone.position.copy(window.car.position).add(carFrontOffset);
							window.debugCarFrontCone.rotation.copy(window.car.rotation);
							window.debugCarFrontCone.rotation.x += -Math.PI / 2;
						}

						// Bass-reactive suspension - CONSTANT SUB SHAKE!
						if (inVehicle && window.carPositionalAudio && window.carPositionalAudio.isPlaying && window.audioAnalyser && character.controlledObject) {
							const frequencyData = new Uint8Array(window.audioAnalyser.frequencyBinCount);
							window.audioAnalyser.getByteFrequencyData(frequencyData);

							// Focus on DEEP SUB BASS (20Hz - 100Hz, roughly bins 0-10)
							let subBassSum = 0;
							const subBassRange = 10; // Focus on deepest frequencies
							for (let i = 0; i < subBassRange; i++) {
								subBassSum += frequencyData[i];
							}
							const subBassLevel = subBassSum / subBassRange / 255; // Normalize to 0-1

							// Get the vehicle's physics body
							const vehicle = character.controlledObject;
							const vehicleBody = vehicle.rayCastVehicle ? vehicle.rayCastVehicle.chassisBody : null;

							// CONSTANT SHAKING based on sub bass level - suspension wobble!
							if (subBassLevel > 0.1 && vehicleBody) { // Lower threshold
								// Scale shake intensity with bass level - MORE AGGRESSIVE
								const shakeIntensity = (subBassLevel - 0.1) * 200;

								// Apply TORQUE instead of impulse - makes it shake/wobble without moving position
								const randomTorqueX = (Math.random() - 0.5) * shakeIntensity;
								const randomTorqueY = (Math.random() - 0.5) * shakeIntensity * 0.3; // Less rotation around Y
								const randomTorqueZ = (Math.random() - 0.5) * shakeIntensity;

								// Apply angular (rotational) impulse - pure suspension shake!
								vehicleBody.torque.x += randomTorqueX;
								vehicleBody.torque.y += randomTorqueY;
								vehicleBody.torque.z += randomTorqueZ;

								// Also detect PEAKS for extra bounce on bass drops
								const bassDelta = subBassLevel - lastBassLevel;
								const timeSinceLastHit = currentTime - lastBassHitTime;
								const isPeak = bassDelta > 0.05 && subBassLevel > 0.3; // Lower thresholds
								const canHit = timeSinceLastHit > BASS_HIT_COOLDOWN;

								if (isPeak && canHit) {
									// EXTRA VERTICAL IMPULSE on bass drop - bigger bounce
									const bounceStrength = subBassLevel * 100;
									vehicleBody.applyImpulse(
										new CANNON.Vec3(0, bounceStrength, 0),
										new CANNON.Vec3(0, 0, 0)
									);
									lastBassHitTime = currentTime;
									console.log('💥 BASS DROP! Sub:', subBassLevel.toFixed(2), 'Bounce:', bounceStrength.toFixed(2));
								}
							}

							lastBassLevel = subBassLevel;
						}
					}
				}
			}, 100);

			// Handle ` (backtick) key for debug mode toggle
			document.addEventListener('keydown', (e) => {
				if (e.key === '`') {
					let isVisible = false;

					// Toggle speaker cones
					if (window.debugInnerCone && window.debugOuterCone && window.debugBackCone) {
						window.debugInnerCone.visible = !window.debugInnerCone.visible;
						window.debugOuterCone.visible = !window.debugOuterCone.visible;
						window.debugBackCone.visible = !window.debugBackCone.visible;
						isVisible = window.debugInnerCone.visible;
					}

					// Toggle speaker marker and arrow
					if (window.debugSpeakerMarker) {
						window.debugSpeakerMarker.visible = !window.debugSpeakerMarker.visible;
					}
					if (window.debugSpeakerArrow) {
						window.debugSpeakerArrow.visible = !window.debugSpeakerArrow.visible;
					}

					// Toggle car visualizations
					if (window.debugCarMarker) {
						window.debugCarMarker.visible = !window.debugCarMarker.visible;
					}
					if (window.debugCarArrow) {
						window.debugCarArrow.visible = !window.debugCarArrow.visible;
					}
					if (window.debugCarFrontCone) {
						window.debugCarFrontCone.visible = !window.debugCarFrontCone.visible;
					}

					console.log('🔍 Debug cones:', isVisible ? 'VISIBLE' : 'HIDDEN');

					// Show detailed debug info when toggling on
					if (isVisible && window.speakerPosition && window.world && window.positionalAudio) {
						const speakerDir = new THREE.Vector3();
						window.positionalAudio.getWorldDirection(speakerDir);

						console.log('═══════════════════════════════════');
						console.log('🔊 SPEAKER DEBUG INFO:');
						console.log('Speaker Position:', window.speakerPosition);
						console.log('Speaker Direction:', speakerDir);
						console.log('Inner Cone: 120° (Green)');
						console.log('Outer Cone: 230° (Yellow)');

						const camera = window.world.camera;
						const toListener = new THREE.Vector3().subVectors(camera.position, window.speakerPosition).normalize();
						const angle = speakerDir.angleTo(toListener) * (180 / Math.PI);

						console.log('═══════════════════════════════════');
						console.log('📍 YOUR POSITION:');
						console.log('Camera Position:', camera.position);
						console.log('Direction from Speaker:', toListener);
						console.log('Angle from Speaker Front:', angle.toFixed(1) + '°');

						if (angle < 120) {
							console.log('🟢 STATUS: FRONT of speaker (clear audio)');
						} else {
							console.log('🔴 STATUS: BEHIND speaker (muffled + bass boost)');
							const factor = (angle - 120) / 60;
							console.log('Muffling Factor:', (factor * 100).toFixed(1) + '%');
						}
						console.log('═══════════════════════════════════');
					}
				}
			});

			// Handle F key press
			document.addEventListener('keydown', (e) => {
				if (e.key === 'f' || e.key === 'F') {
					if (nearComputer && !terminalOpen && !customizationOpen) {
						// Prevent default F key behavior (vehicle entry)
						e.preventDefault();
						e.stopPropagation();
						e.stopImmediatePropagation();

						// Smoothly decelerate character before opening terminal
						character.velocitySimulator.target.set(0, 0, 0);

						// Check velocity every frame until character stops
						let checkStopInterval = setInterval(() => {
							const speed = character.velocity.length();

							// If character is nearly stopped (velocity < 0.1)
							if (speed < 0.1) {
								clearInterval(checkStopInterval);

								// Fully stop the character
								character.velocity.set(0, 0, 0);
								character.velocitySimulator.position.set(0, 0, 0);
								character.velocitySimulator.velocity.set(0, 0, 0);
								character.velocitySimulator.target.set(0, 0, 0);
								character.angularVelocity = 0;

								// Now open OS
								window.terminalOpen = terminalOpen = true;
								osDiv.classList.add('active');
								interactionPrompt.classList.remove('show');

								// Update OM count display when opening OS
								const omCountElement = document.getElementById('om-count');
								if (omCountElement && window.authState?.isLoggedIn) {
									const oms = window.authState.user?.oms || 0;
									omCountElement.textContent = oms;
									console.log(`🎮 Updated OM display on OS open: ${oms}`);
								}

								// Disable character controls
								world.inputManager.inputReceiver = window.dummyInputReceiver;

								// Enable mouse cursor - exit pointer lock directly
								if (document.pointerLockElement) {
									document.exitPointerLock();
								}

								// Check if chat view is visible and restart polling if needed
								const chatView = document.getElementById('chat-view');
								if (chatView && chatView.style.display === 'block') {
									console.log('📱 Chat view is visible, restarting polling');
									startChatPolling();
								}
							}
						}, 16); // Check every frame (~60fps)

						return false;
					}
				}
			}, true);

			// Handle R key press for radio (universal access)
			document.addEventListener('keydown', (e) => {
				if (e.key === 'r' || e.key === 'R') {
					// Don't toggle if Ctrl+R or Cmd+R (page refresh)
					if (e.ctrlKey || e.metaKey) {
						return;
					}

					// Don't toggle if user is typing in an input field
					if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
						return;
					}

					// Don't toggle if customization menu or terminal is open
					if (window.customizationOpen || window.terminalOpen) {
						return;
					}

					// Prevent the event from propagating to avoid double-firing
					e.preventDefault();
					e.stopPropagation();

					// Dismiss prompt if near car
					if (nearCar && !radioPromptDismissed) {
						radioPromptDismissed = true;
						interactionPrompt.classList.remove('show');
					}
					// Toggle phone/radio
					window.toggleCarRadio();
				}
			}, true);

		}, 100);

		// ========== CAR RADIO FUNCTIONALITY ==========
		const RADIO_API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
			? 'http://localhost:3000'
			: window.location.origin; // Use same domain as the app (Vercel)

		// Radio play count tracking (global scope for radio functions)
		let radioPlayCountTimer = null;
		let radioCurrentTrackId = null;
		let radioCurrentTrackUserId = null;

		// Shuffle array helper
		function radioShuffleArray(array) {
			const shuffled = [...array];
			for (let i = shuffled.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
			}
			return shuffled;
		}

		window.radioOpen = false;
	let radioOpen = window.radioOpen;
		let radioTracksData = [];
		let radioCurrentIndex = -1;
		const carRadioDiv = document.getElementById('car-radio');

		// Global playback state for syncing desktop and phone
		window.currentPlaybackSource = null; // 'desktop' or 'phone'
		window.currentPlaybackTrack = null; // track info
		window.isPlaybackPaused = false;

		// Update phone player UI to match current playback state
		function updatePhonePlayerUI() {
			if (!window.currentPlaybackTrack) return;

			const btn = document.getElementById('radio-play-btn');
			const titleEl = document.getElementById('radio-current-title');
			const artistEl = document.getElementById('radio-current-artist');
			const artEl = document.querySelector('.car-radio-mini-art');

			// Update play/pause button
			if (btn) {
				btn.textContent = window.isPlaybackPaused ? '▶' : '⏸';
			}

			// Update now playing info
			if (titleEl) {
				titleEl.textContent = window.currentPlaybackTrack.title || 'Unknown';
			}
			if (artistEl) {
				artistEl.textContent = window.currentPlaybackTrack.artist || (window.currentPlaybackSource === 'desktop' ? 'Desktop Playback' : 'Unknown Artist');
			}

			// Update artwork
			if (artEl) {
				if (window.currentPlaybackTrack.artworkUrl) {
					artEl.style.backgroundImage = `url('${window.currentPlaybackTrack.artworkUrl}')`;
				} else {
					artEl.style.backgroundImage = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
				}
			}
		}
		window.updatePhonePlayerUI = updatePhonePlayerUI;

		// Toggle car radio
		window.isOpeningPhone = false; // Flag to prevent double-toggling during opening animation
		window.toggleCarRadio = function() {
			// Prevent toggling while phone is in process of opening
			if (window.isOpeningPhone) {
				console.log('⏳ Phone is opening, please wait...');
				return;
			}

			const previousState = window.radioOpen;
			window.radioOpen = radioOpen = !radioOpen;
			console.log(`🔄 Toggling phone: was ${previousState}, now ${radioOpen}`);
			if (radioOpen) {
				window.isOpeningPhone = true; // Set flag to prevent re-toggling
				// Smoothly decelerate character before opening
				if (window.character) {
					character.velocitySimulator.target.set(0, 0, 0);

					// Check velocity every frame until character stops
					let checkStopInterval = setInterval(() => {
						const speed = character.velocity.length();

						// If character is nearly stopped (velocity < 0.1)
						if (speed < 0.1) {
							clearInterval(checkStopInterval);
							window.isOpeningPhone = false; // Clear flag

							// Fully stop the character
							character.velocity.set(0, 0, 0);
							character.velocitySimulator.position.set(0, 0, 0);
							character.velocitySimulator.velocity.set(0, 0, 0);
							character.velocitySimulator.target.set(0, 0, 0);
							character.angularVelocity = 0;

							// Now open the radio
							carRadioDiv.classList.add('active');
							document.getElementById('phone-home').classList.remove('hidden');
							document.getElementById('phone-music-app').classList.remove('active');
							updatePhoneTime();
							document.exitPointerLock();

							// Only disable controls if NOT in a vehicle
							const inVehicle = window.character.controlledObject && window.character.controlledObject.rayCastVehicle;
							if (!inVehicle && window.dummyInputReceiver && window.world) {
								window.world.inputManager.inputReceiver = window.dummyInputReceiver;
							}

							// Load radio tracks if not loaded
							if (radioTracksData.length === 0) {
								loadRadioTracks();
							}

							// Sync phone player UI with current playback
							updatePhonePlayerUI();
						}
					}, 16); // Check every frame (~60fps)
				} else {
					// No character, open immediately
					window.isOpeningPhone = false; // Clear flag immediately for instant open
					carRadioDiv.classList.add('active');
					document.getElementById('phone-home').classList.remove('hidden');
					document.getElementById('phone-music-app').classList.remove('active');
					updatePhoneTime();
					document.exitPointerLock();
					if (radioTracksData.length === 0) {
						loadRadioTracks();
					}

					// Sync phone player UI with current playback
					updatePhonePlayerUI();
				}
			} else {
				window.isOpeningPhone = false; // Clear flag when closing
				carRadioDiv.classList.remove('active');
				console.log('📱 Closing phone...');

				// Use PhoneAppManager to properly close everything
				if (window.PhoneAppManager) {
					PhoneAppManager.closeApp();
				} else {
					console.error('❌ PhoneAppManager not available!');
				}

				// Play lock sound when closing phone
				if (window.uiSoundEngine) {
					window.uiSoundEngine.play('lock');
				}

				// Re-enable character controls (character handles both on-foot and vehicle control)
				if (window.character) {
					window.character.takeControl();
				}
			}
		};

		// Centralized Phone App Management System
		const PhoneAppManager = {
			apps: ['music', 'messenger', 'flappy', 'settings'],
			currentApp: null,

			// Clean up ALL apps before switching
			cleanupAllApps: function() {
				// Close all overlays
				closePhoneAlert();
				const highscores = document.getElementById('flappy-highscores');
				if (highscores) highscores.style.display = 'none';

				// Stop Floaty game
				if (window.flappyGame && window.flappyGame.animationFrame) {
					cancelAnimationFrame(window.flappyGame.animationFrame);
					window.flappyGame.animationFrame = null;
					window.flappyGame.gameStarted = false;
					window.flappyGame.gameOver = false;
				}

				// Stop chat polling
				if (window.phoneChatPolling) {
					stopPhoneChatPolling();
				}

				// Reset messenger to conversations view
				document.getElementById('messenger-chat-view').style.display = 'none';
				document.getElementById('messenger-conversations-view').style.display = 'block';

				// Clear all input focus
				const phoneInputs = document.querySelectorAll('#car-radio input, #car-radio textarea');
				phoneInputs.forEach(input => input.blur());
			},

			// Deactivate ALL apps
			deactivateAllApps: function() {
				this.apps.forEach(app => {
					const appEl = document.getElementById(`phone-${app}-app`);
					appEl.classList.remove('active');
					// NUCLEAR FIX: Use display none to completely remove from layout
					appEl.style.display = 'none';
				});
			},

			// Open a specific app
			openApp: function(appName) {
				// Block music app for spectators
				if (appName === 'music' && isSpectatorMode) {
					showPhoneAlert('Access Denied', 'Music controls are disabled for spectators. The host controls the music.');
					return;
				}

				// Validation check for messenger
				if (appName === 'messenger' && !window.authState?.isLoggedIn) {
					showPhoneAlert('Login Required', 'Please login on the desktop computer first to use Messenger');
					return;
				}

				// Clean up previous app state
				this.cleanupAllApps();

				// Deactivate all apps
				this.deactivateAllApps();

				// Hide home screen
				document.getElementById('phone-home').classList.add('hidden');

				// Activate the requested app
				const activeApp = document.getElementById(`phone-${appName}-app`);
				activeApp.classList.add('active');
				// Show the app with display flex
				activeApp.style.display = 'flex';

				// App-specific initialization
				if (appName === 'messenger') {
					document.getElementById('messenger-conversations-view').style.display = 'block';
					document.getElementById('messenger-chat-view').style.display = 'none';
				} else if (appName === 'flappy') {
					if (window.initFlappyBird) window.initFlappyBird();
				}

				this.currentApp = appName;
				console.log('📱 Opened app:', appName);
			},

			// Close current app and return to home
			closeApp: function() {
				// Clean up current app
				this.cleanupAllApps();

				// Deactivate all apps
				this.deactivateAllApps();

				// Show home screen
				document.getElementById('phone-home').classList.remove('hidden');

				this.currentApp = null;
				console.log('📱 Closed app, returned to home');
			}
		};

		// Expose PhoneAppManager and functions globally
		window.PhoneAppManager = PhoneAppManager;

		window.openPhoneApp = function(appName) {
			PhoneAppManager.openApp(appName);
		};

		window.closePhoneApp = function() {
			PhoneAppManager.closeApp();
		};

		// Open messenger chat from conversations list
		window.openMessengerChat = function() {
			document.getElementById('messenger-conversations-view').style.display = 'none';
			const chatView = document.getElementById('messenger-chat-view');
			chatView.style.display = 'flex';
			// Load chat messages
			loadPhoneChatMessages();
			// Start polling
			if (!window.phoneChatPolling) {
				startPhoneChatPolling();
			}
		};

		// Close messenger chat back to conversations list
		window.closeMessengerChat = function() {
			document.getElementById('messenger-chat-view').style.display = 'none';
			document.getElementById('messenger-conversations-view').style.display = 'block';
			// Stop chat polling when leaving chat
			if (window.phoneChatPolling) {
				stopPhoneChatPolling();
			}
		};

		// Close music app back to home
		window.closePhoneApp = function() {
			// Use centralized cleanup system
			cleanupPhoneMenus();

			// Reset to home screen
			document.getElementById('phone-music-app').classList.remove('active');
			document.getElementById('phone-messenger-app').classList.remove('active');
			document.getElementById('phone-flappy-app').classList.remove('active');
			document.getElementById('phone-settings-app').classList.remove('active');
			document.getElementById('phone-home').classList.remove('hidden');
		};

		// Update phone time
		function updatePhoneTime() {
			const now = new Date();
			const hours = now.getHours();
			const minutes = now.getMinutes().toString().padStart(2, '0');
			document.getElementById('phone-time').textContent = `${hours}:${minutes}`;
		}

		// Phone chat functionality
		let phoneLastMessageTimestamp = 0;
		let phoneDisplayedMessageIds = new Set();
		window.phoneChatPolling = null;

		async function loadPhoneChatMessages() {
			try {
				const response = await fetch(`${RADIO_API_BASE_URL}/api/v1/chat/messages?limit=50`);
				const result = await response.json();
				const phoneChatMessages = document.getElementById('phone-chat-messages');

				if (result.success && result.data.length > 0) {
					phoneChatMessages.innerHTML = '';
					phoneDisplayedMessageIds.clear();

					result.data.forEach(msg => {
						addPhoneChatMessage(msg.username, msg.text, msg.createdAt, msg.photoURL, msg.id, msg.uid);
						phoneLastMessageTimestamp = msg.createdAt;
					});

					// Scroll to bottom
					phoneChatMessages.scrollTop = phoneChatMessages.scrollHeight;
				} else {
					phoneChatMessages.innerHTML = '<div style="color: rgba(255,255,255,0.4); text-align: center; padding: 20px; font-size: 14px;">No messages yet</div>';
				}
			} catch (error) {
				console.error('Error loading phone messages:', error);
			}
		}

		function addPhoneChatMessage(username, text, timestamp, photoURL, msgId, uid) {
			if (phoneDisplayedMessageIds.has(msgId)) return;
			phoneDisplayedMessageIds.add(msgId);

			const phoneChatMessages = document.getElementById('phone-chat-messages');
			const messageDiv = document.createElement('div');
			messageDiv.style.cssText = 'display: flex; gap: 12px; margin-bottom: 16px; align-items: flex-start;';

			const avatar = document.createElement('div');
			avatar.style.cssText = `width: 36px; height: 36px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); flex-shrink: 0; display: flex; align-items: center; justify-content: center; color: #fff; font-weight: bold; font-size: 14px; ${photoURL ? `background-image: url('${photoURL}'); background-size: cover; background-position: center;` : ''}`;
			if (!photoURL) {
				avatar.textContent = username.charAt(0).toUpperCase();
			}

			const content = document.createElement('div');
			content.style.cssText = 'flex: 1; min-width: 0;';

			const header = document.createElement('div');
			header.style.cssText = 'display: flex; align-items: baseline; gap: 8px; margin-bottom: 4px;';

			const usernameLink = document.createElement('a');
			usernameLink.href = `https://www.sublair.com/u/${username}`;
			usernameLink.target = '_blank';
			usernameLink.textContent = username;
			usernameLink.style.cssText = 'color: #00c6ff; font-weight: 600; font-size: 14px; text-decoration: none;';
			usernameLink.onclick = (e) => e.stopPropagation();

			const time = document.createElement('span');
			const date = new Date(timestamp);
			time.textContent = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
			time.style.cssText = 'color: rgba(255,255,255,0.4); font-size: 12px;';

			header.appendChild(usernameLink);
			header.appendChild(time);

			const messageText = document.createElement('div');
			const urlRegex = /(https?:\/\/[^\s]+)/g;
			const linkedText = text.replace(urlRegex, (url) => {
				return `<a href="${url}" target="_blank" rel="noopener noreferrer" style="color: #5b9bd5; text-decoration: underline;">${url}</a>`;
			});
			messageText.innerHTML = linkedText;
			messageText.style.cssText = 'color: rgba(255,255,255,0.9); font-size: 14px; line-height: 1.5; word-wrap: break-word;';

			content.appendChild(header);
			content.appendChild(messageText);
			messageDiv.appendChild(avatar);
			messageDiv.appendChild(content);
			phoneChatMessages.appendChild(messageDiv);
		}

		async function pollPhoneMessages() {
			if (!phoneLastMessageTimestamp) return;

			try {
				const response = await fetch(`${RADIO_API_BASE_URL}/api/v1/chat/messages?limit=10`);
				const result = await response.json();

				if (result.success && result.data.length > 0) {
					const phoneChatMessages = document.getElementById('phone-chat-messages');
					result.data.forEach(msg => {
						if (msg.createdAt > phoneLastMessageTimestamp) {
							addPhoneChatMessage(msg.username, msg.text, msg.createdAt, msg.photoURL, msg.id, msg.uid);
							phoneLastMessageTimestamp = msg.createdAt;
						}
					});
					// Scroll to bottom
					phoneChatMessages.scrollTop = phoneChatMessages.scrollHeight;
				}
			} catch (error) {
				console.error('Error polling phone messages:', error);
			}
		}

		function startPhoneChatPolling() {
			if (window.phoneChatPolling) return;
			window.phoneChatPolling = setInterval(pollPhoneMessages, 2000);
			console.log('📱 Started phone chat polling');
		}

		function stopPhoneChatPolling() {
			if (window.phoneChatPolling) {
				clearInterval(window.phoneChatPolling);
				window.phoneChatPolling = null;
				console.log('📱 Stopped phone chat polling');
			}
		}

		// Phone chat send message
		document.getElementById('phone-chat-send').addEventListener('click', async () => {
			const input = document.getElementById('phone-chat-input');
			const message = input.value.trim();
			if (!message) return;

			if (message.length > 500) {
				alert('Message too long (max 500 characters)');
				return;
			}

			try {
				const sendBtn = document.getElementById('phone-chat-send');
				sendBtn.disabled = true;
				sendBtn.style.opacity = '0.5';

				const response = await fetch(`${RADIO_API_BASE_URL}/api/v1/chat/messages`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						text: message,
						idToken: window.authState.idToken
					})
				});

				const result = await response.json();

				if (!result.success) {
					throw new Error(result.error || 'Failed to send message');
				}

				// Play sent message sound
				if (window.uiSoundEngine) {
					window.uiSoundEngine.play('sentMessage');
				}

				input.value = '';
				// Reload messages to show new message
				await loadPhoneChatMessages();

			} catch (error) {
				console.error('Error sending phone message:', error);
				alert('Failed to send message: ' + error.message);
			} finally {
				const sendBtn = document.getElementById('phone-chat-send');
				sendBtn.disabled = false;
				sendBtn.style.opacity = '1';
			}
		});

		// Phone chat send on Enter key and tock sound on typing
		document.getElementById('phone-chat-input').addEventListener('keypress', (e) => {
			if (e.key === 'Enter') {
				document.getElementById('phone-chat-send').click();
			} else {
				// Play tock sound on keypress with varied pitch like iOS
				if (window.uiSoundEngine) {
					// Random pitch between 0.95 and 1.05 for natural variation
					const pitch = 0.95 + Math.random() * 0.1;
					window.uiSoundEngine.play('tock', { pitch: pitch, allowOverlap: true });
				}
			}
		});

		// Click outside to close car radio
		document.addEventListener('click', (e) => {
			if (window.radioOpen && !customizationOpen) {
				// Don't trigger if clicking close button or back buttons
				if (e.target.classList.contains('car-radio-close') ||
				    e.target.classList.contains('phone-back-btn')) {
					return;
				}
				// Check if click is outside the car radio menu
				if (!carRadioDiv.contains(e.target)) {
					window.toggleCarRadio();
				}
			}
		}, true);

		// Flappy Bird Game Logic
		let flappyGame = {
			canvas: null,
			ctx: null,
			bird: { x: 50, y: 240, velocity: 0, radius: 12 },
			pipes: [],
			score: 0,
			gameStarted: false,
			gameOver: false,
			gravity: 0.15,
			jumpStrength: -4.5,
			pipeGap: 170,
			pipeWidth: 50,
			pipeSpeed: 1.0,
			frameCount: 0,
			animationFrame: null
		};

		window.initFlappyBird = function() {
			flappyGame.canvas = document.getElementById('flappy-canvas');
			flappyGame.ctx = flappyGame.canvas.getContext('2d');

			// Reset game state
			flappyGame.bird = { x: 50, y: 240, velocity: 0, radius: 12 };
			flappyGame.pipes = [];
			flappyGame.score = 0;
			flappyGame.gameStarted = false;
			flappyGame.gameOver = false;
			flappyGame.frameCount = 0;

			document.getElementById('flappy-score').textContent = '0';
			document.getElementById('flappy-start').style.display = 'block';
			document.getElementById('flappy-gameover').style.display = 'none';

			// Add click listener to canvas
			flappyGame.canvas.onclick = function() {
				if (!flappyGame.gameStarted) {
					flappyGame.gameStarted = true;
					document.getElementById('flappy-start').style.display = 'none';
					flappyGame.gameLoop();
				} else if (flappyGame.gameOver) {
					window.initFlappyBird();
				} else {
					flappyGame.bird.velocity = flappyGame.jumpStrength;
					// Play wing sound for jump
					if (window.uiSoundEngine) {
						window.uiSoundEngine.play('fb_wing', { allowOverlap: true });
					}
				}
			};

			// Draw initial state
			flappyGame.draw();
		};

		flappyGame.gameLoop = function() {
			if (!flappyGame.gameStarted || flappyGame.gameOver) return;

			flappyGame.update();
			flappyGame.draw();
			flappyGame.animationFrame = requestAnimationFrame(flappyGame.gameLoop);
		};

		flappyGame.update = function() {
			// Update bird physics
			flappyGame.bird.velocity += flappyGame.gravity;
			flappyGame.bird.y += flappyGame.bird.velocity;

			// Generate pipes
			flappyGame.frameCount++;
			if (flappyGame.frameCount % 150 === 0) {
				const gapY = Math.random() * (flappyGame.canvas.height - flappyGame.pipeGap - 120) + 60;
				flappyGame.pipes.push({
					x: flappyGame.canvas.width,
					gapY: gapY,
					scored: false
				});
			}

			// Update pipes
			for (let i = flappyGame.pipes.length - 1; i >= 0; i--) {
				const pipe = flappyGame.pipes[i];
				pipe.x -= flappyGame.pipeSpeed;

				// Remove off-screen pipes
				if (pipe.x + flappyGame.pipeWidth < 0) {
					flappyGame.pipes.splice(i, 1);
					continue;
				}

				// Score point
				if (!pipe.scored && pipe.x + flappyGame.pipeWidth < flappyGame.bird.x) {
					pipe.scored = true;
					flappyGame.score++;
					document.getElementById('flappy-score').textContent = flappyGame.score;
					// Play point sound
					if (window.uiSoundEngine) {
						window.uiSoundEngine.play('fb_point', { allowOverlap: true });
					}
				}

				// Collision detection
				const birdLeft = flappyGame.bird.x - flappyGame.bird.radius;
				const birdRight = flappyGame.bird.x + flappyGame.bird.radius;
				const birdTop = flappyGame.bird.y - flappyGame.bird.radius;
				const birdBottom = flappyGame.bird.y + flappyGame.bird.radius;

				if (birdRight > pipe.x && birdLeft < pipe.x + flappyGame.pipeWidth) {
					if (birdTop < pipe.gapY || birdBottom > pipe.gapY + flappyGame.pipeGap) {
						// Play hit sound
						if (window.uiSoundEngine) {
							window.uiSoundEngine.play('fb_hit');
						}
						flappyGame.endGame();
					}
				}
			}

			// Check boundaries
			if (flappyGame.bird.y - flappyGame.bird.radius < 0 || flappyGame.bird.y + flappyGame.bird.radius > flappyGame.canvas.height) {
				// Play hit sound for boundary collision
				if (window.uiSoundEngine) {
					window.uiSoundEngine.play('fb_hit');
				}
				flappyGame.endGame();
			}
		};

		flappyGame.draw = function() {
			const ctx = flappyGame.ctx;
			const canvas = flappyGame.canvas;

			// Clear canvas
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			// Draw pipes
			ctx.fillStyle = '#5cb85c';
			for (const pipe of flappyGame.pipes) {
				// Top pipe
				ctx.fillRect(pipe.x, 0, flappyGame.pipeWidth, pipe.gapY);
				// Bottom pipe
				ctx.fillRect(pipe.x, pipe.gapY + flappyGame.pipeGap, flappyGame.pipeWidth, canvas.height - pipe.gapY - flappyGame.pipeGap);

				// Pipe border
				ctx.strokeStyle = '#4a9d4a';
				ctx.lineWidth = 2;
				ctx.strokeRect(pipe.x, 0, flappyGame.pipeWidth, pipe.gapY);
				ctx.strokeRect(pipe.x, pipe.gapY + flappyGame.pipeGap, flappyGame.pipeWidth, canvas.height - pipe.gapY - flappyGame.pipeGap);
			}

			// Draw bird
			ctx.fillStyle = '#ffd700';
			ctx.beginPath();
			ctx.arc(flappyGame.bird.x, flappyGame.bird.y, flappyGame.bird.radius, 0, Math.PI * 2);
			ctx.fill();

			// Bird outline
			ctx.strokeStyle = '#ff8c00';
			ctx.lineWidth = 2;
			ctx.stroke();
		};

		flappyGame.endGame = function() {
			flappyGame.gameOver = true;
			flappyGame.gameStarted = false;
			document.getElementById('flappy-final-score').textContent = `Score: ${flappyGame.score}`;
			document.getElementById('flappy-gameover').style.display = 'block';
			if (flappyGame.animationFrame) {
				cancelAnimationFrame(flappyGame.animationFrame);
			}
			// Play die sound for game over
			if (window.uiSoundEngine) {
				window.uiSoundEngine.play('fb_die');
			}

			// Submit high score if user is logged in
			if (window.authState?.isLoggedIn && flappyGame.score > 0) {
				submitFloatyHighScore(flappyGame.score);
			}
		};

		// High score functions
		async function submitFloatyHighScore(score) {
			try {
				const response = await fetch(`${RADIO_API_BASE_URL}/api/v1/floaty/highscores`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						score: score,
						idToken: window.authState.idToken
					})
				});

				const result = await response.json();
				if (result.success && result.data.isNewHighScore) {
					document.getElementById('flappy-high-score-msg').textContent = '🏆 NEW HIGH SCORE!';
				} else {
					document.getElementById('flappy-high-score-msg').textContent = '';
				}
			} catch (error) {
				console.error('Error submitting high score:', error);
			}
		}

		window.showFloatyHighScores = async function(event) {
			if (event) {
				event.stopPropagation();
			}

			try {
				const response = await fetch(`${RADIO_API_BASE_URL}/api/v1/floaty/highscores?limit=10`);
				const result = await response.json();

				const listDiv = document.getElementById('flappy-highscores-list');

				if (result.success && result.data.length > 0) {
					listDiv.innerHTML = result.data.map((entry, index) => `
						<div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; margin-bottom: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;">
							<div style="display: flex; align-items: center; gap: 10px;">
								<div style="font-size: 18px; font-weight: bold; color: ${index === 0 ? '#ffd700' : index === 1 ? '#c0c0c0' : index === 2 ? '#cd7f32' : '#fff'};">${index + 1}</div>
								<div style="font-size: 16px;">${entry.username}</div>
							</div>
							<div style="font-size: 18px; font-weight: bold;">${entry.score}</div>
						</div>
					`).join('');
				} else {
					listDiv.innerHTML = '<div style="color: rgba(255, 255, 255, 0.6); padding: 20px;">No high scores yet!</div>';
				}

				document.getElementById('flappy-highscores').style.display = 'block';
			} catch (error) {
				console.error('Error loading high scores:', error);
			}
		};

		window.closeFloatyHighScores = function() {
			document.getElementById('flappy-highscores').style.display = 'none';
		};

		// Settings App - Bluetooth and Audio Output
		window.bluetoothEnabled = false;
		window.currentAudioOutput = 'stack'; // 'stack' or 'car'

		// Function to check if audio can play
		window.canPlayAudio = function() {
			// Audio can only play if bluetooth is enabled
			return window.bluetoothEnabled;
		};

		window.toggleBluetooth = function() {
			window.bluetoothEnabled = !window.bluetoothEnabled;
			const toggle = document.getElementById('bluetooth-toggle');
			const circle = toggle.querySelector('div');
			const audioSection = document.getElementById('audio-output-section');

			if (window.bluetoothEnabled) {
				toggle.style.background = '#34c759';
				circle.style.right = '2px';
				circle.style.left = 'auto';
				audioSection.style.opacity = '1';
				audioSection.style.pointerEvents = 'all';
				console.log('📱 Bluetooth enabled - audio routing enabled');
			} else {
				toggle.style.background = 'rgba(255, 255, 255, 0.3)';
				circle.style.left = '2px';
				circle.style.right = 'auto';
				audioSection.style.opacity = '0.5';
				audioSection.style.pointerEvents = 'none';

				// Stop all audio when bluetooth disabled
				if (window.radioAudioElement) {
					window.radioAudioElement.pause();
				}
				if (window.audioElement) {
					window.audioElement.pause();
				}
				// Stop positional audio sources (stack and car)
				if (window.positionalAudio && window.positionalAudio.isPlaying) {
					window.positionalAudio.stop();
				}
				if (window.carPositionalAudio && window.carPositionalAudio.isPlaying) {
					window.carPositionalAudio.stop();
				}
				// Update phone player UI
				const radioBtn = document.getElementById('radio-play-btn');
				if (radioBtn) radioBtn.textContent = '▶';
				// Update desktop player UI
				const desktopBtn = document.getElementById('audio-play-pause');
				if (desktopBtn) {
					desktopBtn.textContent = '▶ PLAY';
					document.getElementById('desktop-audio-status').textContent = 'STOPPED';
				}
				console.log('📱 Bluetooth disabled - all audio stopped');
			}

			// Play tock sound
			if (window.uiSoundEngine) {
				window.uiSoundEngine.play('tock', { pitch: 1.0, allowOverlap: true });
			}
		};

		// Custom phone alert system
		window.showPhoneAlert = function(title, message) {
			document.getElementById('phone-alert-title').textContent = title;
			document.getElementById('phone-alert-message').textContent = message;
			document.getElementById('phone-alert-overlay').style.display = 'flex';
		};

		window.closePhoneAlert = function() {
			document.getElementById('phone-alert-overlay').style.display = 'none';
		};

		// Centralized phone menu cleanup system
		window.cleanupPhoneMenus = function() {
			// Close all overlays
			closePhoneAlert();

			// Close high scores overlay
			const highscores = document.getElementById('flappy-highscores');
			if (highscores) {
				highscores.style.display = 'none';
			}

			// Reset messenger to conversations view
			const messengerChat = document.getElementById('messenger-chat-view');
			const messengerConvos = document.getElementById('messenger-conversations-view');
			if (messengerChat) messengerChat.style.display = 'none';
			if (messengerConvos) messengerConvos.style.display = 'block';

			// Stop flappy game
			if (window.flappyGame && window.flappyGame.animationFrame) {
				cancelAnimationFrame(window.flappyGame.animationFrame);
				window.flappyGame.animationFrame = null;
				window.flappyGame.gameStarted = false;
				window.flappyGame.gameOver = false;
			}

			// Stop chat polling
			if (window.phoneChatPolling) {
				stopPhoneChatPolling();
			}

			// Clear any input focus
			const phoneInputs = document.querySelectorAll('#car-radio input, #car-radio textarea');
			phoneInputs.forEach(input => input.blur());
		};

		window.selectAudioOutput = function(output) {
			if (!window.bluetoothEnabled) return;

			// Stop audio on the OTHER source when switching (realistic bluetooth behavior)
		if (output === 'stack' && window.carPositionalAudio && window.carPositionalAudio.isPlaying) {
			window.carPositionalAudio.stop();
			console.log('🔇 Stopped car audio when switching to stack');
		} else if (output === 'car' && window.positionalAudio && window.positionalAudio.isPlaying) {
			window.positionalAudio.stop();
			console.log('🔇 Stopped stack audio when switching to car');
		}

		window.currentAudioOutput = output;
			const stackCheck = document.getElementById('stack-check');
			const carCheck = document.getElementById('car-check');

			if (output === 'stack') {
				// Stack selected - show filled
				stackCheck.style.border = '2px solid #0a84ff';
				stackCheck.innerHTML = '<div style="width: 12px; height: 12px; border-radius: 50%; background: #0a84ff;"></div>';
				// Car unselected - show empty
				carCheck.style.border = '2px solid rgba(255, 255, 255, 0.3)';
				carCheck.innerHTML = '';
			} else if (output === 'car') {
				// Car selected - show filled
				carCheck.style.border = '2px solid #0a84ff';
				carCheck.innerHTML = '<div style="width: 12px; height: 12px; border-radius: 50%; background: #0a84ff;"></div>';
				// Stack unselected - show empty
				stackCheck.style.border = '2px solid rgba(255, 255, 255, 0.3)';
				stackCheck.innerHTML = '';
			}

			// Update phone player UI to show stopped state
			const radioBtn = document.getElementById('radio-play-btn');
			if (radioBtn) radioBtn.textContent = '▶';

			// Play tock sound
			if (window.uiSoundEngine) {
				window.uiSoundEngine.play('tock', { pitch: 1.2, allowOverlap: true });
			}

			console.log(`📱 Audio output set to: ${output}`);
		};

		// Load tracks for radio
		function loadRadioTracks() {
			console.log('📻 Loading radio tracks from:', RADIO_API_BASE_URL);
			Promise.all([
				fetch(`${RADIO_API_BASE_URL}/api/v1/tracks`).then(r => r.json()),
				fetch(`${RADIO_API_BASE_URL}/api/v1/users`).then(r => r.json())
			])
			.then(([tracksResult, usersResult]) => {
				console.log('📻 Tracks result:', tracksResult);
				console.log('📻 Users result:', usersResult);

				if (tracksResult.success && tracksResult.data) {
					radioTracksData = tracksResult.data;
				}

				const usersData = usersResult.success ? usersResult.data : {};

				// Merge user data
				radioTracksData = radioTracksData.map(track => {
					if (track.user_id && usersData[track.user_id]) {
						const user = usersData[track.user_id];
						return {
							...track,
							artistName: user.displayName || user.username || 'Unknown Artist',
							artistUsername: user.username || null
						};
					}
					return {
						...track,
						artistName: 'Unknown Artist',
						artistUsername: null
					};
				});

				// Shuffle tracks for random order
				radioTracksData = radioShuffleArray(radioTracksData);

				console.log('📻 Loaded', radioTracksData.length, 'tracks');
				displayRadioTracks();
			})
			.catch(error => {
				console.error('Error loading radio tracks:', error);
				document.getElementById('radio-tracklist').innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">Failed to load tracks</div>';
			});
		}

		// Display tracks in radio (supports filtering)
		function displayRadioTracks(tracksToDisplay = radioTracksData) {
			const container = document.getElementById('radio-tracklist');
			container.innerHTML = tracksToDisplay.map((track, displayIndex) => {
				// Find the actual index in the full radioTracksData array
				const actualIndex = radioTracksData.indexOf(track);

				const artistDisplay = track.artistUsername
					? `<a href="https://www.sublair.com/u/${track.artistUsername}" target="_blank" class="artist-link" onclick="event.stopPropagation();">${track.artistName}</a>`
					: (track.artistName || 'Unknown Artist');

				return `
					<div class="car-radio-track-item ${actualIndex === radioCurrentIndex ? 'playing' : ''}" onclick="playRadioTrack(${actualIndex})">
						<div class="car-radio-track-number">${displayIndex + 1}</div>
						<div class="car-radio-track-details">
							<div class="car-radio-track-name">${track.title || 'Unknown'}</div>
							<div class="car-radio-track-meta">${artistDisplay} • ${track.genre || 'Unknown'}</div>
						</div>
					</div>
				`;
			}).join('');
		}

		// Phone search functionality
		document.getElementById('phone-search-input').addEventListener('input', (e) => {
			const query = e.target.value.toLowerCase();
			if (query === '') {
				displayRadioTracks();
			} else {
				const filtered = radioTracksData.filter(track =>
					(track.title && track.title.toLowerCase().includes(query)) ||
					(track.artistName && track.artistName.toLowerCase().includes(query)) ||
					(track.genre && track.genre.toLowerCase().includes(query))
				);
				displayRadioTracks(filtered);
			}
		});

		// Play track from radio
		window.playRadioTrack = function(index) {
			// Check if bluetooth is enabled
			if (!window.canPlayAudio()) {
				showPhoneAlert('Bluetooth Disabled', 'Please enable Bluetooth in Settings to play audio');
				return;
			}

			if (index < 0 || index >= radioTracksData.length) return;

			// Select audio output based on bluetooth setting
			const audioOutput = window.currentAudioOutput === 'car' ? window.carPositionalAudio : window.positionalAudio;
			console.log('🎵 Phone audio routing - Output:', window.currentAudioOutput, 'Audio object exists:', !!audioOutput, 'carPositionalAudio:', !!window.carPositionalAudio, 'positionalAudio:', !!window.positionalAudio);
			if (!audioOutput) {
				console.error('Audio system not ready');
				return;
			}

			// Clear any existing radio play count timer
			if (radioPlayCountTimer) {
				clearTimeout(radioPlayCountTimer);
				radioPlayCountTimer = null;
			}

			radioCurrentIndex = index;
			const track = radioTracksData[index];

			// Store current track ID and user ID for play counting
			radioCurrentTrackId = track.id;
			radioCurrentTrackUserId = track.user_id;

			// Update now playing display
			document.getElementById('radio-current-title').textContent = track.title || 'Unknown';

			const artistElement = document.getElementById('radio-current-artist');
			if (track.artistUsername) {
				artistElement.innerHTML = `<a href="https://www.sublair.com/u/${track.artistUsername}" target="_blank" class="artist-link">${track.artistName}</a>`;
			} else {
				artistElement.textContent = track.artistName || 'Unknown Artist';
			}

			// Update artwork
			const artElement = document.querySelector('.car-radio-mini-art');
			if (track.artwork_url) {
				artElement.style.backgroundImage = `url('${track.artwork_url}')`;
			} else {
				// Fallback gradient if no artwork
				artElement.style.backgroundImage = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
			}

			// Update play button
			document.getElementById('radio-play-btn').textContent = '⏸';

			// Update track list highlighting
			displayRadioTracks();

			// Stop current track if playing on both outputs
			if (window.carPositionalAudio && window.carPositionalAudio.isPlaying) {
				window.carPositionalAudio.stop();
			}
			if (window.positionalAudio && window.positionalAudio.isPlaying) {
				window.positionalAudio.stop();
			}

			// Build stream URL
			const streamUrl = `${RADIO_API_BASE_URL}/api/v1/stream/${track.id}`;
			const outputName = window.currentAudioOutput === 'car' ? 'car' : 'stack';
			console.log(`🎵 Loading track from phone to ${outputName}:`, track.title);

			// Load and play track through selected audio output
			const audioLoader = new THREE.AudioLoader();
			audioLoader.load(streamUrl, (buffer) => {
				audioOutput.setBuffer(buffer);
				audioOutput.setLoop(false);

				// Set volume based on output type
				if (window.currentAudioOutput === 'car') {
					// Car: adjust volume based on whether inside vehicle
					const inVehicle = window.character && window.character.controlledObject && window.character.controlledObject.rayCastVehicle;
					const initialVolume = inVehicle ? 1.0 : 0.3;
					audioOutput.setVolume(initialVolume);

					// Connect to car-specific EQ chain
					const source = audioOutput.getOutput();
					source.disconnect();
					source.connect(window.carEQ.bass);
					window.carEQ.bass.connect(window.carEQ.lowMid);
					window.carEQ.lowMid.connect(window.carEQ.highMid);
					window.carEQ.highMid.connect(window.carEQ.treble);
					window.carEQ.treble.connect(window.carEQ.outsideLowpass);
					window.carEQ.outsideLowpass.connect(window.audioAnalyser);
					window.audioAnalyser.connect(audioOutput.context.destination);
				} else {
					// Stack: use full desktop speaker EQ chain with spatial filters
					audioOutput.setVolume(1.0);
					const source = audioOutput.getOutput();
					source.disconnect();
					source.connect(window.speakerDirectionalBass);
					window.speakerDirectionalBass.connect(window.speakerDirectionalLowpass);
					window.speakerDirectionalLowpass.connect(window.eqFilters.vehicleLowpass);
					window.eqFilters.vehicleLowpass.connect(window.eqFilters.lowpass);
					window.eqFilters.lowpass.connect(window.eqFilters.highpass);
					window.eqFilters.highpass.connect(window.eqFilters.low);
					window.eqFilters.low.connect(window.eqFilters.mid);
					window.eqFilters.mid.connect(window.eqFilters.high);
					window.eqFilters.high.connect(window.eqFilters.masterGain);
					window.eqFilters.masterGain.connect(window.audioAnalyser);
					window.audioAnalyser.connect(audioOutput.context.destination);
				}

				audioOutput.play();
				window.carAudioSource = audioOutput; // Store reference for controls

				// Set global playback state for phone
				window.currentPlaybackSource = 'phone';
				window.currentPlaybackTrack = {
					title: track.title,
					artworkUrl: track.artwork_url,
					trackId: track.id,
					url: streamUrl,
					artist: track.artistName
				};
				window.isPlaybackPaused = false;

				// Broadcast audio sync to spectators
				if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
					multiplayerWs.send(JSON.stringify({
						type: 'audio_sync',
						action: 'play',
						trackData: {
							id: track.id,
							title: track.title,
							artistName: track.artistName,
							artistUsername: track.artistUsername,
							artwork_url: track.artwork_url,
							user_id: track.user_id
						},
						trackIndex: index,
						audioOutput: window.currentAudioOutput,
						timestamp: performance.now()
					}));
					console.log('📡 Broadcasting audio play to spectators:', track.title);
				}

				// Start 30-second timer for play count
				if (radioCurrentTrackId) {
					radioPlayCountTimer = setTimeout(() => {
						window.incrementPlayCount(radioCurrentTrackId, radioCurrentTrackUserId);
						radioPlayCountTimer = null;
					}, 30000); // 30 seconds
					console.log(`⏱️ Started 30-second play count timer for radio track ${radioCurrentTrackId}`);
				}

				// Auto-play next track when current one ends
				audioOutput.onEnded = function() {
					// Clear play count timer if track ends before 30 seconds
					if (radioPlayCountTimer) {
						clearTimeout(radioPlayCountTimer);
						radioPlayCountTimer = null;
					}
					console.log('🔄 Track ended, playing next...');
					window.radioSkipNext();
				};

				console.log(`📱 Playing from phone to ${outputName}:`, track.title);
			}, undefined, (error) => {
				console.error('Error loading phone track:', error);
			});
		};

		// Radio controls
		window.radioTogglePlay = function() {
			// Check if we have a track from desktop that we should control
			if (window.currentPlaybackSource === 'desktop' && window.positionalAudio && window.positionalAudio.buffer) {
				// Control desktop playback
				const btn = document.getElementById('radio-play-btn');
				if (window.positionalAudio.isPlaying) {
					window.positionalAudio.pause();
					window.isPlaybackPaused = true;
					btn.textContent = '▶';
					const playPauseBtn = document.getElementById('audio-play-pause');
					if (playPauseBtn) playPauseBtn.textContent = '▶ PLAY';
					const statusEl = document.getElementById('desktop-audio-status');
					if (statusEl) statusEl.textContent = 'PAUSED';

					// Broadcast pause to spectators
					if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
						multiplayerWs.send(JSON.stringify({
							type: 'audio_pause'
						}));
						console.log('🎵 Broadcasting pause to spectators (from OS)');
					}
				} else {
					window.positionalAudio.play();
					window.isPlaybackPaused = false;
					btn.textContent = '⏸';
					const playPauseBtn = document.getElementById('audio-play-pause');
					if (playPauseBtn) playPauseBtn.textContent = '❚❚ PAUSE';
					const statusEl = document.getElementById('desktop-audio-status');
					if (statusEl) statusEl.textContent = `NOW PLAYING:\n${window.currentPlaybackTrack?.title || 'Unknown Track'}`;

					// Broadcast resume to spectators
					if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
						multiplayerWs.send(JSON.stringify({
							type: 'audio_resume'
						}));
						console.log('🎵 Broadcasting resume to spectators (from OS)');
					}
				}
			} else if (radioCurrentIndex === -1 && radioTracksData.length > 0) {
				// No track loaded, play first phone track
				playRadioTrack(0);
			} else {
				// Control phone playback
				const btn = document.getElementById('radio-play-btn');
				const audioOutput = window.currentAudioOutput === 'car' ? window.carPositionalAudio : window.positionalAudio;
				if (audioOutput) {
					if (btn.textContent === '▶') {
						audioOutput.play();
						window.isPlaybackPaused = false;
						btn.textContent = '⏸';
						// Broadcast resume to spectators
						if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
							multiplayerWs.send(JSON.stringify({
								type: 'audio_sync',
								action: 'resume',
								currentTime: audioOutput.source?.buffer?.duration ? (audioOutput.context.currentTime - audioOutput.source.startedAt) : 0
							}));
							console.log('📡 Broadcasting audio resume');
						}
					} else {
						audioOutput.pause();
						window.isPlaybackPaused = true;
						btn.textContent = '▶';
						// Broadcast pause to spectators
						if (isHosting && multiplayerWs && multiplayerWs.readyState === WebSocket.OPEN) {
							multiplayerWs.send(JSON.stringify({
								type: 'audio_sync',
								action: 'pause'
							}));
							console.log('📡 Broadcasting audio pause');
						}
					}
				}
			}
		};

		window.radioSkipNext = function() {
			if (radioTracksData.length === 0) return;
			// Clear play count timer when skipping
			if (radioPlayCountTimer) {
				clearTimeout(radioPlayCountTimer);
				radioPlayCountTimer = null;
			}
			const nextIndex = (radioCurrentIndex + 1) % radioTracksData.length;
			playRadioTrack(nextIndex);
		};

		window.radioSkipPrev = function() {
			if (radioTracksData.length === 0) return;
			// Clear play count timer when skipping
			if (radioPlayCountTimer) {
				clearTimeout(radioPlayCountTimer);
				radioPlayCountTimer = null;
			}
			const prevIndex = radioCurrentIndex - 1 < 0 ? radioTracksData.length - 1 : radioCurrentIndex - 1;
			playRadioTrack(prevIndex);
		};

		// ========== WELCOME SLIDESHOW ==========
		let currentSlide = 0;
		const totalSlides = 6;

		function updateSlide() {
			// Update slides
			document.querySelectorAll('.welcome-slide').forEach((slide, index) => {
				slide.classList.toggle('active', index === currentSlide);
			});

			// Update dots
			document.querySelectorAll('.welcome-dot').forEach((dot, index) => {
				dot.classList.toggle('active', index === currentSlide);
			});

			// Update buttons
			const prevBtn = document.getElementById('welcome-prev');
			const nextBtn = document.getElementById('welcome-next');
			const startBtn = document.getElementById('welcome-start');

			prevBtn.disabled = currentSlide === 0;

			if (currentSlide === totalSlides - 1) {
				nextBtn.style.display = 'none';
				startBtn.style.display = 'block';
			} else {
				nextBtn.style.display = 'block';
				startBtn.style.display = 'none';
			}
		}

		window.nextSlide = function() {
			if (currentSlide < totalSlides - 1) {
				currentSlide++;
				updateSlide();
			}
		};

		window.prevSlide = function() {
			if (currentSlide > 0) {
				currentSlide--;
				updateSlide();
			}
		};

		window.goToSlide = function(slideIndex) {
			currentSlide = slideIndex;
			updateSlide();
		};

		window.closeWelcome = function() {
			console.log('🎬 closeWelcome called');
			const welcomeOverlay = document.getElementById('welcome-overlay');
			console.log('welcomeOverlay element:', welcomeOverlay);
			welcomeOverlay.classList.remove('active');

			// Clear inline styles that were set by loading manager
			welcomeOverlay.style.opacity = '';
			welcomeOverlay.style.pointerEvents = '';
			welcomeOverlay.style.zIndex = '';

			console.log('Removed active class and cleared inline styles');

			// Set a flag in localStorage so it doesn't show again
			localStorage.setItem('welcomeShown', 'true');
		};

		// Click outside to close
		document.addEventListener('click', (e) => {
			if (customizationOpen) return; // Don't interfere with customization menu

			console.log('Click detected, target:', e.target);
			const welcomeOverlay = document.getElementById('welcome-overlay');
			const welcomeModal = document.querySelector('.welcome-modal');

			console.log('Welcome active?', welcomeOverlay.classList.contains('active'));
			console.log('Click inside modal?', welcomeModal.contains(e.target));

			if (welcomeOverlay.classList.contains('active') &&
			    !welcomeModal.contains(e.target)) {
				console.log('Calling closeWelcome from click outside');
				closeWelcome();
			}
		}, true);

		// Check if welcome has been shown before - DISABLED FOR NOW TO TEST
		// Uncomment the localStorage check once testing is complete
		/*
		window.addEventListener('load', () => {
			const welcomeShown = localStorage.getItem('welcomeShown');
			const welcomeOverlay = document.getElementById('welcome-overlay');

			if (welcomeShown === 'true') {
				welcomeOverlay.classList.remove('active');
			}
		});
		*/

	</script>
</body>

</html>
